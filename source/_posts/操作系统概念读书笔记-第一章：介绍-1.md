---
title: 操作系统概念读书笔记-第一章：介绍-1 基础概念
date: 2021-12-29 22:53:42
img: https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228175748055.png
summary: '本文是《操作系统概念（第九版）》的第一章的读书笔记第一部分，主要介绍了操作系统中的一些基础概念。This blog is the first part of reading notes of  Operating System Concepts (Ninth Edition) chapter 1: Introduction, which tells  the basic ideas of Operating System'
categories:
  - Operating System Concepts Reading Notes
tags:
  - 操作系统
  - Operating System
  - Reading Notes
---

> 本文是《操作系统概念（第九版）》的第一章的读书笔记第一部分，主要介绍了操作系统中的一些基础概念。
>
> This blog is the first part of reading notes of  _Operating System Concepts (Ninth Edition)_ chapter 1: Introduction, which tells  the basic ideas of Operating System

![Chapter 1: Introduction](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228175748055.png)



# Operating System Concepts-Chapter 1: Introduction-1 Basic Concepts 

操作系统概念第一部分是Overview，包括第一章和第二章。

本章主要介绍了操作系统中一些基本概念和操作系统的发展历史/操作系统的种类，以及操作系统的任务。本章的第一部分主要讲解了操作系统的一些基础概念



## 1. What is Operating System?

要说明什么是操作系统，还得从什么是计算机说起

> **What is computer**：
>
> 从硬件上来说，计算机就是一堆硬件，包括鼠标、显示器、CPU、显卡等等；而对于我们用户来说，计算机就是一个黑箱子，我们坐在计算机前面，通过鼠标、键盘等等方式为计算机输入数据，计算机计算后会通过显示屏把输出（图像）输出出来。

然而就像我们去买显卡的时候一样，我们知道显卡可以用来进行图形渲染，带来更好的游戏体验。然而我们在买显卡的时候买到的却是一个硬件，我们也没有办法直接使用

因此，在我们和计算机的一堆硬件之间存在一个管理员，这个管理员帮助我们管理计算机的硬件，把我们的需求转换为对计算机硬件的调用，**这个管理员就是操作系统**。



### A. 操作系统的概念

我们首先需要对操作系统有一个大的认知，即`操作系统是一个在用户和硬件之间的程序`



### B. 操作系统的目标

操作系统的目标如下：

- 执行用户的程序，并能够简化用户解决问题的过程
- 让计算机更加易于使用
- 以高效的方式使用计算机的硬件，从而提高性能

因此说白了，操作系统的目的其实就是两个：向下，`高效的使用硬件`；向上，`让计算机对用户更加易用`

因此未来介绍的包括存储管理、内存管理等等都是为了更加易用这个目标，而存储管理则视为了高效的使用硬件





## 2. Computer System Structure

当我们提到操作系统的时候，通常指的是操作系统这个软件，只不过这个软件和硬件结合的非常紧密。

而当我们提到计算机系统的时候，计算机系统不仅仅指硬件的集合，实际上还指包括硬件在内的，操作系统等软件的集合。因此计算机系统的结构从下到上如下：

- **硬件**：我们的文档需要保存在硬盘中，我们的程序需要被CPU运行，显示器上的图像需要被显卡渲染，网络数据的收发需要网卡……硬件提供了最基础的计算机的资源
- **操作系统**：操作系统可以控制、管理各种各样的硬件，并且为多个用户的多种程序调度硬件资源
- **应用程序**：应用程序负责调用硬件资源，解决用户的需求，例如文芳编辑器、编译器、汇编器、数据库软件等等
- **用户**：用户通过调用引用程序解决他们的问题，用户可以是具体的人，也可以是其他的电脑前的用户（本机是运算发生的地方，而用户在的电脑负责产生运算请求并发到本机）等等

具体的图示如下

![计算机系统的结构图](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229170838604.png)



## 3. Resource in Computer System

根据上面的讲解，从应用程序的角度和用户的角度来看，计算机系统中的资源可以分为下面的两种：

- 硬件资源（应用程序的角度向下看）
  - **主机资源**：包括CPU和内存
  - **外部设备资源**：包括
    - 外部存储设备：U盘、固态/机械硬盘、光驱/光盘等等
    - 外部输入输出设备：键盘（字符作为输入），显示器（图像作为输出），打印机（喷出的油墨作为输出），鼠标（位置作为输入）
    - 其他设备：例如网线接头
- 软件资源（用户的角度向下看）
  - 系统程序：例如操作系统、编译器等等系统的软件
  - 应用程序：MS Office套装、CAD软件以及用户自己开发的程序等等
  - 工具软件

具体的结构图如下：

![计算机系统具有的资源](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229173958594.png)





## 4. Operating System Definition

操作系统的定义实际上非常多，从不同的角度能够给出操作系统不同的定义



### A. Resource Allocator

从资源管理的角度，操作系统就是一个资源分配器（包括软件、硬件）。而作为资源分配者，操作系统就需要满足以下的要求：

- 管理所有的资源
- 兼顾公平与效率，即不同的用户、程序请求同一个资源的时候，系统要确保公平以及效率

更加具体的，操作系统管理的硬件资源如下：

- CPU管理：CPU的分配和控制，即决定那个程序能用多久的CPU
- 内存管理：分配和回收内存空间，关于为什么要进行内存管理在后面会有更多的介绍
- 设备管理：分配和控制IO设备，例如把文档以怎么样的方式保存到磁盘上、键盘输入的字符该怎样的处理
- 文件管理：管理文件的权限，这个文件谁能看到、谁能修改……

<img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229200640120.png" alt="操作系统管理的硬件资源" style="zoom:50%;" />



### B. Control Program

另外一方面，从操作系统的功能来说，操作系统像一个管理程序，用于：

- 防止错误的发生
- 阻止对计算机不正确的使用



### C. More Definition

其实操作系统目前并没有一个广泛通用的定义，维基百科上的定义如下

> **From Wikipedia**：
>
> 操作系统（英语：Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。
>
> 操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统。许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用命令行界面，将图形用户界面视为一种非必要的应用程序。
>
> 操作系统理论在计算机科学中，为历史悠久而又活跃的分支；而操作系统的设计与实现则是软件工业的基础与内核。
>
> ![维基百科上对操作系统的定义](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229201749524.png)



从外观上来描述操作系统，它的特点如下：

- 买电脑时厂商附带的一切：Windows、MacOS、VMS、Multics
- 开机后一直在运行的程序







## 5. Dual-mode of Operating System

实际上操作系统在运行过程中具有两种状态：**用户态（User Mode）**和**内核态（Kernel Mode）**

- **User Mode**：处于用户态的程序仅仅可以执行非特权指令，例如1+1

- **Kernel Mode**：处于内核态的程序可以执行所有的指令，包括特权指令。

通常来说，特权指令指的是一些如果操作不当可能会导致系统崩溃的指令，例如清除内存、重置时钟、读取磁盘等等。因此如果不对这些特权指令加以保护（即所有用户都可以使用），那么垃圾程序员写出来的烂代码很可能就会搞崩系统。



为了区分用户态和内核态的程序，在硬件（CPU）上通常会用一个比特位来进行标识，称为**模式位（mode bit）**。例如处于用户态的程序user mode bit是1，而处于内核态的程序的user mode bit是0。





## 6. System Call

为了保护系统不会因为垃圾程序员导致的崩溃，系统通过不同的模式来保护一些高危的指令。例如对磁盘进行读写的指令如果使用不当可能会造成磁盘损坏，但由于我们在程序中经常会有读写文件的操作，例如C语言的fread、Python的open等等。而文件就保存在磁盘上，因此读写文件在计算机底层就一定会包含对磁盘进行操作的指令。

只是由于读写磁盘这些特权指令使用的非常频繁，经常在用户态的程序中被调用，因此就需要为用户态的程序提供仅可以在内核态运行的指令的接口/入口/函数API。**这些函数称为系统调用(System Call)**。

在系统调用的时候，我们的程序会取调用这些系统提供的函数，因此在执行这些函数的时候，程序的控制流会短暂的移交到系统提供的函数中。此时我们程序的模式位会改变为内核态。在内核提供的函数完成调用后，程序控制流会返回我们的程序，此时程序的模式位会改回我们原先的特权态。

称进行系统调用时，程序控制流转移到系统中为**陷入内核（trap in kernel）**。

因此一次系统调用的过程中我们程序的控制流和对应的状态位变化如下，横轴为时间。

![系统调用的时序图](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229211610111.png)





## 7. Computer Startup

正如前面所讲，操作系统本身也是一个软件，只不过这个软件和QQ、微信这类软件不同：QQ和微信是运行在操作系统上的软件，他们通过各种各样的系统调用来调用硬件资源，结合自己的逻辑控制与判断完成任务；而操作系统是直接运行在硬件上的，负责管理硬件以及提供各种各样的系统调用。因此尽管两者都是软件，两者所处的层级并不同，正如前面的计算机系统的结构图中展示的一样。

![计算机系统的结构图](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229170838604.png)

正是因为这份特殊性，系统这个软件的启动和QQ这类普通的软件启动的方式不同。QQ这类普通软件（Windows上的exe、Linux上的o）我们双击即可运行，这是因为操作系统在背后帮我们干了非常多的事情，例如：申请一块内存空间用来存放QQ这个程序的指令、把QQ这个程序的指令从磁盘中读取出来并放到申请到的内存的位置中去（加载）、调用CPU去解析、执行QQ程序中的指令……

![操作系统也是一个软件](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229214549149.png)

但是系统的启动是完全基于一个裸的硬件的，因此在启动系统的时候并不会像启动QQ一样有操作系统为其准备好各种各样的环境。取而代之的是有一个叫做引导程序（Bootloader）为操作系统准备各种环境，引导程序会首先进行设备自检、初始化周边设备，然后加载操作系统，即从磁盘中读取操作系统内核可执行文件的指令序列，然后复制到内存中。

因此计算机启动的过程首先运行引导程序，然后由引导程序进行设备的自检，而后引导、初始化操作系统



## 8. Computer System Organization

前面我们从层次上介绍了计算机系统的结构（Structure），下面从硬件的角度介绍计算机系统的组成（Organization）。

计算机系统的组成包含多种多样的设备，通常会有：

- 一个或多个CPU
- 一个或多个磁盘
- 一个或多个USB设备
- 一个或多个显示器

然而一个经典的CPU的执行流程是：用户通过键盘鼠标、磁盘等输入输出设备把数据输入（鼠标点击、键盘敲击、读取磁盘中的文件）到计算机，接下来数据被CPU计算得到结果，最后结果通过显示器或者磁盘输出（显示或者保存）。

而由于多种不同的设备读取到的数据的形式可能不同，而CPU只能够处理一种格式的数据，因此就需要在硬件上有控制器（Device Controller）或者适配器（Device Adapter），他们负责把从磁盘、鼠标、键盘读取到的原始数据处理转化为CPU可以直接处理的数据，然后让CPU进行处理，或者是把CPU处理之后的数据转换为显示器可以显示的数据。

此外，数据在电路中的传输是以分时的电信号的形式传输的，传播速度为光速，因此需要设备保存下数据，因此就有了存储器（Memory）。

<img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229221140892.png" alt="计算机系统的组成" style="zoom:150%;" />





## 9. Bus

上面说到，数据在不同的设备间传递，而每个设备都会有自己的Controller或者Adapter以实现和CPU的交互。数据的传输需要有实体，这个实体在计算机中实际上就是总线（Bus）。

通过总线我们就可以实现让不同的设备（买来的机器自带的设备还是我们自己外加的附加设备/周边设备/第三方设备）之间进行数据的交互。

<img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229221706606.png" alt="总线让内存和CPU之间进行交互" style="zoom:150%;" />



## 10. I/O Operation

还是在上面说到，不同的设备每个设备都会有一个控制器/适配器，设备可以通过控制器/适配器和CPU进行数据间的交互。然而通常来说，每个控制器/适配器都会有一个自己的缓存（buffer），用来存储暂时的输入。

使用buffer的原因也很简单，就是因为设备读取输入的速度的问题。例如我们现在希望从磁盘中读取一个文本文件（例如，三国演义），然后让CPU把这个文本文件里的每个句子在句子末尾添加一个回车，接下来再把处理后的文本文件保存到磁盘中去。

![三国演绎的文本文件](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229223014684.png)

然而在读取三国演义的时候有一个问题就是磁盘的读取速度是有上限的，假设一毫秒只能读取文本文件的一半，而作为用户我们当然是希望文本文件一次性被读完，然后被CPU一次性处理完之后保存到磁盘中。

因此这个时候就是缓存的作用了，buffer可以暂时存储已经读取到的一半的文件，接下来等待后一半读取完了之后统一交给CPU处理。

其实同样的例子还发生在键盘上，假设我们现在写一个程序，读取用户输入的句子，并将输入的句子打印在屏幕上。那么由于键盘是一次一个字符的传输，因此我们如果希望能够完整的把一句话打印在屏幕上，就需要一个缓冲区来保存先前所有输入的字符，然后等待用户按下回车结束输入，再把缓冲区中的句子发送给CPU，让CPU处理完后交给屏幕显示。

因此对于CPU而言，CPU的操作就是把数据从内存中移入到某个设备的缓冲区，或者把数据从某个设备的缓冲区中移动到内存中。至于具体的数据在缓冲区的保存和从缓冲器移动到内存都是由设备控制器/适配器完成的。

称数据从内存到控制器缓冲区/从控制器缓冲区到内存中的一次操作为一次**I/O操作（I/O Operation）**。

由于I/O操作发生在内存和设备控制器/适配器之间，而每个设备都会有自己的控制器/适配器，因此实际上操作系统可以并发的(Concurrent)和多个设备之间进行I/O操作。

> **为什么需要内存/主存（内存又称为主存）**：
>
> 我们上面的讲解中说道，各种控制器读取到的数据需要移入内存中才能够被CPU处理，而CPU处理完的数据也需要保存到内存中才能够被设备保存（输出到磁盘或者屏幕上）。
>
> 那么为什么数据需要经过内存/主存？原因就在于**各种设备运行的速度/访问的时间不同**
>
> 借用_现代操作系统_中的图片，CPU从寄存器中获取需要处理的数据只需要1纳秒，从内存中获取需要处理的数据需要10纳秒，而从磁盘中获取数据则需要10毫秒，基本上$10^3$的数量级的差距。
>
> 因此如果CPU直接从设备中获取需要处理的数据，那么CPU就不得不等待这些设备，因此就会浪费大量的时间。所以提高CPU的利用率，降低等待时间/加快速度，所有的数据都需要被放到内存中去。
>
> ![各种设备的访问时间](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229224334928.png)





## 11. Interrupt

上面说道，I/O操作是内存和设备控制器的缓冲区之间的数据交换，这个过程的目的在于加快稍后CPU数据的获取（CPU可以直接从内存中获取数据而非等待设备控制器）。一个典型的CPU的I/O操作的流程其实如下（假设还是上面的读取文件后给每个句子后面添加回车）：

- CPU首先发出通知给控制器，要求控制器把数据放到内存中的某个位置上去
- 接下来CPU发出这样的指令给控制器后就继续去执行其他的程序的指令去了，而在CPU执行其他指令的这段时间，控制器就会去设备上获取数据（读取文件或者等待用户输入）
- 当控制器完成读取后，会发送消息给CPU，通知CPU读取已经完成。
- CPU在收到控制器发来的消息后，会中止当前正在执行的指令，继续去每个句子后添加回车。

具体的时序图如下：

```mermaid
	sequenceDiagram
    CPU->>USB Port 1: Fetch the data from file zzzzzz for me
    USB Port 1 -->> Main Memory: Put data1： xxxxxxx on yyyyyyy
    USB Port 1 -->> Main Memory: Put data2： xxxxxxx on yyyyyyy
    USB Port 1 -->> Main Memory: .....
    USB Port 1 -->> Main Memory: Put dataN： xxxxxxx on yyyyyyy
    USB Port 1 -->> CPU: All data you need is put on yyyyyyy
    CPU -->> Main Memory: I need data on yyyyyy
    Main Memory -->> CPU: Here is your data: xxxxxxx
```

![CPU与控制器的交互](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230191239374.png)

因此，称在某些情况下计算机中止当前程序的运行，并转而去运行其他的程序的现象为**中断(Interruput)**。上面的例子就是典型的I/O中断，即由于输入输出导致的中断。而导致中断发生的事件称为**中断事件(Interrupt Event)**。

除了I/O中断以外，还有很多类型的中断，例如上面的执行系统调用（System Call），以及CPU执行用户程序时发生的运算错误，例如除0错误。

实际上中断是计算机系统中非常常用的机制，因为中断可以让原有的程序放弃CPU并且让CPU执行新的程序。

此外，中断分为两类，一类是**可屏蔽的中断（Maskable Interrupt）**，一类是**不可屏蔽的中断（Non-Maskable Interruptable）**。可屏蔽的中断表示中断事件导致的中断并不会立即中止当前程序的运行。CPU可能在稍后来响应这个中断事件，例如上面的把文件从磁盘读入到内存完成后，控制器向CPU发送的中断可能并不会立即让CPU中止运行当前的程序，来处理内存中的程序。因为CPU当前运行的程序可能是具有更高优先级的。例如在后面我们会讲到的同步。当前程序会特地的禁止CPU响应中断。

此外，CPU对可屏蔽的中断的另外一种响应就是忽略中断。

对于不可屏蔽的中断，CPU会立即中断当前运行的程序，然后处理中断。例如如果上面读取完成的事件发出的是不可屏蔽的中断的话，CPU就会立即处理这个中断，而处理中断的方式就是继续运行我们的文本处理程序。

根据中断发生的原因，中断可以分为三类：

- **程序产生的中断**：程序产生的中断是用户的程序在运行的过程中，某些意外事件（中断事件）发生，导致向CPU发出了中断。常见的程序产生的中断有：除0中断、溢出中断、系统调用（虽然系统的函数被视为程序的一部分，但是系统的函数本身也可以视为一段程序，因此调用系统的函数就会"中止"我们的程序，而运行系统的程序（新的程序），因此在这个含义上，系统调用也可以视为中断）
- **I/O中断**：I/O中断即指由I/O设备产生的中断，常见的如上面的读取完成中断，此外还有文件不存在这类中断
- **计时器中断**：由计算机系统上的一个叫做计时器的硬件产生的中断（关于计时器稍后会讲）。





## 12. Timer

计时器本身是在计算机硬件系统上的一个硬件，类似于手表中的石英可以以固定的频率震动，计时器可以以固定的时间间隔（Unix中是1/60秒）发出一个中断。这个中断通常称为**计时器中断（Timer Interrupt）**。这个固定的时间间隔称为**时间片（Time Share）**。

不同于磁盘读取完成中断，计时器中断的意义不在于运行某个特定的中断处理程序，而在于通知操作系统（当前程序），他（你）已经占用CPU够久了，该把CPU让给别的程序来运行了。

因此计时器的目的其实就在于通过分时的CPU占用实现类似于并行的效果，提升多用户使用的体验（多道程序）。而之所以需要不断的中断的原因在于CPU（假设只有一个核心，虽然现在的CPU经常都是8核、16核）一次只能运行一个程序，因为一个程序被编译出来之后可能只有几百KB，但是在汇编层次的机器码而言，会有成千上万的指令。这些指令运行和解释起来就需要一个CPU（的核心）。

因此，操作系统中的计时器机制的特点如下：

- 通过简单的计时 --> 中断，避免了无穷循环和硬件资源的永久霸占
- 在一定的时间间隔后会发出一个中断
- 当中断发生后，当前进程可能会被kill掉，而其占用的资源会被释放，例如加锁的文件（文件加锁在后面会讲，但是目前只需要明白为了避免文件被两个程序同时修改导致的不同步，程序在修改文件的时候通常会给文件加锁，避免其他人同时修改文件）

此外，计时器有的时候也被称为**看门狗（Watch Dog Timer）**

虽然我们上面说计时器中断并不会类似文件读取完成中断一样，会调用我们指定的中断处理程序（我们的加回车程序）来处理中断。但是其实计时器中断也会去调用一个特殊的中断处理程序。这个中断处理程序是系统里已经写好的程序。这个程序的目的就是把当前程序的一些变量从寄存器中保存到内存中去，然后决定下一个需要运行的程序，接下来把下一个需要运行的程序的变量等内容从内存中加载到寄存器中去。



## 13. Interrupt Handling

当中断发生的时候（例如计时器中断），操作系统具体是如何完成整个中断的过程的？

首先我们需要明白，中断的定义就是中止运行当前程序，然后去运行新的程序。因此对中断的处理其实就包含两步，第一步就是中止当前程序的运行，第二步就是运行新的程序。

对于中止当前程序的运行，需要做的首先就是保存当前程序运算到中间得到的一些中间变量。例如我们让一个程序循环从1加到1000，例如：

```python
sum = 0
for i in range(1, 1001):
    sum += i
print(i)
```

那么在加到50的时候程序可能由于时间片用完了，导致程序需要被中断，CPU转而去运行别的程序。此时需要保存循环变量i。以及保存在寄存器的中间变量sum。

接下来第二步就是运行新的程序，即**中断处理程序(Interruput Handler或者Interrupt Service Routine，ISR)**。在计算机内部，中断的表示是利用一个整数来表示的。而接下来去运行中断处理程序处理中断处理程序。由于中断可能会有很多种，因此中断处理程序也会有很多。为此需要指定一个中断 -- >中断处理程序的映射表，这个映射表称为**中断表(Interrupt Table)**。一个典型的中断表如下

<img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230152940124.png" alt="中断表" style="zoom:50%;" />

如果是上面假设的计时器中断（中断的目的就在于把CPU让给下一个程序）的话，那么就会去运行计时器中断处理程序，计时器中断处理程序会从CPU的就绪队列中挑去下一个需要执行CPU的进程，然后把这个进程的变量和程序计数器加载到寄存器中，从而开始运行下一个程序。

以上就是一个典型的中断处理的过程。

除了正常的中断处理意外，还有可能发生的一个情况就是中断冲突。

在一个操作系统中，中断发生的次数非常多，每秒可能就会有一百多次。由于中断发生的原因可能会非常多，例如上面的IO中断，那么就可能会出现一个现象就是系统正在处理一个中断的时候另外一个中断发生了。例如上面的磁盘读取完成中断发生后，正在运行我们后续的程序的时候（中断处理程序），另外一个中断事件发生了，例如时间片用完。此时就会发生中断的冲突。

因此为了处理多个中断冲突的情况，系统为不同的中断设定不同的优先级。高优先级的中断会中断掉低优先级的中断处理程序，而低优先级的中断会等待高优先级的中断完成。注意，中断冲突发生的情况一定是CPU当前正在运行一个中断的处理函数。

因此处理中断的时候就会有两种处理方式，第一种就是A图中的低优先级的Y中断的中断处理函数等待高优先级的X中断的中断处理程序完成，第二种就是B图中的高优先级的Y中断的中断处理程序中断了低优先级的X中断的中断处理程序。

![两种中断冲突处理方式](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230144720338.png)





## 14. I/O Processing

正如前面所说的，I/O指的是由CPU发起的，内存和I/O设备之间数据的交互。前面我们只是泛泛的说了一下系统是如何处理输入输出请求的。其实在真实的情境下，I/O的处理分为两种：

- **同步I/O（Synchronous）**：同步I/O指的是当CPU向控制器发出I/O请求后，CPU会空转以等待控制器完成I/O。在此期间CPU不会运行其他的任何程序。
- **异步I/O（Asynchronous）**：异步I/O指的是当CPU先控制发出I/O请求后，CPU会立马中断发出I/O请求的程序（例如添加回车的程序），然后运行别的程序，一直直到控制读取完成后向CPU发出中断。当CPU收到中断之后就会中断其他的程序，转而继续运行添加回车的程序（当然这个取决于当前运行的程序和中断的优先级）。

这两种I/O处理的方式如下图，A图中同步的I/O随着事件流逝，user占用的CPU会等待读取完成的中断。而B图中异步的I/O则是发出I/O请求后立即返回，同时user占用的CPU立刻去运行其他的程序。

![两种I/O处理方式](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230154003231.png)



此外，由于每个I/O设备都会有自己的控制器，因此每个I/O设备可能都会处于不同的状态（是否在响应I/O请求）。因此在系统中有一张表来维护每个设备的状态，这个表称为**设备状态表(Device-Status Table)**

![设备状态表](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230160557297.png)





## 15. Storage Structure

在计算机系统中，有不少硬件都可以进行数据的存储，例如寄存器、磁盘、内存(主存)，甚至包括控制器的缓冲区。但是计算机的存储结构通常指磁盘、内存这类专门用于存储的硬件在内的存储系统。

通常，计算机的存储结构中包含以下硬件：

- **内存/主存（Main Memory）**：主存是唯一的CPU可以直接获取数据的设备。内存中的数据是**易失性的（volatile）**，即断电后数据会全部遗失。
- **二级存储（Secondary Memory）**：二级存储是对主存的扩展，其内部的数据是**非易失性的（nonvolatile）**。
- **磁盘（Magnetic Disks）**：磁盘是由可以保存磁场的材料制成的。数据在其内部以磁的形式保存
  - 通常而言，数据在磁盘上按照**磁道（Track）**、**扇区（Sector）**的形式记录在磁盘上。
  - 磁盘上的**设备控制器(Disk Controller)**帮助完成计算机和磁盘之间的沟通，包括磁信号到电信号的转换。

通常在考虑存储器的选择的时候，会权衡速度、价格和容量三个方面的因素。一般而言速度越快、容量越大，价格就会越高。因此系统中存储器的分层结构（Storage-Device Hierarchy）如下图

<img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230163108041.png" alt="存储器的分层结构" style="zoom:150%;" />

从上到下单位价格容量越来越低，而速度越来越慢。

在前面放过一张图，图中描述了CPU访问每个设备、获取到数据需要的时间。一般来说访问内存需要10纳秒左右的时间，虽然寄存器的访问速度非常快，但是CPU内板载的寄存器首先非常有限，其次价格非常高昂，因此退而求其次，就有了**高速缓存(Cache)**。

计算机中的二八定律指出80%的访问都是针对20%的数据的，因此可以把内存中一些经常被访问的数据加载到高速缓存中去，CPU每次要从内存中获取数据前先从高速缓存中去看看，如果高速缓存中有的话就直接获取数据即可，如果没有再去内存中获取数据。

因此如果绝大多数CPU需要的数据都在缓存中的话，系统的运行速度实际上可以有极大地提升。

![各种设备的访问时间](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229224334928.png)





## 16. Multiprocessors

前面我们所有的讲解都是基于一个CPU，并且CPU中只有一个核心这个前提展开的，然而在现代的计算机中，有些系统可能不止有一个CPU，换而言之我们现在的计算机系统有些是多处理器的（Multiprocessors）的系统。

多处理器的系统有如下的好处：

- **大吞吐量（Increased Throughput）**
- **便宜（Economy of scale）**
- **更加可靠/容错更好（Graceful Degradation/fault tolerance）**

通常来说，多处理器系统有两种架构：

- **非对称多处理器架构（Asymmetric Multiprocessing）**：对称处理多处理架构指处理器之间是对称的，即在操作系统看来，没有多个处理器，只有一个处理器，所有的线程不加以区分，具体由那个处理器执行是随机的，所有处理器之间共享内存。

  ![对称多处理器架构](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230165903630.png)

- **对称对处理器架构（Symmetric Multiprocessing）**：非对称多处理架构指处理器与处理器之间是非对称的，有些处理器专注于处理用户的程序（线程），而有些处理器则专注于处理系统线程

两者的对比图如下：

![Asymmetric v.s. Symmetric](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230170031905.png)





## 17. Multicore

前面我们说了可能存在不止一个处理器的系统，其实现在的计算机中一个处理器有多个核心，类似于多处理器的系统架构，多核心的CPU的好处和多处理器的系统的好处是类似的。

多核心的CPU主要有三种设计：

- **共享缓存（Shared Cache）**：共享缓存的CPU中的多个核心之间会共享cache，而运算则是独立的。知名的一些产品有：IBM POWER4/5 family、Sun UltraSPARC-IV、Fujitsu SPARC64-VI、Sun Niagara、Intel Yonah/Merom family

  ![共享缓存的CPU设计](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230170816531.png)

- **共享IO接口（Shared I/O Interface）**：CPU可以通过总线和其他各个设备之间进行数据的交互，例如和内存。而共享I/O接口的多核处理器的设计则是两个处理器有单独的运算单元和缓存，只有I/O接口是共享的。一些知名的产品包括：Intel Itanium2、AMD dual-core Opteron 

  ![共享I/O接口的CPU](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230171118342.png)

- **共享外壳(?)（Shared data packet）**：这种多核心CPU的设计两个核心基本上就是独立的CPU，我实在不知道怎么翻译data packet……

  ![共享外壳的CPU](https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230171323203.png)

