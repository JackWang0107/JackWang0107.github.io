<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>李宏毅ML2021-Spring-3: Neural Network Training Manual</title>
      <link href="/2022/01/10/li-hong-yi-ml2021-spring-3-neural-network-training-manual/"/>
      <url>/2022/01/10/li-hong-yi-ml2021-spring-3-neural-network-training-manual/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是李宏毅Machine Learning 2021 Spring 第二节课Introduction of Machine / Deep Learning的笔记，本节课主要讲解了深度学习的训练攻略</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110183944100.png" alt="第二节课：Neural Network Training Manual"></p><h1 id="李宏毅ML2021-Spring-3-Neural-Network-Training-Manual"><a href="#李宏毅ML2021-Spring-3-Neural-Network-Training-Manual" class="headerlink" title="李宏毅ML2021-Spring-3: Neural Network Training Manual"></a>李宏毅ML2021-Spring-3: Neural Network Training Manual</h1><p>我们在前面的一节课以Youtube人数预测这个案例贯穿始终，在介绍Machine Learning / Deep Learning基础概念的同时，从线性模型入手，讲解了神经网络模型。</p><p>此外，我们还讲解了Machine Learning中训练一个模型的流程（Procedure）。我们复习一下，这三步分别是：</p><ol><li>定义模型（含参函数）</li><li>定义损失函数（根据我们的数据）</li><li>优化（训练）模型（神经网络是通过梯度下降）</li></ol><p>然而其实神经网络中进行训练的时候，直接使用梯度下降往往会出现很多的问题，导致模型训练不出来。除此以外，我们上节课其实海遗留了不少问题，例如为什么神经网络要用Deep的而不是Fat的。这些内容在本节课都会进行讲解。</p><h2 id="1-Framework-of-ML"><a href="#1-Framework-of-ML" class="headerlink" title="1. Framework of ML"></a>1. Framework of ML</h2><p>我们首先规范化一下我们的（训练）模型（神经网络）时候整体的框架。</p><p>首先，我们根据我们需要完成的任务来收集数据，所有的数据被分为两部分，<strong>一部分是包含label的训练数据</strong>，而<strong>另外一部分是不包含label的测试数据</strong>：</p><ul><li><strong>Training Data</strong>：${(x^1,\hat y^1),(x^2,\hat y^2),(x^3,\hat y^3),\cdots,(x^N,\hat y^N)}$</li><li><strong>Testing Data</strong>：${x^{N+1},x^{N+2},x^{N+3},\cdots,x^{N+M}}$</li></ul><blockquote><p>PS：其实，我们在手机数据的时候是不会划分测试数据和训练数据的，换而言之我们收集数据的时候都是$(x,\hat y)$这样的键值对。然后我们收集完数据之后再对数据进行拆分，其中一部分分为训练数据，而另外一部分分为测试数据。</p><p><strong>这就意味我们其实是有测试数据的label的</strong>。但是注意，我们要当做没有，原因会在本文的后面讲解</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110212204164.png" alt="训练和测试数据"></p><p>而具体每一个具有label的数据，我们称为一个示例（example），即$(x^i,\hat y^i),i=1,\cdots,N$。在不同的问题中，$x^i$和$y^i$的表现形式不同。例如：</p><ul><li>在语音辨识（Speech Recognition）问题中，$x^i$是输入的音频，而输出的$\hat y$是音素(Phoneme，类似于音标)</li><li>在图像识别（Image Recognition）问题中，$x^i$是输入的图片，而输出的$\hat y$是图片中的物品的名称/类别(Class)</li><li>在语者辨识（Speaker Recognition）问题中，$x^i$是输入的音频，而输出的$\hat y$是说话的人的名字</li><li>在机器翻译（Machine Translation）问题中，$x^i$是带翻译的文本，而输出的$\hat y$是目标语言的文本</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110214031998.png" alt="不通问题中x和y的形式不同"></p><p>接下来，有了训练数据和测试数据之后，我们就能够训练、测试我们的模型</p><ul><li><p>首先是训练阶段</p><ol><li>训练阶段的第一件事，就是定义出来一个含有位置参数的函数$y=f_\theta(x)$，注意，以后我们用$\theta$表示模型中的参数</li><li>接下来，我们要定义一个loss，loss是一个函数，因此有的时候又被称为loss function。Loss function的输入是模型中的参数，用于判定这组参数是好还是不好</li><li>最后一步就是求解一个Optimization的问题，即找一个$\theta^*$，能够让$L(\theta)$最小</li></ol><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110214209790.png" alt="训练阶段"></p></li><li><p>在训练阶段之后，就是测试阶段</p><ol><li><p>我们用得到的$\theta^*$来对所有的测试数据中的数据进行预测，即</p><script type="math/tex; mode=display">y^i=f_{\theta^*}(x^i), \qquad\qquad i=N+1,N+2,\cdots,N+M</script></li><li><p>接下来就可以用我们预测得到的${y^{N+1},y^{N+2},\cdots,y^{N+M}}$，例如把预测得到的结果上传到Kaggle上去（后面的课程的作业的要求）</p></li></ol></li></ul><h2 id="2-General-Guide"><a href="#2-General-Guide" class="headerlink" title="2. General Guide"></a>2. General Guide</h2><p>下面的这张图就是神经网络训练的攻略手册，可以帮助我们训练出来高精度的模型。当然适用于我们前期训练模型</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110223158424.png" alt="模型训练攻略"></p><p>整个攻略是从上到下的，因此当我们发现模型得到的精度不高，或者是模型根本没有训练起来的时候，第一步就是先检查模型在训练数据上的损失。</p><p>有人可能会问，为什么模型在测试集上的表现不好反而要先去检查训练集上的损失呢？</p><p>其实检查训练集上的损失是为了先检查模型有没有学习到东西。虽然说模型可能表现很差，但是通过这一步能看到模型训练时候的loss有没有下降，如果没有下降，那么就意味着很可能代码写错了</p><h3 id="A-Large-Loss-on-Training-Data"><a href="#A-Large-Loss-on-Training-Data" class="headerlink" title="A. Large Loss on Training Data"></a>A. Large Loss on Training Data</h3><p>我们如果检查发现，在训练集上模型的表现确实有提升，但是最终模型收敛到的loss却很大，那么此时就有两个可能，第一个是Model Bias，第二个就是Optimization的问题</p><h4 id="1-Model-Bias"><a href="#1-Model-Bias" class="headerlink" title="1. Model Bias"></a>1. Model Bias</h4><p>对于Model Bias而言，其实在上周就已经讲过了。具体而言就是我们的模型太简单，其学习能力太弱难以充分的学习当前的任务。或者说模型的潜力太小，最终开发/学习到极致的模型也无法胜任当前的任务。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110221632640.png" alt="模型训练攻略" style="zoom: 33%;"></p><p>那么到底什么是模型的学习能力/潜力呢？</p><p>举例来说，我们现在设计了一个含有参数$\theta$的模型$f_\theta(x)$，即</p><script type="math/tex; mode=display">y=f_\theta(x)</script><p>由于模型中的参数是可以变化的，而一个参数就对应一个具体的模型，例如$y=2x^2$和$y=3x^3$，这两个模型都平方模型这一类模型，但是却是两个不同的模型。</p><p>因此，我们让模型$f_\theta(x)$中的参数$\theta$取不同的值，就有了不同的具体的模型，例如：$f_\theta^1(x)$、$f_\theta^2(x)$、$f_\theta^3(x)$、$\cdots$、$f_\theta^N(x)$、$\cdots$</p><p>那么我们把这些模型当做高维（维数大于等于$len(\theta)$，因为可能存在参数更多的模型）空间中的一个点，那么我们把所有的模型集合起来，就可以得到一个模型的Set。</p><p>然而当前模型所构成Function Set太小了，无法包含到让模型损失最小的模型。换而言之，可以让Model表现最好的模型（模型由参数描述）是无法用当前模型来描述的</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110224645545.png" alt="当前模型的Function Set不包含最佳的Function" style="zoom:50%;"></p><p>那么这个时候，即便是当前模型所能够描述的Function Set中最好的模型，他的Loss依然很高。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110225130533.png" alt="image-20220110225130533"></p><p>这个时候问题就类似于我们是在大海里捞针（表现最好的参数），然而大海里并没有针（当前模型并不存在全局/全模型最佳的参数）</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110225344433.png" alt="大海捞针却没有针" style="zoom:50%;"></p><p>那么这个时候，我们要做的就是重新设计我们的模型，让他具有更大的潜力/更加可塑（more flexible）。所谓更加可塑，其实指的就是结构更加复杂、参数更加多、能够表达更多的模型。</p><p>这样的事情其实我们在上一节课就已经做过了，我们发现线性模型只看一天前的数据不太行，那么就让他看前56天的数据，然后觉得模型还是不太行，那么就引入Sigmoid、ReLu等函数为模型添加非线性、构成深度网络、神经网络</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110230559512.png" alt="Model Bias的解决方案：重新设计模型" style="zoom:50%;"></p><h4 id="2-Optimization"><a href="#2-Optimization" class="headerlink" title="2. Optimization"></a>2. Optimization</h4><p>在训练数据上loss大可能是由于Model Bias造成的，但并不是说所有的在训练数据上loss大就是由于Model Bias造成的，还有一种可能就是Optimization的问题。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110231923155.png" alt="Optimization的问题" style="zoom: 33%;"></p><p>所谓Optimization的问题，其实指的就是我们没有做好Optimization这一步。在我们的预期里，我们通过Optimization就能够让模型的表现得到提升，然而这都是建立在我们做好了Optimization这一步的基础山的，因此如果我们没有做好Optimization，模型的表现也是上不去的。</p><p>Optimization这一步出问题，其实由很多种可能，例如我们的学习率设的太大或者太小等等。当然，我们在上一节课其实也讲了一种Optimization中可能出现的问题，就是Local Minima的问题</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110231450099.png" alt="梯度下降卡在了Local Minima上" style="zoom:33%;"></p><p>同样，用图像来形象的表示的话，就是问题的最佳的模型的参数确实可能由我们的模型来描述，然而在Gradient Descent的时候，由于某些原因（例如局部最优点），我们无法得到这个全局最优点。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110231557891.png" alt="无法得到最优值，只能得到次优值" style="zoom: 50%;"></p><p>形象的比喻，我们这个时候面临的问题就是针确实在海里，只是我们没有办法找到这根针</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110232047999.png" alt="大海捞针找不到针" style="zoom:50%;"></p><h4 id="3-Diagnosis-between-Model-Bias-and-Optimization"><a href="#3-Diagnosis-between-Model-Bias-and-Optimization" class="headerlink" title="3. Diagnosis between Model Bias and Optimization"></a>3. Diagnosis between Model Bias and Optimization</h4><p>那么这个时候问题来了，既然模型在训练数据上的表现糟糕可能是由Model Bias造成的，也有可能是由Optimization造成的。那么在当我们真实遇到了模型在训练数据集上的表现糟糕的情况的时候，到底那个才是我们的处境？</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110232503590.png" alt="到底哪个才是我们现在所处的问题呢？" style="zoom: 33%;"></p><p>那么这个时候，判断我们所处的情况的关键就是我们的模型到底有没有足够的潜力，或者说我们的模型到底够不够flexible（可塑）？</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110233144866.png" alt="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110233055346.png"></p><p>那么这个时候我们可以通过下面的几个方法来进行判断：</p><ul><li><p>通过不同的模型之间的比较来获得insight，即我们的模型是否足够的flexible</p><blockquote><p><strong>举一个通过比较或者insight的例子</strong></p><p>这个例子是来自与2015年的Paper：Residual Network中的例子。这个Paper在一开头就讲了一个故事。这个故事是说，现在针对同一个任务，训练两个基本的结构相同而层数不同的Network。一个Network是20层网络，而另外一个是56层的模型</p></blockquote></li><li><p>a</p></li><li><p>as</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 李宏毅ML2021 Spring Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Hungyi Li </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Neural Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅ML2021-Spring-2: Introduction of Machine/Deep Learning</title>
      <link href="/2022/01/09/li-hong-yi-ml2021-spring-2-introduction-of-deeplearning-machinelearning/"/>
      <url>/2022/01/09/li-hong-yi-ml2021-spring-2-introduction-of-deeplearning-machinelearning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是李宏毅Machine Learning 2021 Spring 第二节课Introduction of Machine / Deep Learning的笔记，本节课主要结合案例讲解了机器学习/深度学习的基本概念</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109135954313.png" alt="第二节课：Introduction of Machine/Deep Learning"></p><h1 id="李宏毅ML2021-Spring-2-Introduction-of-Machine-Deep-Learning"><a href="#李宏毅ML2021-Spring-2-Introduction-of-Machine-Deep-Learning" class="headerlink" title="李宏毅ML2021-Spring-2: Introduction of Machine/Deep Learning"></a>李宏毅ML2021-Spring-2: Introduction of Machine/Deep Learning</h1><h2 id="1-What-is-Machine-Learning"><a href="#1-What-is-Machine-Learning" class="headerlink" title="1. What is Machine Learning"></a>1. What is Machine Learning</h2><p>到底什么是机器学习呢？</p><p>从一个角度来说，机器学习其实就是让机器去找函数，例如：</p><ul><li>对于语音识别来说，函数的输入是一段语音信号而输出是这段语音信号对应的文本</li><li>对于图像识别来说，输入是一张图片，而输出是一段描述图片类别的文本</li><li>对于下围棋来说，函数的输入是当前棋盘上的状态，输出是机器下一步落子的位置</li></ul><p>从上面的例子我们能够想象得到这些函数会非常非常复杂，人类没有办法写出他们的解析式，因此我们预期希望机器能够自动寻找这个函数</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109140806853.png" alt="机器学习等价于寻找函数" style="zoom:50%;"></p><h2 id="2-Different-types-of-Functions"><a href="#2-Different-types-of-Functions" class="headerlink" title="2. Different types of Functions"></a>2. Different types of Functions</h2><p>  因为要找的函数不同，机器学习可以分为不同的类别。下面就是一些专有的名词：</p><ul><li><p>Regression: 机器需要寻找的函数的输出是一个（连续的）数值</p><p>例如，让机器预测未来的PM2.5的数值。函数的输出是明天中午的PM2.5的指数，而输入则是今天可能影响到明天PM2.5数值的因素的值，例如今天的PM2.5、今天的问题、今天的臭氧浓度等等。像这样，寻找输出是一个连续数值的函数的任务就是Regression的任务</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109141428084.png" alt="Regression任务" style="zoom:50%;"></p></li><li><p>Classification: 机器的输出是多个选项中正确的一个（类别） ，这些选项都是人类提前给定的</p><p>例如，让机器判断一封邮件是不是垃圾邮件。那么机器的输入就是这封电子邮件，而输出就是Yes或者No两个选项中的一个。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109142452666.png" alt="Classification任务" style="zoom:50%;"></p><p>当然，Classification任务的选线可以不止有两个，像上面这样只有两个选项的Classification任务是Binary的。而对于下围棋来说，我们如果把棋盘上$19\times19$个可以落子的位置当做$19\times19$个类的话，那么让机器下围棋这个任务就是一个有$19\times19$的选择题，让机器从$19\times19$个选项中选出正确的选项（下一步要下的位置）</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109142920372.png" alt="Classification任务：多分类" style="zoom:50%;"></p></li></ul><p>然而Classification和Regression都只是机器学习任务中的一小部分，还有一类很大的问题，即Structure Learning</p><ul><li>Structured Learning: 机器不只需要做选择题、产生一个数字，还要去产生一个有结构的物体。例如让机器去画一张画、写一篇文章。形象的理解就是让机器学会创造</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109143127219.png" alt="Classification和Regression都只是巨大世界的一小部分" style="zoom: 80%;"></p><h2 id="3-Case-Study-How-does-machine-find-a-function"><a href="#3-Case-Study-How-does-machine-find-a-function" class="headerlink" title="3. Case Study: How does machine find a function?"></a>3. Case Study: How does machine find a function?</h2><h3 id="A-Background"><a href="#A-Background" class="headerlink" title="A. Background"></a>A. Background</h3><p>自从2014年开始上课以来，李宏毅老师就会把自己的课程视频上传到YouTube频道上。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109143614678.png" alt="李宏毅老师的YouTube频道" style="zoom:50%;"></p><p>而对于一个YouTuber来说，他最在意的就是这个频道的流量有多少。因为对于一个全职Youtuber来说，流量决定了一个YouTuber的收益有多少。</p><p>那么我们就想，能否找到一个函数输入是YouTub后台的数据，而输出是未来的点阅率</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109144001795.png" alt="希望找到的函数" style="zoom:50%;"></p><h3 id="B-How-to-find-the-function"><a href="#B-How-to-find-the-function" class="headerlink" title="B. How to find the function?"></a>B. How to find the function?</h3><p>接下来我们就要问该怎么样寻找这个输入是今天的数据，输出是未来数据的函数呢？</p><p>那么对于机器学习来说，整个过程分为三步</p><ol><li><p><strong>第一个步骤就是写出一个带有未知参数的函数解析式</strong>。简单来说就是我们先猜测一下这个函数$f$的到底长什么样子。</p><p>那么我们先猜测一下，这个函数可能是下面这样</p><script type="math/tex; mode=display">y=b+wx_1</script><p>其中$y$是明天的观看人数，例如2月26号的观看人数，而$x_1$是今天的观看人数，例如2月25号的观看人数；$b$和$w$都是未知的参数，后面我们准备让机器学习的就是这两个未知的参数</p><p>那么我们为什么猜测这个函数会是$y=b+wx_1$这个样子呢？其实这个猜测是来自于我们先前对这个问题的理解，即我们的<strong>domain knowledge</strong>。而常听有人会说做机器学习需要一些domain knowledge，那其实domain knowledge的左右就是帮助我们写出来这个函数解析式。考虑到在真实的一个神经网络中，模型就是我们需要找的一个函数，因此domain knowledge的作用就是指导我们该如何设计网络。</p><p>对于上面的问题来说，我们的domain knowledge就是明天的观看人数应该会和昨天的人数有关。虽然有关但又不是相同，因此我们就乘以一个数字在加上一个数字 。而<strong>我们猜测得到的带有未知参数的函数就称为我们的Model</strong></p><p>我们的猜测是基于我们现有的认识（现有的Domain Knowledge）提出的，而由于我们的认知是受限的，我们的模型又是在当下的认知下提出的，因此可能不对，或者说表现不佳。那么未来随着我们对问题研究的深入，我们对问题的认识越发深刻，我们就可以根绝我们更加完善、正确的Domain Knowledge来指导我们修改模型。</p><p>例如明天的观看次数是不是有可能和过去几天都有关系？也即今天一天的观看人数无法完全决定明天的观看人数。当然这需要我们对问题进行探索，验证当前的Domain Knowledge才行。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109144812145.png" alt="第一步：根据Domain Knowledge写出含参函数解析式" style="zoom:50%;"></p></li><li><p>定义一个Loss。Loss其实也是一个函数，这个函数的输入是我们函数的参数，即</p><script type="math/tex; mode=display">L=L(b,w)</script><p>而Loss这个函数输出的值就是值当前的参数的好坏，好坏的衡量可以用一个数值来描述（有点模糊数学隶属度的意思）。</p><p>这样说比较抽象，我们举一个具体的例子。假设，我们现在让上模型中的参数$b=0.5k,w=1$，那么我们的模型就变成了</p><script type="math/tex; mode=display">b=0.5k,w=1 \rightarrow y=0.5k+x_1</script><p>那么上面$y=0.5k+x_1$这个模型到底有多好呢？这就是Loss来衡量的。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109151732346.png" alt="Loss衡量模型有多好" style="zoom:50%;"></p><p>而要衡量Loss就要从训练资料来入手。假设我们现在的输入的数据是从2017年1月1日到2020年12月31日的观看数据。那么我们就可以通过下面的方式来计算Loss。</p><p>我们把2017年1月1日的观看人数带入到模型中去，计算得到模型预测的2017年1月2日观看的人数为5.3k，接下来我们用模型预测的结果和真实的值来进行比较，计算得到一个误差$e_1$。<strong>这个真实的值就称为label</strong>。当然误差计算的方式不止一种，我们这里就去绝对值，即$e_1=|y-\hat y|=0.4k$</p><p>当然，我们现在有的数据不止有1月1日这一天，我们也可以用1月2日的值预测1月3日的值，然后计算$e_2$。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109151755049.png" alt="Loss衡量模型的好坏-1" style="zoom:50%;"></p><p>同样的方法，为我们可以算到三年来每一天预测的误差。然后我们把这三年的误差加起来取平均，就得到的了模型在所有数据上的表现。而这个平均的Loss越大，就表明模型的表现越差。</p><p>此外，计算Loss的方法不止一种，我们上面是对绝对值取平均，因此称为Mean Absolute Error（MAE），此外还有Mean Square Error（MSE）的Loss</p><p>我们这个任务很明显是一个Regression的任务，而对于Classification的任务，我们的loss function就可以取Cross-Ectropy Loss</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109152002306.png" alt="Loss衡量模型的好坏-2" style="zoom:50%;"></p><p>对于$y=b+wx_1$这个模型，我们可以取不同的$w$和$b$计算得到一个loss surface，下面就是这个模型用真实的数据计算得到的Error Surface。越偏红色系Loss就越大，而越偏蓝色系Loss就越小。绘制的线是等高线。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109152855407.png" alt="image-20220109152855407" style="zoom:50%;"></p></li><li><p>机器学习的第三步就是Optimization问题，即找到让模型的Loss最小的参数。对于上面的问题，我们要找的就是让模型loss最小的$w$和$b$，将其记为$w^<em>$和$b^</em>$，那么优化这一步就是</p><script type="math/tex; mode=display">w^*,b^*=arg\min_{w,b} L</script><p>在数学上求解优化问题有很多方法，我们这里只讲Gradient Descent这一种方法。为了简单起见，我们线假设$b$不动的情况下，寻找让Loss最小的$w$</p><p>那么$w$取不同的值的时候，就会得到一条Loss曲线。那么我们的目的就是找到这个loss曲线中最低的那一个点。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109153602769.png" alt="b不变的情况下w的loss曲线" style="zoom:50%;"></p><p>Gradient Descent的步骤如下：</p><ol><li><p>（随机）选择一个初始值$w^0$。注意，现在确实有研究怎么样选择这个初始值会更好，但是我们这里先不关注这些，即假装不存在这些选择初始值的方法，我们就是随机选择一个初始值。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109154027659.png" alt="随机初始一个值" style="zoom:50%;"></p></li><li><p>接下来我们计算Loss对w的微分$\frac{\partial L}{\partial w}|_{w=w^0}$ ，即曲线的斜率</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109153945061.png" alt="计算微分" style="zoom:50%;"></p></li><li><p>如果曲线的斜率是负的，那就表示Loss曲线左边高右边低；反之如果曲线的斜率是正的，那就表示Loss曲线右边高左边低。为了能够达到较低的Loss，我们的模型就应该往Loss曲线上低的地方去。 </p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109155244574.png" alt="向梯度较小的方向前进" style="zoom: 33%;"></p><p>那在前进的时候就会有一个问题，就是到底该前进（下降）多少。由于我们无法控制求导得到的值的大小，因此我们引入一个参数$\eta$来控制下降的多少。这个参数$\eta$称为学习率。由于$\eta$使我们事先设定的，机器没有办法学习这样的参数，因此我们称这些需要自己设定的参数为<strong>超参数</strong>，Hyperparameter</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109161600158.png" alt="梯度下降" style="zoom: 33%;"></p><p>接下来我们要做的事情，就是重复梯度下降的过程，不断地更新$w$的值。直到最后求到的梯度为0，这样无论$\eta$怎样的变都没有办法继续下降。</p><p>然而使用梯度下降有一个很大的问题就是我们没有找到真正最好的解。我们只会找到一次次好的值。我们称全局最好的值为global minima而局部最小的值为local minima。</p><p>因此就会有人说，深度学习使用梯度下降的一个缺点就是会卡在Local Minima。当然，现在有一些研究就是对梯度下降进行了优化，使得其具有避免卡在local minima的能力</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109161732671.png" alt="Gradient Descent卡在local minima" style="zoom:33%;"></p><p>上面我们是只给出了单变量$w$的优化，下面我们给出两个变量的优化</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109162311503.png" alt="两个变量的优化" style="zoom: 33%;"></p><p>在刚才的loss surface上，我们整个的优化过程为</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109162523548.png" alt="Loss Surface上的优化"></p></li></ol></li></ol><p>最后通过上面的三步：</p><ol><li>根据Domain Knowledge猜测函数的形式（构建模型）</li><li>定义loss function</li><li>利用Gradient Descent进行优化</li></ol><p>我们就找到了最佳的函数。这三步就像把大象放进冰箱里去一样。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109163001969.png" alt="image-20220109163001969"></p><p>最后我们需要注意的是，在上面的这个case中，我们的loss的最佳值是0，而模型其实训练到最后都没有达到最佳的loss，这个时候其实就是我们的模型的极限只能到这里了，这就是我们 $y=b+wx_1$这个model 的 bias。想要进一步的提升我们的模型，就需要通过我们的Domain Knowledge来设计更好地和函数。</p><h3 id="C-Training-and-Testing"><a href="#C-Training-and-Testing" class="headerlink" title="C. Training and Testing"></a>C. Training and Testing</h3><p>我们前面的三步加在一起，称为Training。在Training阶段我们通过训练得到了最优的解。</p><p>然而有一个问题就是这些解真的是最优解么？答案其实并不是。因为我们现在的阶段是Training阶段，我们其实是在已经知道答案的数据上计算loss。我们这里只是在自嗨而已，我们假装不知道第二天的观看次数然后预测完了之后进行计算。</p><p>而我们真正关心的，应该是在我们不知道答案的数据上，模型也能给出这么好的结果。因此我们接下来要做的，就是用这个函数真的来进行预测。即我们在2020年末用新的数据来预测2021年的观看人数。最后，真实带入进去计算之后得到的在真实的不知道答案的数据上，跑下来的结果是Loss等于0.58</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109163417888.png" alt="Training阶段"></p><h2 id="4-Linear-Models"><a href="#4-Linear-Models" class="headerlink" title="4. Linear Models"></a>4. Linear Models</h2><p>正如前面所说，我们的模型在训练阶段得到了模型之后要在测试阶段用从来没有见过的数据（不在测试集中的数据）验证一下看看模型的效果如何。那么上面的线性模型跑下来的结果就如下图</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109164043776.png" alt="线性模型的预测额真实值"></p><p>每天观看的矢量基本上就在4~5k左右，而预测的误差达到了0.58k，即平均每天差了600多人次，误差大概20%左右。</p><p>此外，我们可以看到，蓝色的线基本上就是红色的线向右平移过去了而已。这就意味着机器的预测基本上就是把前一天的拿来作为第二天的预测。</p><p>此外，从红色的真实曲线上，我们其实也能够从中得到一些新的“知识“：</p><ul><li>观看的人数的涨跌具有周期性。每个七天都会有两天观看人数很低。这两天对应的就是周五和周六。周末毕竟大家都不想学习，所以已能够理解</li></ul><p>因此在我们通过对原始数据的观察之后，我们有了新的Domain Knowledge，因此根据新的Domain Knowledge，我们向能不能让模型每次预测下一天的时候都会看看前面几天的数据？这样的话模型就有可能学到当前是周几，然后就会有更好的表现。</p><p>退一万步来讲，模型直接把前七天的数据复制过来作为预测也是未尝不可的，也许会预测的更准说不定。</p><p>因此，我们现在新的模型如下</p><script type="math/tex; mode=display">y=b+\sum_{j=1}^7w_jx_j</script><p>其中，$j$表示几天前。</p><p>那么新的模型训练之后在预测集上进行预测，确实发现我们的性能有了不错的提升</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109185737315.png" alt="考虑前7天和前1天的模型性能对比" style="zoom:50%;"></p><p>由于我们考虑了前七天的数据，因此我们会有七个$w_j$的值，计算下来具体的结果如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109190112726.png" alt="7天模型的所有参数的值" style="zoom:50%;"></p><p>类似的，我们就想模型既然看了前七天的数据，他的性能有所提升，那么如果模型看了前一个月的数据呢？因此，我们可以修改我们的模型为</p><script type="math/tex; mode=display">y=b+\sum_{j=1}^{28}w_jx_j</script><p>最后训练下来的结果，确实看了前一个月数据的模型的性能还会有所提升</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109190621320.png" alt="看了一个月数据的模型" style="zoom:50%;"></p><p>我们更进一步，让模型看一下前两个月的数据，即</p><script type="math/tex; mode=display">y=b+\sum_{j=1}^{56}w_jx_j</script><p>可是这个时候尽管在训练集上模型的精度有所提升，但是在没有见过的数据（测试集）上，模型的精度并没有提升</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109211728804.png" alt="看了两个月数据的模型" style="zoom:50%;"></p><p>那么这就意味着，考虑天数的这个模型已经到了其极限了。</p><p>上面的，给feature直接乘以一个数值然后再加上一个数值的模型，我们称为Linear Model</p><h2 id="5-From-Linear-Model-to-New-Model"><a href="#5-From-Linear-Model-to-New-Model" class="headerlink" title="5. From Linear Model to New Model"></a>5. From Linear Model to New Model</h2><h3 id="A-Limited-Linear-Model"><a href="#A-Limited-Linear-Model" class="headerlink" title="A. Limited Linear Model"></a>A. Limited Linear Model</h3><p>在上面，我们其实已经将Linear的Model发挥到了极限。然而即便如此，每天还是有500多人数的预测的误差，因此我们就像能不能进一步提升我们的模型。</p><p>一个合理的质疑就是Linear的Model是不是太简单了？</p><p>为什么这样说呢？我们其实可以想象得到，$x_1$和$y$之间可能具有复杂的关系，例如下图的红线。而Linear的Model不管怎么样的改变$w$和$b$，都只能改变直线的倾斜程度和与$y$轴的截距，无法从根本上改变线型。即第二天的观看人数一定前一天的观看人数越多，第二天的观看人数越多/少。</p><p>然而就像红色的线，有可能前一天看得人多过了某一个程度之后，第二天看的人就越少。然而对于Linear的Model而言，不管怎么样的改变$w$和$b$，都无法产生红色的线。</p><p><strong>因此Linear的Model有很大的limitation</strong>。这种<strong>来自于Model的限制，称为Model的Bias</strong>。即Model能力的上限。</p><p>为此，我们就需要一个更加有弹性的，上限更高的一个Model。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109212237817.png" alt="Linear Model具有非常大的Model Bias" style="zoom:50%;"></p><h3 id="B-Synthesis-of-Piecewise-Curve"><a href="#B-Synthesis-of-Piecewise-Curve" class="headerlink" title="B. Synthesis of Piecewise-Curve"></a>B. Synthesis of Piecewise-Curve</h3><p>为了产生红色这样的曲线，我们其实可以用一个常数再加上一群不同的蓝色的函数来得到上面红色的曲线。蓝色的函数在输入的值很大或者很小的时候都是一个常数，只有值在中间恰好的时候是Slope。</p><p>下面蓝色的函数其实有自己专有的名字，但是我们现在先称呼他为一个“蓝方 ”</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109213739995.png" alt="使用蓝方来合成红方" style="zoom:50%;"></p><p>那么首先这个常数项，我们可以通过红方和$y$轴的交点获得</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109214104095.png" alt="获得常数项" style="zoom:50%;"></p><p>那么要怎么样加上蓝方才能够得到红方呢？我们首先可以这样加：我们让1号蓝方的slope的起点设在红方的第一个拐点，终点设在红方的第二个拐点，并且保持坡度一样。那么这样，1号、2号蓝方相加，就可以得到红方第二个拐点前的部分</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109214211825.png" alt="合成第一段红方" style="zoom:50%;"></p><p>接下来如法炮制，加上第二个蓝方，就可以得到红方的第二段曲线</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109214525965.png" alt="合成红方第二段曲线" style="zoom:50%;"></p><p>接下来，红方的最后一段，就用第三个蓝方来合成</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109214634948.png" alt="合成整个红方" style="zoom:50%;"></p><p>最后，我们把0、1、2、3个蓝方相加，就可以得到红方。</p><p>其实对于所有的Piecewise的Cureve，都能够通过蓝方来合成，例如下面的一些Piecewise的红方，只是不同的Piecewise的红方需要不同的数量、不同形状的蓝方。通常而言，越复杂的Piecewise的红方需要的蓝方就越多</p><blockquote><p>Piecewise的curve指的是由线段所组成的Curve</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109215345481.png" alt="不同数量、形状的蓝方可以合成任意的Piecewise的红方" style="zoom:50%;"></p><h3 id="C-Beyond-Piecewise-Curve"><a href="#C-Beyond-Piecewise-Curve" class="headerlink" title="C. Beyond Piecewise Curve"></a>C. Beyond Piecewise Curve</h3><p>在我们日常中，我们其实更常见的函数并不是Piecewise的曲线，而是光滑的、没有间断点的函数，例如下面的函数。但是我们的蓝方函数都是合成有间断点的Piecewise的曲线。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109220451867.png" alt="更常见的函数" style="zoom: 80%;"></p><p>其实问题也不大，我们主需要在连续的光滑曲线上取有点即可，只要我们取的点越多，就越接近原来的光滑函数，拟合的结果就越好。</p><p>因此，只要我们取的点够多、取的点位置适当，我们就可以逼近这条不是Piecewise的曲线。因此，我们实际上可以用足够多的蓝方来拟合任意的曲线</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110002728915.png" alt="在不是Piecewise的曲线上取点" style="zoom: 50%;"></p><h3 id="D-From-Hard-to-Soft"><a href="#D-From-Hard-to-Soft" class="headerlink" title="D. From Hard to Soft"></a>D. From Hard to Soft</h3><p>我们就是要写出来蓝方的表达式。因为上面的蓝方我们给的是分段的函数，并且由于在拟合的时候不同的蓝方需要的开始转折的$x$的不同，因此比较难写出来蓝方的表达式。而且在计算的时候由于分段会导致条件比较，因此就是用一条曲线来逼近、表示蓝方。</p><p>用于逼近蓝方的曲线就叫做$Sigmoid$函数，其表达式如下</p><script type="math/tex; mode=display">y=c\frac 1{1+e^{-(b+wx_1)}}=csigmoid(b+wx_1)</script><p>Sigmoid和蓝方非常相近，在$x$很大或者很小的时候，$y$都是常数，在中间是非线性的上升。</p><p>Sigmoid如果要翻译中文，可以是S型曲线。</p><p>其实在历史上，是先出现了Sigmoid函数才出现了我们上面的蓝方，不过为了方便讲解，因此我们先介绍的蓝方再介绍的Sigmoid函数。所以上面一直再说的蓝方，其实称为Hard Sigmoid</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110101912902.png" alt="用Sigmoid拟合蓝方" style="zoom:67%;"></p><p>那么还有一个问题，就是我们上面的蓝方的slope是可以左右平移的，那么Sigmoid又该如何去平移呢？</p><p>事实上，我们改变Sigmoid中的$c$、$b$、$w$即可制造出不同的Sigmoid函数。而有了不同的Sigmoid函数之后，我们叠加起来就可以去逼近不同的Piecewise的曲线，而Piecewise的曲线又可以去逼近各种各样光滑的曲线</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110103006819.png" alt="不同的Sigmoid函数" style="zoom:50%;"></p><p>所以对于上面的红方，我们就可以用几个Sigmoid来逼近</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110103451654.png" alt="使用Sigmoid逼近红方" style="zoom:50%;"></p><h3 id="E-From-Linear-to-New-Model"><a href="#E-From-Linear-to-New-Model" class="headerlink" title="E. From Linear to New Model"></a>E. From Linear to New Model</h3><p>总结一下上面，由于Linear Model存在非常大的Model Bias，而我们首先通过Hard Sigmoid来拟合任意的函数，最后用Sigmoid来拟合Hard Sigmoid。所以我们现在就获得了一个更加flexible的model </p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110103722736.png" alt="从Linear到Sigmoid"></p><p>那么其实，$y=b+wx_1$这个并不是我们表现最好的Linear Model，上面我们的最好的Linear Model是看多个feature的Linear Model，即</p><script type="math/tex; mode=display">y=b+\sum_{j=1}^nw_jx_j</script><p>那么我们现在要把这个Linear的Model扩展成Sigmoid这种Model的话，只需要把Sigmoid里面的东西换掉即可，则式子如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110105012755.png" alt="扩展看多个Feature的Linear Model"></p><p>上面的这个如果看起来头痛的话，我们用更直观的方式把他来画出来。我们现在先假设$j=1,2,3$，即只有三个Feature，模型只会看前三天的观看人数。我们还假设$i=1,2,3$，即我们用三个Sigmoid Function来拟合曲线。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110105431002.png" alt="Model的表达式"></p><p>那么我们首先先画出来输入</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110105307581.png" alt="输入只有前三天的人数"></p><p>然后我们再画出来三个Sigmoid函数，一个黑色的圆圈表示一个Sigmoid函数，由于我们有三个Sigmoid函数，因此就有三个黑色的圆圈</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110105909018.png" alt="三个Sigmoid函数"></p><p>画完了基础的元素之后，我们就开始画出来运算的步骤。</p><p>我们首先看要怎么样画出来Sigmoid内部括号里的东西。括号里的东西就是给每个$x$乘以一个数字$w$，然后再把三者相加，最后加一个$b$，所以我们下面这样画括号内部的东西</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110110548596.png" alt="画出括号内的东西"></p><p>同理，我们画出来第二个、第三个Sigmoid函数，我们就不写出来所有的$w$了，那么最后画下来的结果如下图</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110111044131.png" alt="画完三个Sigmoid之后的函数"></p><p>为了简单期间，我们把每个括号内计算的结果记为$r$，那么最后的结果就是</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110111305968.png" alt="最终的计算结果"></p><p>我们把上面三个括号的式子向量化，用矩阵乘法的形式来表达，就有向量$\vec x$乘以一个矩阵$W$在加上一个向量$\vec b$就得到了一个向量$\vec r$</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110111423642.png" alt="矩阵乘法表示的括号内的运算" style="zoom:50%;"></p><p>所以括号里干事事情就是下面的图</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110111758709.png" alt="三个Sigmoid括号内计算的示意" style="zoom:67%;"></p><p>接下来，赛算完括号里的东西后，要通过Sigmoid函数，所以三个$r$要分别通过三个Sigmoid函数。我们同样简写一下，用一个小写的希腊字母sigma来表示Sigmoid函数，即</p><script type="math/tex; mode=display">\begin{cases}a_1=sigmiod(r_1)\\a_2=sigmiod(r_2)\\a_3=sigmiod(r_3)\end{cases}\Leftrightarrow\vec a = \sigma(\vec r)</script><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110112031971.png" alt="通过三个Sigmoid函数" style="zoom:50%;"></p><p>我们最后一步，就是把三个$a$再用一个Linear Model，即乘以权重再相加，用矩阵表示，就是</p><script type="math/tex; mode=display">y=\vec b + {\vec c^T} \vec a</script><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110113027230.png" alt="最后一步" style="zoom:50%;"></p><p>所以我们上面一连串的运算，用矩阵表示出来就是</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110113246168.png" alt="矩阵运算表示的模型" style="zoom:50%;"></p><p>最后，我们用一个式子表示就是</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110113410265.png" alt="矩阵表示的模型" style="zoom:50%;"></p><p>上面就是我们得到的New Model</p><h2 id="6-New-Model"><a href="#6-New-Model" class="headerlink" title="6. New Model"></a>6. New Model</h2><p>上面我们通过Linear的Model不断深入，得到了New Model。那么我们下面就将聚焦于New Model的优化</p><h3 id="A-Model-Parameter-Function-with-Unknow-Parameter"><a href="#A-Model-Parameter-Function-with-Unknow-Parameter" class="headerlink" title="A. Model Parameter / Function with Unknow Parameter"></a>A. Model Parameter / Function with Unknow Parameter</h3><p>我们在前面说过，机器学习的模型其实都是带有参数的函数，New Model也不例外，例如我们上边的New Model</p><script type="math/tex; mode=display">y=b+c^T\sigma(b+Wx)</script><p>我们先重新定义一下符号。</p><p>在上式中，$x$称为feature，而所有未知的参数是$W$、$b$、$c$、$b$。注意我们有两个$b$，一个$b$是向量，另外一个是标量</p><p>由于$x$是feature，是一开始就给定的，因此我们实际上需要让机器去寻找的参数就是$W$、$b$、$c$、$b$</p><p>我们把这四个未知的参数拿出来，拉直，拼成一个很长的向量，我们用$\theta$来表示这个向量，如下图。</p><p>那么$\theta$中有一些值来自于W，有一些值来自于$b$，还有一些来自于$c$，我们这里就不去管他们了，把模型中所有未知的参数统称为模型的参数$\theta$</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110114652967.png" alt="定义模型的参数" style="zoom:50%;"></p><h3 id="B-Back-to-ML-Framework-Define-Loss"><a href="#B-Back-to-ML-Framework-Define-Loss" class="headerlink" title="B. Back to ML Framework: Define Loss"></a>B. Back to ML Framework: Define Loss</h3><p>我们在前面讲Linear Model的时候，说道：模型就是函数，而机器学习就是让机器去找函数的最佳参数。我们找这个函数的过程包括三步：</p><ol><li>定义模型 / 定义参数</li><li>定义Loss</li><li>使用Gradient Descent来优化参数，找到最佳的参数</li></ol><p>那么对于New Model来说，我们上面定义了New Model的含参函数表达式（function with unknown parameter），接下来就到了第二步骤，要定义Loss</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110115348831.png" alt="ML Framework第二步：定义Loss" style="zoom:50%;"></p><p>我们前面说过，loss function是模型参数的函数，对于Linear的Model来说，$L=L(w,b)$，而对于New Model来说，我们上面已经定义了模型的参数为$\theta$，所以对于神经网络来说，$L=L(\theta)$</p><p>而对于Loss具体的计算来说，由于Loss的计算是根据数据定义的，而我们的数据其实没有变，只是变了模型，所以loss function的计算其实没有变，只是符号改变了一下。</p><p>我们给定一组参数的值$b,c,b,W$，然后让模型用这套参数给出预测$y$，再和真实的label $\hat y$作比较，计算一个error $e$，最后做平均即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110115944808.png" alt="神经网络模型计算Loss" style="zoom:50%;"></p><h3 id="C-Back-to-ML-Framework-Optimize"><a href="#C-Back-to-ML-Framework-Optimize" class="headerlink" title="C. Back to ML Framework: Optimize"></a>C. Back to ML Framework: Optimize</h3><p>在定义完模型和损失函数之后，接下来的一步就是对模型进行优化了。</p><p>而对New Model进行Optimization和对Linear的Model进行Optimization的算法是一模一样的，就是Gradient Descent</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110120242698.png" alt="ML Framework第三步：优化模型" style="zoom:50%;"></p><p>我们这里的目标就是</p><script type="math/tex; mode=display">\theta^* = arg\min_\theta L</script><p>而</p><script type="math/tex; mode=display">\theta = \begin{bmatrix}\theta_1\\\theta_2\\\theta_3\\\vdots\end{bmatrix}</script><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110120608012.png" alt="优化模型" style="zoom:50%;"></p><p>那么同样的，我们还是三步走：</p><ol><li><p>首先随机初始化一个$\theta$的初始值$\theta^0$</p></li><li><p>接下来根据损失函数得到的Loss计算参数的微分，得到g。因为我们的参数是一个向量，所以计算得到的微分也是一个向量，这个微分向量称为Gradient</p><script type="math/tex; mode=display">g=\begin{bmatrix}\frac{\partial L}{\partial \theta_1}|_{\theta=\theta^0}\\\frac{\partial L}{\partial \theta_2}|_{\theta=\theta^0}\\\frac{\partial L}{\partial \theta_3}|_{\theta=\theta^0}\\\frac{\partial L}{\partial \theta_4}|_{\theta=\theta^0}\\\vdots\end{bmatrix}</script><p>上面的式子可以简写为</p><script type="math/tex; mode=display">g=\nabla L(\theta^0)</script></li><li><p>第三步就是利用计算得到的Gradient来更新我们的参数，即</p><script type="math/tex; mode=display">\begin{bmatrix}\theta_1^1\\\theta_2^1\\\theta_3^1\\\vdots\end{bmatrix}\leftarrow\begin{bmatrix}\theta_1^0\\\theta_2^0\\\theta_3^0\\\vdots\end{bmatrix}-\begin{bmatrix}\eta \frac{\partial L}{\partial \theta_1}|_{\theta=\theta^0}\\\eta \frac{\partial L}{\partial \theta_2}|_{\theta=\theta^0}\\\eta \frac{\partial L}{\partial \theta_3}|_{\theta=\theta^0}\\\vdots\end{bmatrix}</script><p>简写上面的式子就是</p><script type="math/tex; mode=display">\theta^1\leftarrow \theta^0-\eta g</script></li><li><p>然后重复上面的步骤，不断计算梯度、进行优化，直到我们不想继续算下去或者算出来的Gradient全是0.</p><p>当然在实际上，基本上都是我们不想继续算了，很少会有算到的Gradient全是0</p><script type="math/tex; mode=display">\theta^2\leftarrow \theta^1-\eta g\\\theta^3\leftarrow \theta^2-\eta g\\\theta^4\leftarrow \theta^3-\eta g\\\vdots</script></li></ol><h3 id="D-Mini-Batch"><a href="#D-Mini-Batch" class="headerlink" title="D. Mini-Batch"></a>D. Mini-Batch</h3><p>上面其实已经介绍完了New Mode的训练。其实在训练过程中还有一个小问题，就是在实际的计算的过程中，我们每次计算梯度并不是直接用所有的数据，而是用所有的数据中的一小部分。</p><p>我们用这一小部分数据在一起算一个Loss，然后用这一小部分的数据算到一个Loss $L^1$。然后用这个Loss去算一个梯度$g=\nabla L^1(\theta^0)$</p><p>这一小部分数据就称为一个<strong>Batch</strong>。一个Batch里的数据直接随机抽样就可以得到</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110123138076.png" alt="Mini-Batch"></p><p>然后我们继续取第二个Batch计算、第三个Batch计算……</p><p>直到我们用完所有的数据。把所有的Batch都计算过一遍就称为一个<strong>epoch</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110123426817.png" alt="Update with different Batches" style="zoom:50%;"></p><p>至于为什么要使用Batch？下个文章再说（下节课老师才讲），毕竟这个文章以及有8500字了。</p><p>为了加深影响，举两个例子来说，</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110123625439.png" alt="两个例子" style="zoom:50%;"></p><p>此外，由于Batch的大小也是我们自己定的，因此一个Batch有多少个数据，即Batch Size也是一个由我们决定的Hyper-Parameter</p><h3 id="E-ReLu-Rectified-Linear-Unit-ReLU"><a href="#E-ReLu-Rectified-Linear-Unit-ReLU" class="headerlink" title="E. ReLu: Rectified Linear Unit (ReLU)"></a>E. ReLu: Rectified Linear Unit (ReLU)</h3><p>我们其实还可以对模型做更多的变形。例如上面我们是用Sigmoid来替换Hard的Sigmoid。其实我们也可以用别的来代替Sigmoid</p><p>例如用下面的函数</p><script type="math/tex; mode=display">y=\begin{cases}x, & x> 0\\0, & x <0\end{cases}</script><p>简写为</p><script type="math/tex; mode=display">y=c\max(0, b+wx_1)</script><p>我们只需要改变$0$、w、$w$、$b$就同样可以实现线的平移。</p><p>其实用两个ReLu就可以合成Hard Sigmoid，例如下面的图</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110124230269.png" alt="从Sigmoid到ReLu" style="zoom:50%;"></p><p>所以如果想在模型中使用Hard Sigmoid而非Sigmoid的话，每个Sigmoid用两个Relu代替就行。</p><p>类似的，Sigmoid、ReLu、Hard Sigmoid这些函数在神经网络中，我们称其为<strong>Activation Function</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110124446031.png" alt="两个ReLu代替Sigmoid" style="zoom:50%;"></p><p>当然，还有其他的Activation Function。至于哪种激活函数比较好呢？下次再讲（写），这里快写不下了</p><h2 id="7-Case-Study-Neural-Network-Application"><a href="#7-Case-Study-Neural-Network-Application" class="headerlink" title="7. Case Study: Neural Network Application"></a>7. Case Study: Neural Network Application</h2><p>我们上面讲解了新模型的训练，那么接下来就把神经网络运用到上面YouTube观看次数预测的案例中去</p><h3 id="A-单层"><a href="#A-单层" class="headerlink" title="A. 单层"></a>A. 单层</h3><p>我们首先用上面的New Model，表达式如下，然后选用不同的ReLu的数量。</p><p>我们可以看到使用了新的模型的性能确实相比于Linear的Model有所提升，但是到了1000个ReLu之后，性能又到了瓶颈</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110125607587.png" alt="单层网络实验结果"></p><h3 id="B-多层"><a href="#B-多层" class="headerlink" title="B. 多层"></a>B. 多层</h3><p>我们上面都是只用了一层的新模型，即只有一层Activation Function。我们其实可以把第一层输出的$a$当做输入的$x$丢给下一层继续去计算</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110125940383.png" alt="Deeper Network"></p><p>那么通过这样不断地重复，我们就可以获得更深的模型。这里到底要叠多深，也是一个超参数。</p><p>我们继续进行实验，每一层用100个ReLu，实验的结果如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110130241302.png" alt="深层网络的实验结果"></p><p>下面就是真实的通过三层ReLu的实验结果</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110130440493.png" alt="三层ReLu的结果"></p><p>我们能够看到，不断叠深的模型确实学到了周期这个规律，并且大部分时间预测的都很准。</p><p>但是还是有一个问题，就在最右边出现了一个低谷，当天机器并没有预测到低谷，而是在第二天才出现了低谷。</p><p>那么这一天其实就是过年，这一天是除夕，没人会在除夕学机器学习吧？<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110130633256.png" alt="机器没有预测到低谷" style="zoom:50%;"></p><h2 id="8-Origin-of-Name"><a href="#8-Origin-of-Name" class="headerlink" title="8. Origin of Name"></a>8. Origin of Name</h2><p>就像Linear Model一样，我们上面的模型也要有一个名字，毕竟有了一个Fancy的名字才能够吸引人 </p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110130908501.png" alt="给模型一个Fancy的名字"></p><p>对于每一个激活函数，我们把他们称为一个Neural，那么整个模型就成为Neural Network</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110131017180.png" alt="Neural Network"></p><p>然而Neural Network这个名词在80、90年代其实就已经被玩烂了。那时候的人们对Neural Network的预期很高。可是最后受到当时技术的限制，Neural Network的表现让人大跌眼镜。所以Neural Network的名字就被搞臭掉了。</p><p>基本上Paper里有Neural Network，Paper就会被据掉。所以后来，为了重振Neural Network的雄风，就给了Neural Network新的名字。</p><p>我们把每一层称为一个Hidden Layer，很多层在一起那就是一个Deep的Network，那么就把这个技术称为Deep Learning。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110131425996.png" alt="Deep Learning"></p><h2 id="9-Deep-Network"><a href="#9-Deep-Network" class="headerlink" title="9. Deep Network"></a>9. Deep Network</h2><p>后来随着深度学习技术的发展，人们把网络越叠越深，2012年AlexNet有8层，在图像分类上的错误率为16.4%。到了2014年，牛津的VGG叠了19层，错误率为7.3%。在同一年谷歌的GoogleNet叠了22层，错误率降到了6.7%。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110131545131.png" alt="网络在逐渐变深"></p><p>然而他们都不是最深的模型，到了2015年，何凯明的Residual Network有152层，比台湾最高的楼台北101还要高</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110132028268.png" alt="ResNet非常深"></p><p> 当然，ResNet能训练的这么深其实是由于他用了特殊的结构，这个结构以后再讲</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110132212409.png" alt="ResNet特殊的结构"></p><p>到这里，我们其实就已经讲完了深度学习</p><h2 id="10-Why-Deep-Nor-Fat？"><a href="#10-Why-Deep-Nor-Fat？" class="headerlink" title="10. Why Deep Nor Fat？"></a>10. Why Deep Nor Fat？</h2><p>最后，其实有一个微妙的问题，就是我们前面说所有曲线都可以用Piecewise的曲线来逼近，因此对于Neural Network来说，只要有足够多的Neural就可以逼近任意的函数了</p><p>那么有一个问题，我们为什么要把网络叠深而不是把所有的神经元放到同一层，即为什么不是把网络变宽而不是变深？</p><p>这个留着下节课讲</p><h2 id="11-Why-don’t-we-go-deeper"><a href="#11-Why-don’t-we-go-deeper" class="headerlink" title="11. Why don’t we go deeper?"></a>11. Why don’t we go deeper?</h2><p>同样是上面的例子，我们可能觉得越深的网络越好，可是事实却是四层的模型不如三层的模型。</p><p>这其实是由于出现了Overfitting，即在训练数据上的表现变好而在没看过的数据上的表现变差。</p><p>关于Overfitting，我们下次再讲</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110133856191.png" alt="Overfitting"></p><h2 id="12-To-learn-More"><a href="#12-To-learn-More" class="headerlink" title="12. To learn More"></a>12. To learn More</h2><p>最后，是关于这节课一些没有讲到，未来也不一定会用，但是很有用的知识，由于本次课程完全关注深度学习，因此并不会讲解。这是之前的课程的讲解</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220110134223640.png" alt="image-20220110134223640"></p>]]></content>
      
      
      <categories>
          
          <category> 李宏毅ML2021 Spring Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Hungyi Li </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Neural Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅ML2021-Spring-1: Introduction</title>
      <link href="/2022/01/09/li-hong-yi-ml2021-spring-1-introduction/"/>
      <url>/2022/01/09/li-hong-yi-ml2021-spring-1-introduction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是李宏毅Machine Learning 2021 Spring 第一节课Introduction的笔记，记录了课程相关的要求</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109122555074.png" alt="第一节课：Introduction"></p><h1 id="李宏毅ML2021-Spring-1-Introduction"><a href="#李宏毅ML2021-Spring-1-Introduction" class="headerlink" title="李宏毅ML2021-Spring-1:Introduction"></a>李宏毅ML2021-Spring-1:Introduction</h1><p>李宏毅老师2021年的Machine Learning课程是完全可以通过线上上课的方式来学习的，因为所有的资料，包括课程、作业等等都可以通过线上的方式来完成。因此我们通过线上上课完全可以实现在教室里同等的听课效果</p><h2 id="1-Prerequisite"><a href="#1-Prerequisite" class="headerlink" title="1. Prerequisite"></a>1. Prerequisite</h2><p>2021年春季的课程没有考试也没有前置的要求、先修课等要求。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109123003194.png" alt="课程没有先修课的要求" style="zoom: 33%;"></p><p>虽然这样说，但是其实还是需要一些基础的能力，因为想要听懂、想要能够完成作业这些能力都是必须的：</p><ul><li><strong>数学知识</strong>：<ul><li>微积分</li><li>线性代数</li><li>概率论</li></ul></li><li><strong>编程能力</strong>：<ul><li>所有的作业都是基于Python的，并且所有的作业都有助教提供的例程。其实只需要运行助教的例程就能够完成作业。但是想要高分的话还是需要自己能够写</li><li>所有的作业都会用到Pytorch这个框架</li></ul></li><li><strong>硬件要求</strong>：<ul><li>除了前几个作业，后面的作业是需要真实训练模型的，因此会有硬件（GPU）的要求。但是所有的作业都可以通过谷歌的Colab云平台来完成，因此硬件其实不是问题。当然我自己是有机器的，因此就懒得花费时间去学习Google的colab了</li></ul></li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109123452250.png" alt="要求具有的出能力" style="zoom:50%;"></p><h2 id="2-Orientation"><a href="#2-Orientation" class="headerlink" title="2. Orientation"></a>2. Orientation</h2><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109124302620.png" alt="课程的方向"></p><ul><li>虽然名字叫做Machine Learning，但是2021年Spring的课程完全关注于Deep Learning。<ul><li>虽然在知识的划分上，DL是ML中的进阶知识。然而其实在李宏毅老师的讲解下，并不需要要ML的基础知识就能够听懂。</li><li>因此，本课程其实可以作为机器学习的第一堂课，从中我们可以学习到机器学习的基础知识，熟悉机器学习</li><li>此外，这门课和林轩田老师的机器学习技法的课程的重叠会很少，因为林老师的课程主要关注于传统的机器学习，只在最后会将到关于深度学习的内容</li></ul></li><li>此外，本课程还会讲解机器学习中最新、最前沿的技术。<ul><li>本课程会从最基础的知识讲到最新的知识</li></ul></li></ul><p>因此，在学完这门课程之后，完全可以：</p><ul><li>继续深入的学习机器学习的相关知识</li><li>将学习到的知识用于其他领域</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109125213775.png" alt="写完课程后可以干的事"></p><h2 id="3-Assignment"><a href="#3-Assignment" class="headerlink" title="3. Assignment"></a>3. Assignment</h2><p>本课程作业有两种形式：</p><ul><li>多选题：多选题的结果需要通过国立台湾大学的NTU COOL网站来提交</li><li>编程题（排行榜）：在kaggle或者JudgeBoi上根据模型性能排名的排行榜</li></ul><p>最后，关于编程题的代码需要在NTU COOL上提交。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109125410367.png" alt="课程的作业"></p><h2 id="4-Grading-Criterion"><a href="#4-Grading-Criterion" class="headerlink" title="4. Grading Criterion"></a>4. Grading Criterion</h2><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109125727983.png" alt="成绩的评判"></p><p>首先是关于作业分数的评判：</p><ul><li>课程一共有15次作业，每个作业都有十分。只会记录15个作业中的10个最高的来记录分数。<ul><li>PS：在老师看来，想要涵盖机器学习（深度学习）所有内容至少需要15个作业</li></ul></li><li>不强制要求完成所有的作业，选择自己感兴趣的作业完成即可</li><li>非常鼓励学生完成所有的15个作业<ul><li>PS：15个作业全部完成老师会送一件T恤<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul></li></ul><p>下面是所有作业的时间表</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109130152524.png" alt="作业安排"></p><p>最后课程成绩的评判如下：</p><ul><li>C-：这门课不会挂人，因此单纯的跑完了助教的例程就可以及格。</li><li>A-：根据每个作业的提示对助教的例程进行改进、提升，完成这些作业就可以是A-，大多数同学都是A-。</li><li>A+：每个作业其实都设置了一些难关，如果克服了他们就可以得到A+，而完成这些挑战需要通过自己的思考以及阅读文章</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109130415174.png" alt="课程成绩的评判"></p><h2 id="5-Rules"><a href="#5-Rules" class="headerlink" title="5. Rules"></a>5. Rules</h2><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109132756818.png" alt="基础的规则"></p><p>课程的一些规定如下：</p><ul><li>不允许抄袭别人的代码或者直接上传别人的代码<ul><li>别人包括宇宙中所有的生物</li><li>修改别人的代码里的变量名也是没有用的</li></ul></li><li>不要让把自己的代码分享给别人。<ul><li>如果分享代码、结果给别人那么自己也会受到同样的惩罚</li></ul></li></ul><p>此外，因为部分作业是在Kaggle上提交的，因此对于Kaggle也会有一些规定：</p><ul><li>每天的上传次数是有限制的<ul><li>不允许使用多个账号</li><li>不要相互借账号</li><li>因为有的作业在之前的几个学期也有布置，因此不要提交之前学习公开的代码</li><li>不要试图通过任何方式提高提交的次数</li></ul></li><li>所有的结果应该是由机器产生的<ul><li>不要试图手动打label的方式得到答案</li></ul></li><li>作业中使用的数据集都是开源的。因此他们的测试集和训练集都是公开的。因此不要把测试集用于训练<ul><li>此外包括但不仅仅是一下行为是禁止的：<ul><li>把测试数据加入到训练集中</li><li>使用测试数据来调参</li></ul></li><li>注意<ul><li>不要使用其他的第三方数据，例如在imagenet上训练好了跑到mnist上finetune</li><li>只使用作业中提供的数据集</li></ul></li></ul></li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109133332643.png" alt="Kaggle的规则-1"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109133527767.png" alt="Kaggle的规则-2"></p><p>最后是关于代码的一些规则</p><ul><li><p>作业的代码需要上传到NTU COOL上</p></li><li><p>上传的代码应该能够产生和你在leaderboard上的结果相近的模型</p><ul><li>如果没法产生，那么就会被视为作弊</li><li>助教会抽查代码、运行检查</li><li>如果你的作业拿到了10分，那么就会向全班展示</li><li>助教和老师有权判断是否作弊</li></ul></li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109134233249.png" alt="代码的规则"></p><h2 id="6-Punishment"><a href="#6-Punishment" class="headerlink" title="6. Punishment"></a>6. Punishment</h2><p>如果违反了上面的规则，那么乘法如下：</p><ul><li>第一次违反规则，那么期末总成绩打九折</li><li>第二次违反规则，直接零分，下学期再见</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109134637455.png" alt="惩罚"></p><h2 id="7-Information"><a href="#7-Information" class="headerlink" title="7. Information"></a>7. Information</h2><p>最后是关于课程的一些信息</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109134751615.png" alt="课程的主页"></p>]]></content>
      
      
      <categories>
          
          <category> 李宏毅ML2021 Spring Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Hungyi Li </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Neural Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅ML2021-Spring-0:Before Begin</title>
      <link href="/2022/01/09/li-hong-yi-ml2021-spring-0-before-begin/"/>
      <url>/2022/01/09/li-hong-yi-ml2021-spring-0-before-begin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文讲解李宏毅ML2021 Spring Notes系列文章的写作原因以及系列文章的写作目的</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207145714311.png" alt="课程官网"></p><h1 id="李宏毅ML2021-Spring-0-Before-Begin"><a href="#李宏毅ML2021-Spring-0-Before-Begin" class="headerlink" title="李宏毅ML2021-Spring-0: Before Begin"></a>李宏毅ML2021-Spring-0: Before Begin</h1><p>李宏毅老师的Machine Learning 2021 Spring的课程李宏毅老师以及上传到他的Youtube上了，并且系列作业也已经经过整理向公众开放。今年的ML课程完全关注Deep Learning，此外结合了Kaggle的许多实战。<strong>因此本系列文章作为我听课时候的笔记，记录了我在听课时候的心得与体会。</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/44fe603d253c2586def6d0e832b5efd6_r.jpg" alt="ML与DL的关系"></p><h2 id="1-Why-write-this-series-of-blogs"><a href="#1-Why-write-this-series-of-blogs" class="headerlink" title="1. Why write this series of blogs?"></a>1. Why write this series of blogs?</h2><p>之所以决定动笔写李宏毅2021 Spring机器学习课程的笔记，是有多方面的原因：</p><ul><li>最近西安疫情比较严重，被封在了学校里，那么刚好就在这个时候写一写笔记，这样让封闭的日子显得更加有意义</li><li>其实我之前就已经把这个课程学了一半左右了，然而对于学生来说考试是必不可少的，当长达半个月过去之后听过的课在记忆里的印象也逐渐淡去，因此写下笔记能够让未来自己再度阅读的时候能够快速的回忆</li><li>作为曾经学习过DL的记录，未来可以有所证明</li></ul><p>其实也正如我在<code>李宏毅ML2021 Spring Homework</code>专栏中所说的</p><blockquote><p>在2019年我刚进入大学的时候，那个时候深度学习已经火热起来了。在那个时候我就通过观看李宏毅老师的Machine Learning的系列课程从而对机器学习和深度学习入门了。</p><p>然而可惜的是，由于种种原因，在2019年的时候，李宏毅老师的ML系列课程我最终没有坚持下来全部看完。</p><p>一方面是受到了当时学识的限制。在那时候刚刚进入大学，刚刚开始学习线性代数，对概率论、图论、凸优化、计算机、多元高等数学等内容完全没有接触过。</p><p>另外一方面当时更加关注与计算机底层LInux等内容的学习；最后是大一时候的课是真的多。</p><p>因此最终没有听完2019年的课程，非常的可惜。</p><p>现在因为降级转入计算机专业的原因，有了很多的时间；此外自己在业余时间也已经把许多计算机的课程、深度学习的数学原理课程都已经学过了，编程能力也有了非常大的提升。</p><p>又恰逢2021年李宏毅老师的课程上架。因此决定这一次详细的学完所有课程并完成对应的作业。</p><p>所有的作业都以博客的形式来记录我炼丹的点滴。希望能够见证我这一段时间的投入和付出。</p></blockquote><p>因此希望这个系列的笔记能够作为我坚持学习的记录和动力。</p><h2 id="2-Who-is-Hung-yi-Lee"><a href="#2-Who-is-Hung-yi-Lee" class="headerlink" title="2. Who is Hung-yi Lee"></a>2. Who is Hung-yi Lee</h2><p>As now we are going to have classes of Hung-yi Lee, we’d better have some knowledge of him.</p><p>首先是<code>Wikipedia</code>的介绍</p><blockquote><p><strong>From wikipedia</strong></p><p>李宏毅（1985年或1986年－），台湾地区计算机科学家，国立台湾大学电机工程学系副教授，研究领域包括语意理解、语音辨识、机器学习、深度学习等。</p><p>李宏毅在大学二年级时，因对电机系许多课程感到困惑，曾一度非常沮丧迷惘，甚至萌生了退学的念头。他当时选了一门“数字通信处理”课程，发现自己难以听懂，但他并未放弃，不弃选不退修，最终豁然开朗，“原来用手机拨电话给别人时，中间发生的事就是这些信号处理。”找到学习的兴趣后，李宏毅开始跟随中央研究院李琳山院士做项目，随后于2010年从国立台湾大学取得硕士学位，2012年取得博士学位。2012年9月至2013年8月间，李宏毅于中央研究院资讯科技创新研究中心担任博士后研究员。2013年9月以客座科学家身份前往麻省理工学院计算机科学暨人工智能实验室。2014年返台，担任台湾大学电机工程学系教师至今。</p><p>2015年，李宏毅开始在台湾大学讲授机器学习课程，选课人数通常爆满，有400多人来修。于是，李宏毅将学生分在两间教室，一间现场看老师上课，另一间同步看直播。由于直播上课的诸多限制，李宏毅养成了录制课程影片的习惯。一开始李宏毅将影片上传至个人主页，后来由于萤幕侧录软件的序号过期，无法导出MP4，但有导出至YouTube的选项，于是李宏毅开始将课程影片上传至YouTube。此举不仅帮助了台湾大学的学生，还意外嘉惠台湾大学以外的学生。在其影片下方，还有中国大陆的学生留言感谢，表示已经听完全部课程，并留下笔记连结。截至2021年9月30日，李宏毅的YouTube频道有8.99万位订阅者，最热门的影片有56万次观看。</p><p>李宏毅擅长用浅显易懂的语言，以学生喜爱的精灵宝可梦、凉宫春日等动漫来讲解复杂的机器学习技术，因此被亲切地称为“精灵宝可梦大师”。中华民国电脑学会称李宏毅为“第一个公开有系统地完整深入讲解深度学习技术的学者，使得华文的深度学习教学与英文世界并驾齐驱。”</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207143939983.png" alt="维基百科对老师的介绍"></p><p>从维基百科的介绍中能够看出来，李宏毅老师讲解机器学习的课程非常的有趣和生动，因此广受欢迎。我在当初也是受到了李宏毅老师早年的课程的熏陶，才进入了ML/DL的大门。</p><h2 id="3-Why-is-Hung-yi-Lee"><a href="#3-Why-is-Hung-yi-Lee" class="headerlink" title="3. Why is Hung-yi Lee"></a>3. Why is Hung-yi Lee</h2><p>为什么选择李宏毅老师的课程而非其他老师的课程？</p><p>首先是因为李宏毅老师的课程非常的通俗易懂，在讲课的时候老师会举各种各样的例子，宝可梦、全职猎人、凉宫春日等等，贴近与学生的距离。</p><p>其次是因为老师的ML的课程从16年到现在以及过去了5年时间了，在这五年中老师的课程已经经过了长久的打磨，因此会具备丰富的经验，所以学起来的时候体验会好很多。</p><p>最后就是关于我个人的原因，因为先前没有学完老师2019年的课程，感到非常遗憾，所想要在2021年完成老师的课程，弥补当年的遗憾。</p>]]></content>
      
      
      <categories>
          
          <category> 李宏毅ML2021 Spring Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Hungyi Li </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Neural Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法9-相关性分析</title>
      <link href="/2022/01/09/shu-xue-jian-mo-suan-fa-9-xiang-guan-xing-fen-xi/"/>
      <url>/2022/01/09/shu-xue-jian-mo-suan-fa-9-xiang-guan-xing-fen-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍了数学建模中的一类知识：相关性分析</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/v2-df840824b0adc9a637a2ce10d5d52ceb_r.jpg" alt="相关性分析"></p><h1 id="数学建模算法9-相关性分析"><a href="#数学建模算法9-相关性分析" class="headerlink" title="数学建模算法9-相关性分析"></a>数学建模算法9-相关性分析</h1><p><strong>相关性，是指两个变量的关联程度</strong>。一般地，从散点图上可以观察到两个变量有以下三种关系之一：两变量<strong>正相关</strong>、<strong>负相关</strong>、<strong>不相关</strong>。</p><ul><li>如果一个变量高的值对应于另一个变量高的值，相似地，低的值对应低的值，那么这两个变量正相关。在土壤中，孔隙率和渗透度就具有典型的正相关。</li><li>反之，如果一个变量高的值对应于另一个变量低的值，那么这两个变量负相关。</li><li>如果两个变量间没有关系，即一个变量的变化对另一变量没有明显影响，那么这两个变量不相关。</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/v2-6d544d2fe7ff1daa2cab78f0ba2ed3c8_1440w.jpg" alt="两个变量间的关系"></p><p>而<strong>相关性分析是指对两个或多个具备相关性的变量元素进行分析，从而衡量两个变量因素的相关密切程度</strong>。</p><p>之所以要进行相关性分析，是因为在数学建模中经常会遇到一类题目，会评价两个指标（变量）之间的关系/联系。因此，本文就将介绍相关性分析的相关知识。</p><h2 id="1-变量间的相关性"><a href="#1-变量间的相关性" class="headerlink" title="1. 变量间的相关性"></a>1. 变量间的相关性</h2><p>在统计学上，我们通常这样判断变量之间是否有关：</p><ul><li><strong>如果一个变量的取值发生变化，另外一个变量的取值也相应发生变化，则这两个变量有关</strong>。</li><li><strong>如果一个变量的变化不引起另一个变量的变化则二者无关</strong>。</li></ul><p>在变量相关的基础上，我们又会有两个变量的相关程度到底如何，即一个变量变化多少另外一个变量对应的会变化多少？</p><p>因此我们定义<strong>变量关系强度</strong>，即<strong>两个变量相关程度的高低</strong>。统计学中是以准实验的思想来分析变量相关的。通常从以下的角度分析：</p><ul><li>两变量是否相互独立</li><li>两变量是否有共变趋势</li><li>一变量的变化多大程度上能由另一变量的变化来解释</li></ul><h2 id="2-四种基本变量"><a href="#2-四种基本变量" class="headerlink" title="2. 四种基本变量"></a>2. 四种基本变量</h2><p>根据变量的类型，现实中的变量可以分为下面四种：</p><ul><li><strong>定类变量</strong>：根据定性的原则区分总体各个案类别的变量，变量间没有大小关系。例如：性别，民族、婚姻状况</li><li><strong>定序变量</strong>：区别同一类别个案中等级次序的变量，变量间具有大小关系，但是没有数值关系。例如：文化程度、工厂规模、年龄大小</li><li><strong>定距变量</strong>：区别同一类别个案中等级次序及其距离的变量，变量间具有大小关系且具有数值关系（可以用数值描述的变量），例如：摄氏温度、比率、智力水平。此外，定距变量是没有零点的，零只是其中的一个值。而且，加减得到的差值有意义而乘除后的值没有意义。</li><li><strong>定比变量</strong>：也是区别同一类别个案中等级次序及其距离的变量，除了具有定距变量的特点外，还具有零点，即零点相比于其他值有意义，例如：收入、价格、市场占有率</li></ul><h2 id="3-两变量的相关分析"><a href="#3-两变量的相关分析" class="headerlink" title="3. 两变量的相关分析"></a>3. 两变量的相关分析</h2><h3 id="A-Pearson相关系数"><a href="#A-Pearson相关系数" class="headerlink" title="A. Pearson相关系数"></a>A. Pearson相关系数</h3><h4 id="1-Pearson相关系数的计算"><a href="#1-Pearson相关系数的计算" class="headerlink" title="1. Pearson相关系数的计算"></a>1. Pearson相关系数的计算</h4><p>适用于定距、定比类型的变量。 是运用最广的一种相关程度统计量。例如可以用皮尔逊系数分析收入和商品价格的相关性。</p><p>皮尔逊系数$r$的计算如下：</p><script type="math/tex; mode=display">r= \frac{\sum_{i=1}^n (x_i-\bar x)(y_i-\bar y)}{\sqrt {\sum_{i=1}^n (x_i-\bar x)^2\sum_{i=1}^n (y_i-\bar y)^2}}</script><p>Pearson系数的相关性检验用$t$检验，其统计量$t$服从自由度($n-2$)的分布，其中n表示数据的维度</p><script type="math/tex; mode=display">t=  \frac{r}{1-\frac{r^2}{n-2}}</script><p>之所以需要对皮尔逊系数进行检验，原因在于我们对一个变量的值的采集是通过有限次的观测。因此就会存在偶然性的问题，所以需要进行相关性检验</p><ul><li>若计算得到$t\ge t_{a/2}$或$p\ge a$，则认为$r$统计显著。例如变量十六个维度（$n-2=14$），且$a$取0.05，若计算得到$t\ge2.145$，则有95%的概率认为两个变量相关这一结果不是偶然造成的，或者说有95%的把握认为两个变量相关。</li><li>若计算得到$t\leq t_{a/2}$或$p\leq a$，则认为$r$统计不显著，即非常有可能是偶然因素造成的</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108200212772.png" alt="t检验的表"></p><h4 id="2-Pearson相关系数的意义"><a href="#2-Pearson相关系数的意义" class="headerlink" title="2. Pearson相关系数的意义"></a>2. Pearson相关系数的意义</h4><p>对于皮尔逊系数而言，其越接近一，表示计算该皮尔逊系数的两个变量之间相关性越高</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108200533348.png" alt="皮尔逊系数与相关程度" style="zoom:67%;"></p><h4 id="3-Pearson相关系数的使用条件"><a href="#3-Pearson相关系数的使用条件" class="headerlink" title="3. Pearson相关系数的使用条件"></a>3. Pearson相关系数的使用条件</h4><ol><li>两变量均应由测量得到的连续变量。</li><li>两变量所来自的总体都应是正态分布，或接近正态的单峰对称分布</li><li>变量必须是成对的数据</li><li>两变量间为线性关系，因此计算前需要先画散点图查看一下</li></ol><h3 id="B-Spearman相关系数"><a href="#B-Spearman相关系数" class="headerlink" title="B. Spearman相关系数"></a>B. Spearman相关系数</h3><h4 id="1-Spearman系数的计算"><a href="#1-Spearman系数的计算" class="headerlink" title="1. Spearman系数的计算"></a>1. Spearman系数的计算</h4><p>Spearman系数是用于计算度量定序变量与定序变量之间的相关系数。</p><p>斯皮尔曼系数计算如下</p><script type="math/tex; mode=display">r_s=1-\frac{6\sum(x_i-y_i)^2}{n(n^2-1)}</script><p>其中，$x_i$，$y_i$是两个变量按照大小排序的等级，$n$为样本容量。在$n\ge 20$之后，可以用$t$统计量进行检验。</p><script type="math/tex; mode=display">t=r_s\sqrt {\frac{n-2}{1-r_s^2}}</script><p>同样，</p><ul><li>若计算得到$t\ge t_{a/2}$或$p\ge a$，则认为$r$统计显著。例如变量十六个维度（$n-2=14$），且$a$取0.05，若计算得到$t\ge2.145$，则有95%的概率认为两个变量相关这一结果不是偶然造成的，或者说有95%的把握认为两个变量相关。</li><li>若计算得到$t\leq t_{a/2}$或$p\leq a$，则认为$r$统计不显著，即非常有可能是偶然因素造成的</li></ul><h3 id="C-双变量关系强度测量的主要指标"><a href="#C-双变量关系强度测量的主要指标" class="headerlink" title="C. 双变量关系强度测量的主要指标"></a>C. 双变量关系强度测量的主要指标</h3><p>双变量关系强度测量的主要指标如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108203130288.png" alt="双变量关系强度测量的主要指标"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 相关性分析 </tag>
            
            <tag> 皮尔逊系数 </tag>
            
            <tag> Correlation Analysis </tag>
            
            <tag> Pearson Correlation Coefficient </tag>
            
            <tag> Spearman&#39;s rank correlation coefficient </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法10-主成分分析</title>
      <link href="/2022/01/08/shu-xue-jian-mo-suan-fa-10-zhu-cheng-fen-fen-xi/"/>
      <url>/2022/01/08/shu-xue-jian-mo-suan-fa-10-zhu-cheng-fen-fen-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲解了数模中帮助进行数据压缩的算法：主成分分析，PCA</p></blockquote><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/GaussianScatterPCA.svg/300px-GaussianScatterPCA.svg.png" alt="主成分分析" style="zoom:150%;"></p><h1 id="数学建模算法10-主成分分析"><a href="#数学建模算法10-主成分分析" class="headerlink" title="数学建模算法10-主成分分析"></a>数学建模算法10-主成分分析</h1><p>在前面的一节我们讲解了相关性分析。相关性分析用于判断两个变量之间的相关性。那么就存在一个问题，假设现在我们需要建模的数据有上万行，而每一样的一个example都有二十多个维度。那么要对这样的数据进行分析就会非常占用内存，甚至在数模的这几天里面跑出来这些数据就会占用大部分时间。</p><p>因此，为了简化分析、节约时间，在数模中可以使用主成分分析这一方法(Priciple Component Analysis)。</p><p>其基本思想就是通过一些手段，实现对<strong>数据信息的压缩</strong>，从而在损失一部分信息量的前提下实现需要分析的数据的压缩，从而帮助加速分析。</p><p>而如何实现损失部分信息带来数据的压缩呢？一个简单的思路其实就可以通过我们前面说的相关性分析，若两个变量$A,B$之间是强相关的（皮尔逊系数大于0.9），那么我们其实可以认为变量$B$的绝大部分信息都蕴含在$A$，我们通过一些方法就可以从A中获得$B$的信息（例如拟合得到的曲线）。那么通过这样，我们其实就没有必要存储$B$的所有的值了，我们只需要存储$A$的值即可。这样做虽然丢失了部分B的信息，但是我们却能够节省内存。</p><p>类似的，主成分分析就是同类型的用于进行数据压缩的算法。</p><p>数模中常用的数据降维的方法有两种：<strong>主成分分析法</strong>和<strong>因子分析法</strong>。两种方法其实差别不大大，而主成分分析得到的指标数量和原来的指标数量，我们选择前几个就行，而因子分析法则是生成我们指定数量的指标数量。</p><h2 id="1-主成分分析的介绍"><a href="#1-主成分分析的介绍" class="headerlink" title="1. 主成分分析的介绍"></a>1. 主成分分析的介绍</h2><p>主成分的概念由Karl Pearson在1901年提出的。他是考察多个变量间相关性一种多元统计方法。</p><p><strong>主成分分析研究如何通过少数几个主成分(principal component)来解释多个变量间的内部结构</strong>，即从原始变量中导出少数几个主分量，使它们尽可能多地保留原始变量的信息，且彼此间互不相关。</p><p>主成分分析的目的：</p><ul><li><p>数据的压缩</p></li><li><p>数据的解释</p></li></ul><p>其常被用来寻找判断事物或现象的综合指标，并对综合指标所包含的信息进行适当的解释</p><p>若直接对原有的指标进行删除，那么存在的一个问题就是一定会丢失掉信息。因此相比于直接简单的删除，需要先对原始数据进行一定的变换，以实现信息的重组，从而保留蕴含更多信息的指标而丢弃蕴含信息较少的指标。</p><h2 id="2-主成分分析的基本思想"><a href="#2-主成分分析的基本思想" class="headerlink" title="2. 主成分分析的基本思想"></a>2. 主成分分析的基本思想</h2><p>主成分分析的主要思想就是：对这相关变量（为便于理解，先以两个为例）所携带的信息(在统计上信息往往是指数据的变异)进行浓缩处理。假定只有两个变量$x_1$和$x_2$，从散点图可见两个变量存在相关关系，这意味着两个变量提供的信息有重叠。</p><p>那么如果把两个变量用一个变量来表示，同时这一个新的变量又尽可能包含原来的两个变量的信息，这就是降维的过程</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108232921556.png" alt="主成分分析的例子"></p><p>例如，$x_1,x_2$分别表示身高和体重。那么身高和体重确实具有一定的关联，因为身高越高体重一般都会越重。</p><p>我们通过坐标轴的旋转，例如旋转到$y_1$和$y_2$，则此时，我们的数据在$y_1$这个轴上的分布越广泛，则其方差相比于原来就会大了很多。而方差在某种意义上可以表达信息的丰富和匮乏程度。方差非常小的一组数据，由于不同的数据间的同质化严重，因此其信息含量非常的匮乏，而方差大的一组数据则由于数据的多样新，因此其中蕴含的信息会更加丰富。</p><p>从上面的角度来理解，方差越大的维度其表达能力其实就越强，因为其中蕴含了更多的信息。因此我们其实可以仅仅保存所有数据点的$y_1$的值，那么就可以实现数据的有损压缩。</p><p>旋转坐标轴用可以有旋转矩阵来表示，即</p><script type="math/tex; mode=display">\begin{cases}y_1=a_{11}x_1+a_{12}x_2\\y_2=a_{21}x_1+a_{22}x_2\end{cases}</script><p>则我们的关键其实就是找到参数（旋转矩阵）</p><script type="math/tex; mode=display">A=\begin{bmatrix}a_{11} & a_{12}\\a_{21} & a_{22}\end{bmatrix}</script><p>那么对于高维数据，其实也是一样的思想，只不过在高维空间中是一个高维椭球，无法直观地观察。</p><p>每个变量都有一个坐标轴，所以有几个变量就有几个主轴。首先把椭球的各个主轴都找出来，再用代表大多数数据信息的最长的几个轴作为新变量，这样，降维过程也就完成了。</p><p>找出的这些新变量是原来变量的线性组合，叫做<strong>主成分</strong>。</p><p>上面是比较口语化的描述，下面是比较数学一点的描述。</p><blockquote><p>主成分分析就是设法将原来众多具有一定相关性的变量(如$p$个变量)，重新组合成一组新的相互无关的综合变量来代替原来变量。如何处理？</p><p>通常数学上的处理就是将原来$p$个变量作线性组合作为新的综合变量。如何选择？</p><p>如果将选取的第一个线性组合即第一个综合变量记为$F_1$，自然希望$F_1$尽可能多的反映原来变量的信息。怎样反映?</p><p>最经典的方法就是用方差来表达，即$var(F_1)$越大，表示$F_1$包含的信息越多。因此在所有的线性组合中所选取的$F_1$应该是方差最大的，故称之为<strong>第一主成分（Principal  Component I）</strong>。</p><p>如果第一主成分不足以代表原来$p$个变量的信息，再考虑选取$F_2$即第二个线性组合。$F_2$称为<strong>第二主成分（Principal  cComponent II）</strong>。 F1和F2的关系？</p><p>为了有效地反映原来信息，F1已有的信息就不再出现在F2中，即$cov(F1,F2)＝0$。依此类推，可以获得$p$个主成分。因此，这些主成分之间是互不相关的，而且方差依次递减。在实际中，挑选前几个最大主成分来表征。标准？</p><p> 各主成分的累积方差贡献率&gt;80%或特征根&gt;1。</p></blockquote><h2 id="3-主成分分析的数学模型"><a href="#3-主成分分析的数学模型" class="headerlink" title="3. 主成分分析的数学模型"></a>3. 主成分分析的数学模型</h2><p>假定有$n$个样本，每个样本共有$p$个维度，构成一个$n\times p$   阶的数据阵。</p><script type="math/tex; mode=display">X=\begin{bmatrix}x_{11} & x_{12} & \cdots & x_{1p}\\x_{21} & x_{22} & \cdots & x_{2p}\\\vdots & \vdots & \ddots & \vdots\\x_{n1} & x_{n1} & \cdots & x_{np}\\\end{bmatrix}</script><p>当p较大时，在p维空间中考察问题比较麻烦。为了克服这一困难，就需要进行降维处理，即用较少的几个综合变量代替原来较多的<br>变量变量，而且使这些较少的综合变量既能尽量多地反映原来较多变量变量所反映的信息。</p><p>要从原来的所有变量得到新的综合变量，一种较为简单的方法是作线性变换，使新的综合变量为原变量的线性组合，即</p><script type="math/tex; mode=display">\begin{cases}F_1=a_{11}x_1+a_{21}x_2+\cdots+a_{p1}x_p\\F_2=a_{12}x_1+a_{22}x_2+\cdots+a_{p2}x_p\\\qquad\qquad\qquad\vdots\\F_p=a_{1p}x_1+a_{2p}x_2+\cdots+a_{pp}x_p\\\end{cases}</script><p>此外，由于要求所有的主成分之间是没有信息重叠的，因此需要满足规范化条件，即</p><script type="math/tex; mode=display">a_{i1}^2+a_{i2}^2+\cdots+a_{ip}^2=1</script><p>此外，主成分分析要求：</p><ul><li>原始变量之间存在一定的相关性：如果多个变量相互独立或相关性很小，就不能进行主成分分析。<ul><li>首先可以使用Kaiser-Meyer-Olkin（KMO)检验（检验变量之间的偏相关系数是否过小）来进行判断，<strong>要求检验的值大于0.5为可以做，小于0.3为不建议做，0.3~0.5之间是可以做，但是不保证效果</strong></li><li>其次也可以用Bartlett’s 检验。该检验的原假设是相关矩阵为单位阵（不相关），如果不能拒绝原假设，则不适合进行主成分分析，<strong>要求检验的值小于0.05</strong></li><li>上面两个检验有一个就行</li></ul></li><li>各个综合变量间互不相关，即协方差为0</li><li>为了消除变量数量级/分布不同对方差的影响，通常对数据进行标准化处理，变量之间的协方差即为相关系数。</li></ul><p>将原有数据案列拆分为</p><script type="math/tex; mode=display">X=\begin{bmatrix}X_1 & X_2 & \cdots & X_p\end{bmatrix}=\begin{bmatrix}x_{11} & x_{12} & \cdots & x_{1p}\\x_{21} & x_{22} & \cdots & x_{2p}\\\vdots & \vdots & \ddots & \vdots\\x_{n1} & x_{n1} & \cdots & x_{np}\\\end{bmatrix}</script><p>则求</p><script type="math/tex; mode=display">\max_{\vec a} Var(F)， \quad F=\begin{bmatrix}a_1 & a_2 & \cdots & a_p\end{bmatrix} \times\begin{bmatrix}X_1 & X_2 & \cdots & X_p\end{bmatrix}^T</script><p>则将$F$的表达式展开，带入方差的计算式之后即可得到解</p><h2 id="4-PCA的Python求解"><a href="#4-PCA的Python求解" class="headerlink" title="4. PCA的Python求解"></a>4. PCA的Python求解</h2><p>Python中的scikit-learn中其实已经有了非常成熟的PCA的实现，因此我们直接用即可。</p><p>在sklearn中，PCA算法主要是由<code>sklearn.decomposition.PCA</code>类完成。该类的签名如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class sklearn.decomposition.PCA(n_components=None, *, copy=True, whiten=False, svd_solver='auto', tol=0.0, iterated_power='auto', random_state=None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，我们需要关注的参数有：</p><ul><li><strong>n_components</strong>：PCA算法中所要保留的主成分个数n，也即保留下来的特征个数n。int 或者 string，缺省时默认为None，所有成分被保留。赋值为int，比如n_components=1，将把原始数据降到一个维度。赋值为string，比如n_components=’mle’，将自动选取特征个数n，使得满足所要求的方差百分比。</li><li><strong>copy</strong>：bool，True或者False，缺省时默认为True。表示是否在运行算法时，将原始训练数据复制一份。若为True，则运行PCA算法后，原始训练数据的值不会有任何改变，因为是在原始数据的副本上进行运算；若为False，则运行PCA算法后，原始训练数据的值会改，因为是在原始数据上进行降维计算。</li><li><strong>whiten</strong>：bool，缺省时默认为False。白化，使得每个特征具有相同的方差</li></ul><p>其常用的属性如下：</p><ul><li>components_ ：返回具有最大方差的成分。</li><li>explained_variance_ratio_：返回 所保留的n个成分各自的方差百分比。_</li><li>n_components_：返回所保留的成分个数n。</li></ul><p>其常用的方法如下：</p><ul><li><p>fit(X,y=None)</p><p>fit()可以说是scikit-learn中通用的方法，每个需要训练的算法都会有fit()方法，它其实就是算法中的“训练”这一步骤。因为PCA是无监督学习算法，此处y自然等于None。</p></li><li><p>fit(X)，表示用数据X来训练PCA模型。</p><p>函数返回值：调用fit方法的对象本身。比如pca.fit(X)，表示用X对pca这个对象进行训练。</p></li><li><p>fit_transform(X)</p><p>用X来训练PCA模型，同时返回降维后的数据。newX=pca.fit_transform(X)，newX就是降维后的数据。</p></li><li><p>inverse_transform()</p><p>将降维后的数据转换成原始数据，X=pca.inverse_transform(newX)</p></li><li><p>transform(X)</p><p>将数据X转换成降维后的数据。当模型训练好后，对于新输入的数据，都可以用transform方法来降维。</p></li></ul><p>此外，还有get_covariance()、get_precision()、get_params(deep=True)、score(X, y=None)等方法，以后用到再补充吧。</p><h2 id="5-PCA案例"><a href="#5-PCA案例" class="headerlink" title="5. PCA案例"></a>5. PCA案例</h2><blockquote><p><strong>根据我国31个省市自治区2006年的6项主要经济指标数据，进行主成分分析，找出主成分并进行适当的解释</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109004849578.png" alt="主要经济指标"></p></blockquote><p>Python直接求解即可</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pandas as pdfrom pathlib import Pathimport sklearn.decomposition as skdecomposedf = pd.read_excel(Path(__file__).resolve().parent.joinpath("test1.xlsx"), index_col=0, header=0)pca = skdecompose.PCA(n_components=df.shape[1])new = pca.fit_transform(df.to_numpy())print(df)print(pd.DataFrame(new, index=df.index))print(pca.explained_variance_ratio_)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220109010518417.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 主成分分析 </tag>
            
            <tag> Principal Components Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法8-模糊综合评价模型</title>
      <link href="/2022/01/07/shu-xue-jian-mo-suan-fa-8-mo-hu-zong-he-ping-jie-mo-xing/"/>
      <url>/2022/01/07/shu-xue-jian-mo-suan-fa-8-mo-hu-zong-he-ping-jie-mo-xing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍了数学建模中常见的评价算法（模型）：模糊综合评价</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/v2-368fd890e8f6524b341b070804782bd2_1440w.jpg" alt="模糊综合评价法"></p><h1 id="数学建模算法8-模糊综合评价模型"><a href="#数学建模算法8-模糊综合评价模型" class="headerlink" title="数学建模算法8-模糊综合评价模型"></a>数学建模算法8-模糊综合评价模型</h1><p>在数学建模中，很多问题都涉及到评价类问题。而针对评价类问题，我们在前面介绍了层次分析法、灰色综合分析两种用于评价的方法/模型。本文将介绍第三种评价模型：模糊综合评价模型。</p><p>层次分析法适合于对指标这类主观性较强、数据量较少的问题进行评价，而灰色综合分析适合于少量数据并且已知标准（参考向量）的这类评价问题。</p><p>然而在生活中还有一类评价问题：即评价的等级之间是模糊的这一类评价问题。例如现在对一群人的身高进行评价，那么高和矮就是我们可以给出的评价的等级。然而这样的评价等级是模糊的，例如什么样的身高算高、什么算矮、高矮之间的分界线是什么？</p><p>因此针对这类评价等级是模糊的问题，就有了模糊综合评价模型。</p><h2 id="1-模糊数学介绍"><a href="#1-模糊数学介绍" class="headerlink" title="1. 模糊数学介绍"></a>1. 模糊数学介绍</h2><p>现实世界中的许多现象和关系具有不确定性。 这些不确定性的表现形式多种多样，如随机性、 灰色性、模糊性和粗糙性等。</p><p>模糊数学正是利用模糊集及其运算研究、处理模糊不确定现象和关系的数学分支学科。许多数学建模问题包括模糊现象和关系，这类 问题往往可以用模糊数学方法处理。</p><p>下面是百度百科和维基百科上对其的介绍</p><blockquote><p><strong>From BaiduBaike</strong>：</p><p>模糊数学又称Fuzzy 数学，是研究和处理模糊性现象的一种数学理论和方法。模糊性数学发展的主流是在它的应用方面。<br>由于模糊性概念已经找到了模糊集的描述方式，人们运用概念进行判断、评价、推理、决策和控制的过程也可以用模糊性数学的方法来描述。例如模糊聚类分析、模糊模式识别、模糊综合评判、模糊决策与模糊预测、模糊控制、模糊信息处理等。这些方法构成了一种模糊性系统理论，构成了一种思辨数学的雏形，它已经在医学、气象、心理、经济管理、石油、地质、环境、生物、农业、林业、化工、语言、控制、遥感、教育、体育等方面取得具体的研究成果。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107222908877.png" alt="百度百科上模糊数学的介绍"></p><p><strong>From Wikipedia</strong>：</p><p>模糊数学，亦称弗晰数学或模糊性数学。1965年以后，在模糊集合、模糊逻辑的基础上发展起来的模糊拓扑、模糊测度论等数学领域的统称。是研究现实世界中许多界限不分明甚至是很模糊的问题的数学工具。在模式识别、人工智能等方面有广泛的应用。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107222951369.png" alt="维基百科上对模糊数学的介绍"></p></blockquote><p>正如介绍中所指出的，现代数学是建立在集合论基础之上的。</p><p><strong>集合论的重要意义就在于它能将数学的抽象能力延伸到人类认识过程的深处：用集合来描述概念，用集合的关系和运算表达判断和推理，从而将一切现实的理论系统都纳入集合描述的数学框架中</strong>。毫无疑问，以经典集合论为基础的精确数学和随机数学在描述自然界多种客观现象的内在规律中，获得了显著的效果。</p><p>但是，和随机现象一样，在自然界和人们的日常生活中普遍存在着大量的模糊现象，如多云、阴灭、小雨、大雨、贫困、温饱等。<strong>由于经典集合论只能把自己的表现力限制在那些有明确外延的现象和概念上，它要求元素对集合的隶属关系必须是明确的，不能模棱两可</strong>，因而对于那些经典集合无法反映的外延不分明的概念，以前人们都是尽量回避它们。</p><p>然而，随着现代科技的发展，我们所面对的系统日益复杂，模糊性总是伴随着复杂性出现；此外人文、社会学科及其他“软科学”的数学化、定量化趋向，也把模糊性的数学处理问题推向中心地位；更重要的是，计算机科学、控制理论、系统科学的迅速发展，要求计算机要像人脑那样具备模糊逻辑思维和形象思维的功能。凡此种种，迫使人们再也无法回避模糊性，必须寻求途径去描述和处理客观现象中非清晰、非绝对化的一面。</p><p>1965年，美国控制论专家扎德Zadeh(Lotfi A．Zadeh)教授在Information and Control杂志上发表了题为Fuzzy Sets的论文，<strong>提出用“隶属函数”来描述现象差异的中间过渡，从而突破了经典集合论中属于或不属于的绝对关系</strong>。Zadeh教授这一开创性的工作，标志着数学的一个新分支——模糊数学的诞生。</p><h2 id="2-基础概念"><a href="#2-基础概念" class="headerlink" title="2. 基础概念"></a>2. 基础概念</h2><p>在介绍模糊综合评价模型前，需要介绍模糊数学中的一些基础概念</p><h3 id="A-模糊集、隶属度、隶属函数"><a href="#A-模糊集、隶属度、隶属函数" class="headerlink" title="A. 模糊集、隶属度、隶属函数"></a>A. 模糊集、隶属度、隶属函数</h3><p>给定论域$U$，定义$U$上的一个<strong>模糊集</strong>$A$为：</p><script type="math/tex; mode=display">\exists \mu_A(x), s.t. \forall x\in U \rightarrow\mu_A(x)\in[0,1]</script><p>称映射$\mu_A(x)$为模糊集$A$的<strong>隶属函数</strong>，而函数值$\mu_A(x)$称为元素$x$对模糊集$A$的<strong>隶属度</strong>。</p><p>因此，<strong>模糊集就是每个元素都有隶属度的集合</strong>。一个模糊集和一个隶属函数相关。</p><p>类比于概率，隶属度描述了一个元素属于这个模糊集的程度/概率</p><blockquote><p>例题：</p><p>从下列30条线段中选出长线段。设长度从1~30分别为30~1cm</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108104418258.png" alt="30条线段"></p><p>解：由题意得</p><p>“长”是模糊概念，因此可以用模糊集来描述。设$A$表示“长线段”的集合，$x_i,i=1,\cdots,30$表示第$i$条线段，则论域为$U={x_1,x_2,\cdots,x_{30}}$。</p><p>则线段$x_i$作为集合$A$的成员的资格即为$x_i$对$A$的隶属度。因此建立集合$A$的一种隶属函数如下：</p><p>因为线段越长，则其属于$A$的程度越大，因此线段$A$的长短可以用于作为表示A的隶属度。</p><p>从而，令$A(x_1)=1,A(x_2)=0$，作直线：</p><script type="math/tex; mode=display">A(x_i)-0=\frac{1-0}{1-30}(i-30)</script><p>故得到第$i$条线段$x_i$属于长线段集合$A$的隶属函数为：</p><script type="math/tex; mode=display">A(x_i)=\frac{1}{29}(30-i),\qquad i=1,2,\cdots,30</script></blockquote><h3 id="B-隶属函数"><a href="#B-隶属函数" class="headerlink" title="B. 隶属函数"></a>B. 隶属函数</h3><p><strong>隶属函数是将元素映射到隶属度的函数</strong>，其建立了元素和模糊评价之间的联系例如，身高175cm和高之间，假设在当前人群中高个子人群构成的模糊集$A$的隶属函数为$\mu_A$，那么若$\mu_A(175)=0.87$，那么我们就可以认为175cm的身高在当前人群中是高的，即175cm的人属于模糊集$A$。我们也可以理解为175cm的身高在当前人群中有87%的概率是高的。</p><h3 id="C-模糊集的运算"><a href="#C-模糊集的运算" class="headerlink" title="C. 模糊集的运算"></a>C. 模糊集的运算</h3><p>由于模糊集中没有元素和集合间的绝对隶属关系，所以模糊集的运算是通过隶属函数完成的。</p><p>设集合$A$、$B$为两个模糊集，其隶属函数分别为$\mu_A(x),\mu_B(x)$，则集合$A$与$B$常见的运算为：</p><ol><li><strong>包含</strong>：$A\subseteq B \Leftrightarrow \forall x \in A, \mu_A(x)\leq \mu_B(x)$</li><li><strong>相等</strong>：$A= B \Leftrightarrow \forall x \ in A, \mu_A(x) = \mu_B(x)$</li><li><strong>交</strong>：$C=A\cap B \Leftrightarrow \mu_C(x) = \mu_A(x)\land \mu_B(x)$</li><li><strong>并</strong>：$C=A\cup B \Leftrightarrow \mu_C(x) = \mu_A(x)\lor \mu_B(x)$</li><li><strong>补</strong>：$A^c\Leftrightarrow\mu_{A^C}(x)=1-\mu_{A}(x)$</li><li><strong>内积</strong>：$A\times B=\lor_{x\in U}(A(x)\land B(x))$</li><li><strong>外积</strong>：$A\otimes B=\land_{x\in U}(A(x)\lor B(x))$</li></ol><h2 id="3-隶属函数的确定"><a href="#3-隶属函数的确定" class="headerlink" title="3. 隶属函数的确定"></a>3. 隶属函数的确定</h2><p>由模糊集的概念可知，<strong>模糊数学的基本思想是用隶属度代替绝对的属于还是不属于</strong>，所以<strong>应用模糊数学方法建立数学模型的关键是建立符合实际的隶属函数</strong>。然而，如何确定一个模糊集的隶属函数至今还是尚未完全解决的问题。</p><p>目前，<strong>确定隶属度的常用方法是模糊分布法</strong>。模糊分布法将隶属函数看成一种模糊 分布，首先根据问题性质选取适当的模 糊分布，然后再依据相关数据确定分布中的参数。</p><p>模糊分布中常用的梯形分布如下</p><h3 id="A-偏小型"><a href="#A-偏小型" class="headerlink" title="A. 偏小型"></a>A. 偏小型</h3><p>偏小型指值越小越属于这个模糊集，对应的，其隶属函数如下：</p><script type="math/tex; mode=display">\begin{cases}1, & x< a\\\frac{b-x}{b-a}, & a \leq x \leq b\\0, & b < x\end{cases}</script><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108132351591.png" alt="偏小型隶属函数"></p><h3 id="B-偏大型"><a href="#B-偏大型" class="headerlink" title="B. 偏大型"></a>B. 偏大型</h3><p>偏大型指值越大越属于这个模糊集，对应的，其隶属函数如下</p><script type="math/tex; mode=display">\begin{cases}0, & x< a\\\frac{x-a}{b-a}, & a \leq x \leq b\\1, & b < x\end{cases}</script><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108132706169.png" alt="偏大型隶属函数"></p><h3 id="C-中间型"><a href="#C-中间型" class="headerlink" title="C. 中间型"></a>C. 中间型</h3><p>中间型指值越大和越小都不属于这个模糊集，只有在中间的时候才属于这个模糊集，例如人群中不高不矮的人群。其隶属函数如下</p><script type="math/tex; mode=display">\begin{cases}0, & x< a\\\frac{x-a}{b-a}, & a \leq x < b\\1, & b \leq x < c\\\frac{d-x}{d-c}, &c\leq x < d\\0, & d \leq x\end{cases}</script><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108133025758.png" alt="中间型隶属函数"></p><h2 id="4-模糊综合评价法"><a href="#4-模糊综合评价法" class="headerlink" title="4. 模糊综合评价法"></a>4. 模糊综合评价法</h2><p>评价是人类社会中经常性的、极为重要的认识活动。 <strong>对一个事物的评价通常要涉及多个因素或多个指标</strong>，评价是在多因素相互作用下的一种综合评判。</p><p>综合评价是数学建模竞赛中较为常见的问题， 如</p><ul><li>长江水质的评价与预测(2005A)</li><li>艾滋病疗法的 评价及疗效的预测(2006B)</li><li>2010上海世博会影 响力的定量评估(2010B)</li></ul><p>综合评价的方法众多，常用的有<strong>灰色评价法</strong>、 <strong>层次分析法</strong>、<strong>模糊综合评价法</strong>、<strong>数据包络分析法</strong>、 <strong>人工神经网络评价法</strong>、<strong>理想解法</strong>等。有时，还可将两种评价方法集成为组合评价方法。</p><p>各种评价方法出发点不同，解决问题的思路不同，适用对象不同，各有优缺点。不同的评价方法会产生不同的评价结论，有时甚至结论相左，即综合评价的结果不是唯一的。</p><p>而下面就将讲解其中的模糊综合评价法</p><h3 id="A-模糊综合评价法介绍"><a href="#A-模糊综合评价法介绍" class="headerlink" title="A. 模糊综合评价法介绍"></a>A. 模糊综合评价法介绍</h3><p>模糊综合评价作为模糊数学的一种具体应用，最早由我国学者汪培庄提出。基本思想是：<strong>以模糊数学为基础， 应用模糊关系合成原理，将一些边界不清、不易定量的因素定量化，从多个因素对被评价事物隶属等级状况进行综合评价</strong>。</p><p>具体步骤为：</p><ul><li>首先确定被评价对象的<strong>因素集</strong>和<strong>评价集</strong>（例如对成绩进行评价，那么语文、数学、英语就是因素集，而优、良和几个是评价集）</li><li>然后再分别确定各因素的权重及它们的隶属度向量，获得模糊评价矩阵</li><li>最后将模糊评价矩阵与因素的权向量进行模糊运算并归一化，从而得到模糊评价综合结果。</li></ul><p>模糊综合评价法简单易掌握，对多因素、多层次的复杂问题评价效果较好，很难为其它评价方法所替代。</p><h3 id="B-模糊综合评价法的步骤"><a href="#B-模糊综合评价法的步骤" class="headerlink" title="B. 模糊综合评价法的步骤"></a>B. 模糊综合评价法的步骤</h3><h4 id="1-确定评价指标和评价等级（因素集和评价集）"><a href="#1-确定评价指标和评价等级（因素集和评价集）" class="headerlink" title="1. 确定评价指标和评价等级（因素集和评价集）"></a>1. 确定评价指标和评价等级（因素集和评价集）</h4><p>设$U={u_1,u_2,\cdots,u_m}$为刻画被评价对象的$m$中因素（评价指标），$V={v_1,v_2,\cdots,v_n}$为刻画所有因素所处的状态的$n$种评语（评价等级）。</p><p>这里，$m$为评价因素的个数，通常由具体指标体系决定；$n$为评语的个数， 一般划分为3～5个等级。</p><blockquote><p><strong>某服装厂欲采用模糊综合评价法来了解顾客对某种服装的欢迎程度</strong>：</p><ol><li><p><strong>确定评价指标和评价等级</strong></p><p>顾客是否喜欢某种服装，通常与这种服装的花色、样式、价格、耐用度和舒适度等因素有关，故确定评价服装的因素集为</p><script type="math/tex; mode=display">U=\{花色, 样式, 价格, 耐用度，舒适度\}</script><p>综合评价的目的是弄清楚顾客对衣服各方面的欢迎程度，因此每个因素都可能受欢迎、不受欢迎等等。因此，评价集应为 </p><script type="math/tex; mode=display">V=\{很欢迎, 欢迎, 一般, 不欢迎\}</script></li></ol></blockquote><h4 id="2-构造模糊综合评价矩阵"><a href="#2-构造模糊综合评价矩阵" class="headerlink" title="2. 构造模糊综合评价矩阵"></a>2. 构造模糊综合评价矩阵</h4><p>在确定了评价指标和评价等级后，接着就要对每个评价指标$u_i(i=1,\cdots,m)$ 逐一进行模糊评价。</p><p>具体评价方法是：</p><ol><li><p>对评价指标$u_i$给出其能被评为等级$v_j$的隶属度$r_{ij}$。$r_{ij}$可理解为指标$u_i$对于等级$v_j$的隶属度，通常要将$r_{ij}$归一化以便于使用</p></li><li><p>设指标$u_i$的模糊评价为$r_i = ( r_{i1} , r_{i2} , \cdots, r_{in})$，则对所有评价指标$u_i(i=1,\cdots, m)$ 进行的模糊评价构成的<strong>矩阵$R$称为各指标的模糊综合评价矩阵</strong>。其中，</p><script type="math/tex; mode=display">R=(r_{ij})_{m\times n}\begin{bmatrix}r_{11} & r_{12} & \cdots & r_{1n}\\r_{21} & r_{22} & \cdots & r_{2n}\\\vdots & \vdots & \ddots & \vdots \\r_{m1} & r_{m2} & \cdots & r_{mn}\\\end{bmatrix}</script></li><li><p><strong>一般在真实问题中，隶属度$r_{ij}$可以通过频率法确定</strong></p></li></ol><blockquote><p><strong>某服装厂欲采用模糊综合评价法来了解顾客对某种服装的欢迎程度</strong>：</p><ol><li><p><strong>构造模糊综合评价矩阵</strong></p><p>服装厂通过问卷调查，对该服装的花色进行调查，众多被调查者中有20%认为“很欢迎”, 50%认为“欢迎”，30%认为“一般” ， 没有人认为“不欢迎”，则$u_1=花色$的评价向量为$R_1=(0.2, 0.5, 0.3, 0)$。同理，得到$R_2,R_3,R_4,R_5$，那么得到的模糊综合评价矩阵为</p><script type="math/tex; mode=display">R=\begin{bmatrix}R_1\\R_2\\R_3\\R_4\\R_5\\\end{bmatrix}=\begin{bmatrix}0.2 & 0.5 & 0.3 & 0\\0.1 & 0.3 & 0.5 & 0.1\\0 & 0.1 & 0.6 & 0.3\\0 & 0.4 & 0.5 & 0.1\\0.5 & 0.3 & 0.2 & 0\\\end{bmatrix}</script></li></ol></blockquote><h4 id="3-评价指标权重的确定"><a href="#3-评价指标权重的确定" class="headerlink" title="3. 评价指标权重的确定"></a>3. 评价指标权重的确定</h4><p>确定了模糊综合评价矩阵，尚不足以对事物做出评价。<strong>原因在于，各评价指标在评价目标中有不同的地位和作用，即各评价指标在综合评价中占有不同的权重</strong>。</p><p>为此，通常引入一个<strong>模糊向量</strong>$A=(a_1 , a_2 ,\cdots,a_n)$ 来表示各评价指标在目标中所占权重，称之为$权重向量$。其中$a_i$为$u_i$的权重，$\sum a_i=1, a_i\ge 0$。</p><p><strong>确定权重通常有主观和客观两类方法</strong>：</p><ul><li>主观法的代表是层次分析法，即通过因素（层次分析法中的指标）的比较矩阵判断得出来一个权重向量</li><li>客观法是根据各指标间的联系，利用数学方法计算出各指标的权重，如质量分数法、变异系数法等。</li></ul><blockquote><p><strong>变异系数法</strong></p><p>变异系数法的设计原理是：<strong>若某项指标的数值差异较大，能明确区分开各被评价对象，说明该指标的分辨信息丰富，因而应给该指标以较大的权重；反之，若各个被评价对象在某项指标上的数值差异较小，那么这项指标区分各评价对象的能力较弱，因而应给该指标较小的权重</strong></p><p>因为方差可以描述取值的离散程度，即某指标的方差反映了该指标的的分辨能力， 所以可用方差定义指标的权重。由于方差的大小是相对的，还需考虑指标取值的大小、量级，故指标的分辨能力可定义为</p><script type="math/tex; mode=display">v_i=\frac{s_i}{|\bar x_i|}</script><p>例：已知5个投资方案如下表，试确定4个评价指标的权重</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108141518205.png" alt="五个投资方案" style="zoom: 50%;"></p><p>解：根据变异系数法，可按照下列步骤 确定各指标的权重</p><ol><li><p><strong>计算第$i$项指标的均值与方差</strong>：</p><script type="math/tex; mode=display">\bar x_i=\frac 1 n \sum_{j=1}^na_{ij}\\s_i^2=\frac 1{n-1} \sum_{j=1}^n (a_{ij}-\bar x_i)^2</script></li><li><p>计算每个指标的分辨能力，取归一化后的分辨能力为各指标的权重</p><script type="math/tex; mode=display">v_i = \frac {s_i} {|\bar x_i|}\\w_i = \frac {v_i}{\sum v_i}</script></li><li><p>最终解得，四个指标的权重为：$w=(0.244, 0.172, 0.173, 0.412)$</p></li></ol><p>需要指出的是，<strong>用变异系数法求出的某指标的权重与该指标在评价体系中的重要性是两个概念，变异系数法的作用只是提高指标的分辨能力，利于排序</strong>。因为变异系数法的权重计算是根据指标的分辨能力计算的。</p><p>其实，<strong>使用变异系数法的前提恰恰是所有指标在评价体系中的重要性相当</strong>。 也就是说，当<strong>指标在评价体系中的重要性相差较大时，使用变异系数法确定权重并不一定合适</strong></p></blockquote><h4 id="4-模糊合成与综合评价"><a href="#4-模糊合成与综合评价" class="headerlink" title="4. 模糊合成与综合评价"></a>4. 模糊合成与综合评价</h4><p>模糊综合评价矩阵R中的不同行反映了被评价事物从不同的指标评价对各等级的隶属程度。<strong>用权向量A将不同的行进行综合，就可得到被评价事物从总体上对各等级的隶属程度，即模糊综合评价结果</strong>。</p><p>通常采用所谓的<strong>模糊合成</strong>来实现上述的综合。</p><p>模糊合成的基本思想是：<strong>对评价矩阵$R$和权向量$A$进行某种适当的模糊运算, 将两者合成为一个模糊向量$B={b_1,b_2,\cdots,b_n}$， 即$B=A M R$，$M$为模糊合成算子然后对B按照一定法则进行综合分析后即可得出最终的模糊综合评价结果</strong>。</p><p>常见的模糊合成算子有：</p><ul><li>主因素突出型：$M(\land, \lor):b_j=\lor_{i=1}^m(a_i\land r_{ij})$</li><li>主因素突出型：$M(\cdot, \lor):b_j=\lor_{i=1}^m(a_i\cdot r_{ij})$</li><li>加权平均型：$M(\land, \oplus):b_j=\sum_{i=1}^m(a_i\land r_{ij})$</li><li>加权平均型：$M(\cdot, \oplus):b_j=\sum_{i=1}^m(a_i\cdot r_{ij})$</li></ul><p>注意，算子是对矩阵沿列计算的，相当于A右乘R，同时使用算子。即<code>np.apply_along_axis(axis=1)</code></p><p>上述模糊合成算子的特点如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108143220851.png" alt="模糊合成算子的特点" style="zoom:67%;"></p><p>此外，也可以取M为普通的矩阵乘法， 此时合成即为加权平均。至于到底取何种算子取决于问题的性质和算子的特点。</p><p>通常而言，采用<strong>主因素突出型</strong>和<strong>加权平均型算法</strong>的结果大同小异。但在实际中还是要注意这两类算法的特点：</p><ul><li>主因素突出型适用于模糊矩阵中数据相差很悬殊的情形</li><li>加权平均型则常用于因素很多的情形，可以避免信息丢失</li></ul><p>此外，上面的$B$全称为<strong>模糊综合评价向量</strong>，满足$0\leq b_j \leq 1$，且$b_j$需要进行归一化。$b_j$可以理解为被评价对象对第$j$等级的隶属度。</p><p>对$B$分析处理后即可获得综合评价结果。分析处理$B$的常用方法有：</p><ol><li><p><strong>最大隶属度法</strong>：即认定被评价对象的等级为最大隶属度对应的等级, 适用于某隶属度明显大于其它隶属度的情形</p></li><li><p><strong>加权平均法</strong>：具体方法是，给定评价集$V={v_1 ,v_2 ,\cdots,v_n}$中的各等级赋以适当的分值$C={c_1,c_2,\cdots,c_n}$，用归一化的综合评价向量$B={b_1,b_2,\cdots,b_n}$对C的加权平均，得到的值就是模糊综合评价的结果，即：</p><script type="math/tex; mode=display">最终评价=\sum_{i=1}^nc_ib_i</script></li></ol><blockquote><p>例如, 设评价等级集为${很好, 好, 一 般, 差}$，综合评价向量$B=[0.4, 0.3, 0.2, 0 . 1 ]$。</p><ul><li>按最大隶属度法，评价等级为 “很好”。</li><li>若给评价集分别赋值$[4, 3, 2, 1]$，则加权平均值为4 * 0.4 + 3 * 0.3 + 2 * 0.2 + 1 * 0.1 = 3.0，评价为好</li></ul></blockquote><h3 id="C-模糊综合评价法的案例"><a href="#C-模糊综合评价法的案例" class="headerlink" title="C. 模糊综合评价法的案例"></a>C. 模糊综合评价法的案例</h3><blockquote><p><strong>教师教学评价</strong></p><p>在教学过程的综合评价中，取因素集$U={清楚易懂, 教材熟悉, 生动有趣, 板书整齐清晰}$，评价集 $V={很好, 较好, 一般,不好}$。设某班学生对教师的教学评价矩阵为</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108150003732.png" alt="评价矩阵" style="zoom:67%;"></p><p>若考虑评价集的权重$A=(0.5, 0.2, 0.2, 0.1)$，试求学生对这位教师的综合评价。</p><p>解：</p><p>根据A和R，利用四种合成算子， 编程计算得</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108151125965.png" alt="模糊综合评价矩阵" style="zoom:50%;"></p><p>可以看出，第二列较大而第三列较小，因此就认为老师0.3左右是很好的老师，0.4左右是较好的老师，0.2左右是不好的老师，0.06左右是不好的老师</p></blockquote><h3 id="D-模糊综合评价矩阵的获得"><a href="#D-模糊综合评价矩阵的获得" class="headerlink" title="D. 模糊综合评价矩阵的获得"></a>D. 模糊综合评价矩阵的获得</h3><p>上面举得例子简单明了，然而上面的例子实在是太过于简单，因为不仅给出了模糊综合评价矩阵$R$，而且还直接给出了权重向量$A$。实际问题往往只提供了一系列的评价对象以及每个对象的若干评价指标，并且这些指标可能数值差异很大，性质也不同。</p><p>此时，不仅指标的权重向量$A$需要根据适当的方法确定，就连评价矩阵$R$也要按照某种方法对评价指标进行处理后才能获得。</p><ul><li>确定权重向量$A$的常用方法是前面介绍的<strong>变异系数法</strong></li><li>而处理评价指标获取评价矩阵$R$的常用方法除了前面的评论法以外，还有：<strong>相对偏差法</strong>和<strong>相对优属度法</strong></li></ul><h4 id="1-相对偏差模糊矩阵评价法"><a href="#1-相对偏差模糊矩阵评价法" class="headerlink" title="1.  相对偏差模糊矩阵评价法"></a>1.  相对偏差模糊矩阵评价法</h4><p>相对偏差模糊矩阵评价法与灰色关联分析有点类似。首先虚拟一个理想方案$u$，然后按照某种方法建立各方案与$u$的偏差矩阵$R$，再确定各评价指标的权重$A$，最后用$A$对$R$加权平均得各方案与$u$的综合距离$F$，则根据$F$即可对方案进行排序即可。</p><p>相对偏差法评价法的基本步骤如下：</p><ol><li><p><strong>虚拟理想方案</strong>：</p><script type="math/tex; mode=display">u=(u_1, u_2,\cdots, u_n)</script><p>其中，即越多越好的取最大值，越少越好的取最小值</p><script type="math/tex; mode=display">u_i=\begin{cases}\max_j{a_{ij}}, & a_{ij}为效益型指标，即越大越好\\\min_i{a_{ij}}, & a_{ij}为成本型指标，即越小越好\end{cases}</script></li><li><p><strong>建立相对偏差模糊矩阵$R$</strong></p><script type="math/tex; mode=display">R=\begin{bmatrix}r_{11} & r_{12} & \cdots & r_{1n}\\r_{21} & r_{22} & \cdots & r_{2n}\\\vdots & \vdots & \ddots & \vdots \\r_{m1} & r_{m2} & \cdots & r_{mn}\\\end{bmatrix}</script><p>其中，$a_{ij}$为收集得到的数值</p><script type="math/tex; mode=display">r_{ij}=\frac{|a_{ij}-u_i|}{\max_j a_{ij} - \min_j a_{ij}}</script></li><li><p>确定各评价指标权重$w_i$</p></li><li><p>对各方案的偏差加权平均</p><script type="math/tex; mode=display">F_j=\sum_{i=1}^mw_ir_{ij},\qquad j=1,2,\cdots,n</script></li><li><p>根据$F_j$值进行综合评价：若$F_t$&lt;$F_s$，则第$t$个方案排在第$s$个方案之前</p></li></ol><blockquote><p><strong>技术方案评价</strong></p><p>现有下列5个农业技术经济方案，试评价各方案的优劣。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108153619522.png" alt="五个技术方案" style="zoom: 50%;"></p><p>解：</p><p>上述评价指标中，产量、肥力是效益型，而其余均为成本型。</p><ol><li><p>理想方案为:</p><script type="math/tex; mode=display">u=[1000, 60, 4000, 1, 30, 0.5, 1]</script></li><li><p>根据前述方法求出相对偏差模糊矩阵</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108153803418.png" alt="五个技术方案的相对偏差矩阵" style="zoom:50%;"></p></li><li><p>由变异系数法求出指标权重</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108153841727.png" alt="求指标权重" style="zoom:50%;"></p><p>得到指标权重为</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108153907216.png" alt="指标权重" style="zoom:50%;"></p></li><li><p>求加权平均偏差并排序</p><script type="math/tex; mode=display">加权平均偏差为=[0.3525, 0.4558, 0.4505, 0.5206, 0.5864]</script><p>故方案的优劣次序为1、3、2、4、5。</p></li></ol></blockquote><h4 id="2-相对优属度模糊矩阵评价法"><a href="#2-相对优属度模糊矩阵评价法" class="headerlink" title="2. 相对优属度模糊矩阵评价法"></a>2. 相对优属度模糊矩阵评价法</h4><p>相对偏差法的评价依据是各方案与理想方案的偏差，而<strong>相对优属度评价法的基本思想是：首先用适当的方法将所有指标(效益型、 成本型、固定型)转化为效益型(成本型)，得到优属度矩阵$R$，再确定各评价指标的权重$A$，最后用$A$对$R$加权平均得各方案的综合优属度$F$, 则根据$F$即可对方案进行排序</strong></p><p>相对优属度评价法步骤如下：</p><ol><li><p>建立模糊效益矩阵$R_{ij}$    ，其中$\alpha_j$是第$j$个指标的适度值</p><script type="math/tex; mode=display">r_{ij}=\begin{cases}\frac {a_{ij}}{\max_j a_{ij}}, & a_{ij}为效益型\\\frac {\min_j a_{ij}}{a_{ij}}，& a_{ij}为成本型\\\frac {\min_j |a_{ij}-\alpha_j|}{a_{ij}-\alpha_j}, & a_{ij}为固定型\end{cases}</script></li><li><p>确定各评价指标权重$w_i$</p></li><li><p>对各方案的偏差加权平均</p><script type="math/tex; mode=display">F_j=\sum_{i=1}^mw_ir_{ij},\qquad j=1,2,\cdots,n</script></li><li><p>根据$F_j$值进行综合评价：若$F_t&gt;F_s$，则第$t$个方案排在第$s$个方案之前</p></li></ol><blockquote><p><strong>投资方案评价</strong></p><p>已知5个投资方案如下表，试确定4个评价指标的权重</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108141518205.png" alt="五个投资方案" style="zoom: 50%;"></p><p>解：</p><p>4个指标中，投资额、风险损失为成本型，期望净现值、风险盈利值为效益型</p><ol><li><p>按前述方法建立相对优属度模糊矩阵</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108155736847.png" alt="相对优属度模糊矩阵"></p></li><li><p>由变异系数法求出指标权重</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108155807607.png" alt="指标权重"></p></li><li><p>各方案的加权平均优属度</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220108155831023.png" alt="加权平均优属度"></p></li></ol><p>故方案排序为1, 3, 5, 2, 4</p></blockquote><h2 id="5-灰色关联分析、相对偏差法以及相对优属度法的讨论"><a href="#5-灰色关联分析、相对偏差法以及相对优属度法的讨论" class="headerlink" title="5. 灰色关联分析、相对偏差法以及相对优属度法的讨论"></a>5. 灰色关联分析、相对偏差法以及相对优属度法的讨论</h2><p>我们在前面介绍了灰色关联分析，这里又介绍了相对偏差法和相对优属度法。三者尽管具体的步骤不同，但是其核心思想都是一致的，即：找出当前评价体系下最优的方案，然后将现有的方案和最优的方案进行比较，以偏差最小的方案作为最佳方案。</p><p>因此，我们自然就会有一个问题：这三种方法评价同一问题的结论完全一致吗？</p><blockquote><p><strong>针对上面的投资方案</strong></p><ul><li>相对偏差法的方案排序为：1、3、5、4、2</li><li>相对优属度法的排序为：1、3、5、2、4</li><li>灰色关联分析：1、3、2、4、5</li></ul><p><strong>针对上面的农业技术方案</strong>：</p><ul><li>相对偏差法的方案排序为：1、4、2、3、5</li><li>相对优属度法的排序为：1、3、2、4、5</li><li>灰色关联分析：1、3、2、5、4</li></ul></blockquote><p>对于相对偏差法和相对优属度法而言，两者的因素（指标）的权重的计算是依靠变异系数法求得的，而灰色关联分析中我们最后实际上没有乘以权重矩阵，而是把每个指标当做同等重要对待，因此会存在不同</p><p>此外，三者中间得到评价矩阵的方式不同，灰色关联分析是用最大和最小的偏差来描述的，而相对偏差则是偏差，相对优属度法通过函数（等效优属度）。</p><p>因此上述两个原因就是导致三个方法排序得到的指标并不相同的结果，因此：</p><ul><li>灰色关联分析法、相对偏差法和相对优属度法对同一问题的评价、排序结果不尽相同；</li><li>当各指标在评价体系重要性相当时，用变异系数法确定指标权重，可提高上述方法排序的分辨率</li><li>当各指标在评价体系重要性差异较大时，可考虑用层次分析法确定指 标权重</li><li>在实际中, 对于评价类问题，应同时应用上述几种方法进行综合评价， 以提高评价的可靠性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 模糊数学 </tag>
            
            <tag> 模糊综合评价 </tag>
            
            <tag> Fuzzy Comprehension Evaluation Method </tag>
            
            <tag> fuzzy mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法7-一维二维插值以及拟合</title>
      <link href="/2022/01/07/shu-xue-jian-mo-suan-fa-7-yi-wei-er-wei-cha-zhi-yi-ji-ni-he/"/>
      <url>/2022/01/07/shu-xue-jian-mo-suan-fa-7-yi-wei-er-wei-cha-zhi-yi-ji-ni-he/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍了数学建模中常见的算法（数据处理方法）：插值以及拟合</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/300px-Splined_epitrochoid.svg.png" alt="插值" style="zoom:150%;"></p><p>PS：图的含义一组离散数据点在一个外延的插值。曲线中实际已知数据点是红色的；连接它们的蓝色曲线即为插值。</p><h1 id="数学建模算法7-一维二维插值以及拟合"><a href="#数学建模算法7-一维二维插值以及拟合" class="headerlink" title="数学建模算法7-一维二维插值以及拟合"></a>数学建模算法7-一维二维插值以及拟合</h1><p>严格意义上来说，和前面介绍的各种算法不同，插值和拟合都是数据处理的手段。而由于这个系列介绍的就是数学建模中常用的知识，包括了常用算法、常用问题和常用技巧，因此也一并介绍。</p><p>在数学建模的过程中，经常出现的一类操作就是需要对数据进行补全以及外推。例如下面的例子</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107154114356.png" alt="数据补全的例子" style="zoom: 50%;"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107154218906.png" alt="数据外推的例子" style="zoom: 67%;"></p><p>从表象上来看，第一个例子中，我们需要的数据在已有的数据范围内，而第二个例子中我们需要的数据并不在已有的数据范围内，两个问题分别对应<strong>插值</strong>问题和<strong>拟合</strong>问题。其实更一般的，<strong>插值寻求得到函数解析式</strong>而<strong>拟合寻求得到趋势的解析式</strong>。之间的规律。</p><p>插值和拟合最大的区别在于，<strong>插值那就一定得过数据点</strong>。拟合，就是要得到<strong>最接近的结果，是要看总体效果，因此不一定过所有的数据点</strong>。例如下面的图中，左边一列是插值而右边的一列是拟合。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/v2-2d00103d6c2813e686caba5917d184c6_r.jpg" alt="插值和拟合的区别"></p><p>借用知乎上的回答:</p><blockquote><p>最小二乘意义下的拟合，是要求拟合函数与原始数据的均方误差达到极小，是一种整体意义的逼近，对局部性质没有要求。而所谓“插值”，就是要在原有离散数据之间“插入”一些值，这就要求插值函数必须通过所有的离散点，插值函数在离散点之外的那些点都相当于“插入”的值。插值有全局插值，也有局部插值（比如分段线性插值），插值误差通常考虑的是逐点误差或最大模误差，插值的好坏往往通过某些局部的性质来体现，比如龙格现象或吉布斯振荡。</p><p>作者：李晓<br>链接：<a href="https://www.zhihu.com/question/24276013/answer/32942153">https://www.zhihu.com/question/24276013/answer/32942153</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h1 id="一、插值"><a href="#一、插值" class="headerlink" title="一、插值"></a>一、插值</h1><p>先来看看一些插值的问题</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107161744700.png" alt="问题一" style="zoom: 67%;"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107161815987.png" alt="问题二" style="zoom: 67%;"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107161844996.png" alt="问题三" style="zoom: 67%;"></p><p>这些问题可归结为：已知函数在某区间 (域)内若干点处的值，求函数在该区间（域）内其它点处的值。这种问题适宜用插值方法解决。</p><p>因此，将一维插值问题描述为：</p><script type="math/tex; mode=display">已知函数在x_0,x_1,\cdots,x_n处的值y_0,y_1,\cdots,y_n。求简单函数p(x)，使得p(x_i)=y_i</script><p>由于泰勒定理，对于一个足够光滑的函数，可以用一个多项式函数来表示。因此一般将$p(x)$取为多项式。</p><p>此外，由范德蒙行列式和克莱姆法则可以证明，使得在$x_0,x_1,\cdots,x_n$处取值$y_0,y_1,\cdots,y_n$的多项式存在且唯一。因此插值问题一定有解，因为至少有一个多项式的解。</p><h2 id="1-插值的介绍"><a href="#1-插值的介绍" class="headerlink" title="1. 插值的介绍"></a>1. 插值的介绍</h2><p>关于插值，形象的理解就是在前面所说的，根据已有的数据生成得到已经采集到的数据域内的未采集的数据点。更加严谨的定义见下面百度百科和维基百科的介绍</p><blockquote><p><strong>From BaiduBaike</strong>：</p><p>在离散数据的基础上补插连续函数，使得这条连续曲线通过全部给定的离散数据点。 插值是离散函数逼近的重要方法，利用它可通过函数在有限个点处的取值状况，估算出函数在其他点处的近似值。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107160225083.png" alt="百度百科行对插值的介绍"></p><p><strong>From Wikipedia</strong>：</p><p>在数学的数值分析领域中，内插，或称插值（英语：Interpolation），是一种通过已知的、离散的数据点，在范围内推求新数据点的过程或方法。求解科学和工程的问题时，通常有许多数据点借由采样、实验等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。而根据这些数据，我们往往希望得到一个连续的函数（也就是曲线）；或者更密集的离散方程与已知数据互相吻合，这个过程叫做拟合。</p><p>与插值密切相关的另一个问题是通过简单函数逼近复杂函数。假设给定函数的公式是已知的，但是太复杂以至于不能有效地进行评估。来自原始函数的一些已知数据点，或许会使用较简单的函数来产生插值。当然，若使用一个简单的函数来估计原始数据点时，通常会出现插值误差；然而，取决于该问题领域和所使用的插值方法，以简单函数推得的插值数据，可能会比所导致的精度损失更大。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107160316529.png" alt="维基百科上对插值的介绍"></p></blockquote><h2 id="2-常见的插值方法"><a href="#2-常见的插值方法" class="headerlink" title="2. 常见的插值方法"></a>2. 常见的插值方法</h2><h3 id="A-最邻近插值"><a href="#A-最邻近插值" class="headerlink" title="A. 最邻近插值"></a>A. 最邻近插值</h3><p>最邻近插值即指使用最邻近的已采集的数据的值作为需要的点处的值</p><h3 id="B-线性插值"><a href="#B-线性插值" class="headerlink" title="B. 线性插值"></a>B. 线性插值</h3><p>线性插值通过已知点计算得到一个线性函数，从而通过线性函数来获得未知点的值</p><h3 id="C-样条插值"><a href="#C-样条插值" class="headerlink" title="C. 样条插值"></a>C. 样条插值</h3><p>样条函数指一种特殊的函数，由分段的多项式定义。样条插值即指分区间用多个低次多项式进行拟合</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Parametic_Cubic_Spline.svg/400px-Parametic_Cubic_Spline.svg.png" alt="样条函数的例子"></p><h3 id="D-多项式插值"><a href="#D-多项式插值" class="headerlink" title="D. 多项式插值"></a>D. 多项式插值</h3><p>对于$n$个点，选择一个高次的多项式来经过所有点。二次插值、三次差值都是多项式插值的特例。</p><h3 id="E-拉格朗日插值（Lagrange-Interpolation）"><a href="#E-拉格朗日插值（Lagrange-Interpolation）" class="headerlink" title="E. 拉格朗日插值（Lagrange Interpolation）"></a>E. 拉格朗日插值（Lagrange Interpolation）</h3><p>拉格朗日插值法（Lagrange Interpolation） 指的是在节点上给出节点基函数，然后通过基函数的线性组合，组合系数为节点函数值的一种插值方法。</p><p>例如现在需要对下面的三个点进行插值</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107163405396.png" alt="插值的例子"></p><p>虽然我们可以写一个多项式$f(x)=ax^2+bx+c$，然后去通过$(x_1,y_1),(x_2,y_2),(x_3,y_3)$这三个点获得三个式子，然后求解出来$a,b,c$三个系数即可。</p><p>然而这样做比较麻烦，因此拉格朗日插值法找到了分别通过$(x_1,y_1),(x_2,y_2),(x_3,y_3)$三个点的基函数，而基函数在其他点处的值为0。例如，通过$(x_1,y_1)$的基函数$f_1(x)$满足$f_1(x_1)=y\land f_1(x_2)=0 \land f_1(x_3)=0$。然后将三个基函数叠加即可。</p><p>在具体实操作上则找的是$f_1(x_1)=1\land f_1(x_2)=0 \land f_1(x_3)=0$，这样就可以设表达式是$f_1(x)=a(x-x_2)(x-x_3)$，然后带入$x_1,y_1)$求出$a$即可。</p><p>因此对于上面的例子，找到的基函数分别为下面三个：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107163925815.png" alt="三个基函数"></p><p>那么最终通过插值得到的表达式为</p><script type="math/tex; mode=display">f(x)=y_1f_1(x)+y_2f_2(x)+y_3f_3(x)</script><p>进一步，对于$n$个点进行拉格朗日插值法得到的表达式为</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^n y_i\prod_{j\neq i}\frac{x-x_j}{x_i-x_j}</script><h2 id="3-高次差值的Runge现象"><a href="#3-高次差值的Runge现象" class="headerlink" title="3. 高次差值的Runge现象"></a>3. 高次差值的Runge现象</h2><p>在研究插值问题的初期，所有人都想当然地认为（使用多项式插值的时候）插值多项式的次数越高，插值精度越高。然而Runge 通过对一个例子的研究发现， 上述结论仅仅在插值多项式的次数不超过七时成立；<strong>插值多项式的次数超过七时， 插值多项式会出现严重的振荡现象，称之为Runge现象</strong>。</p><p>例如我们下面对$f(x)=\frac 1 {1+25x^2}$从-1到1均匀的采点，然后用一个10次的多项式去拟合的结果。可以看到在中间（-0.2~0.2）拟合的还不错，可是越往两边越离谱，甚至只能保证曲线一定过这个点。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107165257557.png" alt="Runge现象的例子" style="zoom: 67%;"></p><p>然而若使用多项式插值，那么由于需要插值的点越来越多，多项式的次数一定会越来越高。因此为了解决龙格现象，使用分段的方式进行插值。即将所有的点分成多个区间，每个区间内用低次多项式进行插值，然后在区间的交界处通过二阶导连续等手段使得多个区间得到的多项式之间连续。例如上面介绍的样条插值。一般来说，为了所取得多项式次数最好少于7。</p><p>对上面的式子进行样条插值得到的结果如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107170128557.png" alt="样条插值的结果" style="zoom: 67%;"></p><h2 id="4-Python中的插值"><a href="#4-Python中的插值" class="headerlink" title="4. Python中的插值"></a>4. Python中的插值</h2><p>Python中的插值使用SciPy中的interpolate模块完成。</p><p>下面的内容主要参考<a href="https://zhuanlan.zhihu.com/p/136700122">博客</a>：<a href="https://zhuanlan.zhihu.com/p/136700122">https://zhuanlan.zhihu.com/p/136700122</a></p><h3 id="A-一维插值"><a href="#A-一维插值" class="headerlink" title="A. 一维插值"></a>A. 一维插值</h3><p>一维插值指的是自变量是一个标量，我们前面举得例子都是一维插值。</p><p>一维插值主要使用<code>scipy.interpolate.interp1d</code>类实现，其签名如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class scipy.interpolate.interp1d(x, y, kind='linear', axis=- 1, copy=True, bounds_error=None, fill_value=nan, assume_sorted=False)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，我们需要关注的有：</p><ul><li>x，y：需要插值的x和y的值</li><li>kind：插值方式，所有可选项为：‘linear’, ‘nearest’, ‘nearest-up’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’, ‘previous’, or ‘next’。默认为线性插值</li></ul><p>注意，该类实现了call方法，因此直接call即可</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport scipy.interpolate as scinterpimport matplotlib.pyplot as pltx = np.linspace(0, 3 * np.pi, 11)y = np.sin(x)x_a = np.linspace(0, 3 * np.pi, 1000)f = scinterp.interp1d(x, y)y_a = f(x_a)print(type(f))plt.plot(x, y)plt.plot(x_a, y_a)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="B-二维插值"><a href="#B-二维插值" class="headerlink" title="B. 二维插值"></a>B. 二维插值</h3><p>二维插值指的是自变量是一个具有两个分量的向量。虽然我们前面讲的都是一维插值的方法，其实对于二维插值，只需要对两个分量分别进行插值即可，即双xxx插值，例如双线性插值。</p><p>Python中实现二维插值主要使用<code>scipy.interpolate.interp2d</code>类实现，其签名如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class scipy.interpolate.interp2d(x, y, z, kind='linear', copy=True, bounds_error=False, fill_value=None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，需要关注的参数为：</p><ul><li>x, y：二维的点，要么是类似MATLAB的mesh一样的网格点，要么是两个等长的Numpy数组表示点的x，y坐标。</li><li>z：二维点对应的值</li><li>kind：插值方法，可选的选项有：‘linear’, ‘cubic’, ‘quintic’</li></ul><p>最后，一般来说一维插值用样条插值而二维插值用立方插值</p><h1 id="二、拟合"><a href="#二、拟合" class="headerlink" title="二、拟合"></a>二、拟合</h1><p>在插值问题中要求得到的函数解析式过所有数据点。然而再很多时候，数据量一大，这个时候插值得到的函数解析式无论怎么样都会很复杂。还有很多时候数据是没有解析式的。而且通过插值得到的函数的龙格现象和吉布斯震荡导致在数值域外的震荡非常大，往往使用插值得到的函数只能确保在数值域内的值可信而对数值域外的值不是非常可信。因此针对这种情况，我们就通过拟合来完成。</p><p>拟合的目的在于找出数据间的近似函数，其：</p><ol><li>拟合函数不一定过所有数据点</li><li>插值主要求函数值，而拟合主要求函数关系，从而进行进一步的预测</li></ol><p>拟合的难点在于两个关键点：</p><ol><li>拟合曲线的线型选择</li><li>线型中参数的计算</li></ol><p>通常而言，线型的选择依靠专业知识（先验知识）和散点图；而参数的计算，若为线性拟合则用最小二乘法，非线性拟合则用Gauss-Newton迭代法。</p><h2 id="1-Python中的拟合"><a href="#1-Python中的拟合" class="headerlink" title="1. Python中的拟合"></a>1. Python中的拟合</h2><p>Python中的拟合主要依靠Numpy、Scipy中的函数</p><h3 id="A-多项式拟合"><a href="#A-多项式拟合" class="headerlink" title="A. 多项式拟合"></a>A. 多项式拟合</h3><p>多项式拟合主要使用Numpy中的<code>polyfit</code>函数，其函数签名如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">numpy.polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，我们需要关注的为：</p><ul><li>x, y: 需要拟合的数据的x和y的值</li><li>deg：拟合的多项式次数</li></ul><p>返回值为Numpy中的ndarray，分比为从高到低次的项的系数</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport matplotlib as mplimport matplotlib.pyplot as pltx = np.linspace(0, 2 * np.pi, 100)y = 1.5 * xy_noise = y + np.array([np.random.randn() for i in range(len(y))])coeff = np.polyfit(x, y=y_noise, deg=1)plt.plot(x, y)plt.plot(x, y_noise)plt.plot(x, x * coeff[0] + coeff[1])plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107220729119.png" alt="拟合的结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 一维二维插值 </tag>
            
            <tag> 拟合 </tag>
            
            <tag> Interpolation </tag>
            
            <tag> Fitting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法6-灰色关联分析与预测</title>
      <link href="/2022/01/06/shu-xue-jian-mo-suan-fa-6-hui-se-guan-lian-fen-xi-yu-yu-ce/"/>
      <url>/2022/01/06/shu-xue-jian-mo-suan-fa-6-hui-se-guan-lian-fen-xi-yu-yu-ce/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍了数学建模中常见的分析与预测算法：灰色关联分析和灰色预测</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/Steps-for-inscribed-cored-grey-relational-analysis-model-IC-GRA-model-calculations.png" alt="灰色关联分析"></p><h1 id="数学建模算法6-灰色关联分析与预测"><a href="#数学建模算法6-灰色关联分析与预测" class="headerlink" title="数学建模算法6-灰色关联分析与预测"></a>数学建模算法6-灰色关联分析与预测</h1><p>灰色关联分析法主要解决对一个系统中多个变量进行分析，从而得出哪些变量和目标变量之间是正相关，哪些是负相关。而灰色预测模型则是在灰色关联分析的基础上，对目标变量未来的发展趋势进行预测的算法。两者都属于灰色系统理论。</p><p>因此，灰色系统理论处理的问题为：<strong>相关性分析</strong>以及<strong>预测</strong>两类问题</p><p>灰色关联分析是数学建模中非常常用的一系列算法，例如：</p><ul><li>CUMCM2003A SARS的传播问题</li><li>CUMCM2005A 长江水质的评价和预测</li><li>CUMCM2006A 出版社的资源配置</li><li>CUMCM2006B 艾滋病疗法的评价及疗效的预测问题</li><li>CUMCM2007A 中国人口增长预测</li></ul><p>我们可以更详细的看一下其中的两个问题:</p><blockquote><p><strong>问题一：SARS传播问题</strong></p><p>SARS（Severe Acute Respiratory Syndrome，严重急 性呼吸道综合症, 俗称：非典型肺炎）是21世纪第一 个在世界范围内传播的传染病。SARS的爆发和蔓延 给我国的经济发展和人民生活带来了很大影响，我们 从中得到许多重要的经验和教训，认识到定量地研究 传染病的传播规律、为预测和控制传染病蔓延创造条 件的重要性。请你们对SARS 的传播建立数学模型， 具体要求如下：</p><ol><li>对附件1所提供的一个早期的模型，评价其合理性和实用性</li><li>建立你们自己的模型，说明为什么优于附件1中 的模型；特别要说明怎样才能建立一个真正能够预测 以及能为预防和控制提供可靠、足够的信息的模型， 这样做的困难在哪里？对于卫生部门所采取的措施做 出评论，如：提前或延后5天采取严格的隔离措施， 对疫情传播所造成的影响做出估计。附件2提供的数据供参考。</li><li>收集SARS对经济某个方面影响的数据，建立相应的数学模型并进行预测。附件3提供的数据供参考</li></ol><p><strong>问题二：长江水质的评价和预测</strong></p><p>水是人类赖以生存的资源，保护水资源就是保护我们自己，对 于我国大江大河水资源的保护和治理应是重中之重。专家们呼吁 ：“以人为本，建设文明和谐社会，改善人与自然的环境，减少 污染。” 长江是我国第一、世界第三大河流，长江水质的污染程度日趋 严重，已引起了相关政府部门和专家们的高度重视。2004年10月 ，由全国政协与中国发展研究院联合组成“保护长江万里行”考 察团，从长江上游宜宾到下游上海，对沿线21个重点城市做了实 地考察，揭示了一幅长江污染的真实画面，其污染程度让人触目 惊心。为此，专家们提出“若不及时拯救，长江生态10年内将濒 临崩溃”（附件１），并发出了“拿什么拯救癌变长江”的呼唤 （附件2）。</p><p>附件3给出了长江沿线17个观测站（地区）近两年多主要水质指标 的检测数据，以及干流上７个观测站近一年多的基本数据（站点距离 、水流量和水流速）。通常认为一个观测站（地区）的水质污染主要 来自于本地区的排污和上游的污水。 一般说来，江河自身对污染物都有一定的自然净化能力，即污染 物在水环境中通过物理降解、化学降解和生物降解等使水中污染物的 浓度降低。反映江河自然净化能力的指标称为降解系数。 事实上，长江干流的自然净化能力可以认为是近似均匀的，根据 检测可知，主要污染物高锰酸盐指数和氨氮的降解系数通常介于 0 . 1 ~ 0 . 5之间，比如可以考虑取0 . 2　(单位：1 /天)。附件4是 “1995~2004年长江流域水质报告”给出的主要统计数据。下面的附 表是国标(GB3838-2002) 给出的《地表水环境质量标准》中4个主要项 目标准限值，其中Ⅰ、Ⅱ、Ⅲ类为可饮用水</p><p>请你们研究下列问题：</p><ol><li>对长江近两年多的水质情况做出定量的综合评价，并分析各地区水质的污染状况。</li><li>研究、分析长江干流近一年多主要污染物高锰酸盐指数和氨氮的污染源主要在哪些地区?</li><li>假如不采取更有效的治理措施，依照过去10年的主要统计数据， 对长江未来水质污染的发展趋势做出预测分析，比如研究未来10年的 情况</li><li>根据你的预测分析，如果未来10年内每年都要求长江干流的Ⅳ类 和Ⅴ类水的比例控制在20%以内，且没有劣Ⅴ类水,那么每年需要处理 多少污水？</li><li>你对解决长江水质污染问题有什么切实可行的建议和意见</li></ol></blockquote><p>可以看出来，对于SARS问题，第二、三问都涉及了预测，因此可以用灰色模型求解。而对于长江水质，三、四问同样是需要进行预测的。</p><p>此外，数学建模中常用的预测方法用：</p><ul><li>微分方程模型</li><li>灰色预测模型</li><li>差分方程模型</li><li>马尔可夫预测</li><li>时间序列</li><li>差值拟合</li><li>神经网络</li></ul><p>不同的预测问题适合不同的预测方法，本文就将讲解其中的灰色关联分析以及灰色预测模型 。</p><h2 id="1-灰色系统理论的介绍"><a href="#1-灰色系统理论的介绍" class="headerlink" title="1. 灰色系统理论的介绍"></a>1. 灰色系统理论的介绍</h2><p>灰色系统理论由华中科技大学控制科学与工程系教授，博士生导师邓聚龙于1982年提出的。它是用来解决信息不完备系统的数学方法，它把控制论的观点和方法延伸到复杂的大系统中，将自动控制与运筹学的数学方法相结合，用独树一帜的方法和手段，研究了广泛存在于客观世界中具有灰色性的问题。在短短的时间里，灰色系统理论有了飞速的发展，它的应用已渗透到自然科学和社会经济等许多领域，显示出这门学科的强大生命力，具有广阔的发展前景。</p><p><strong>系统分析的经典方法是将系统的行为看做是随机变化的过程，用概率统计方法，从大量历史数据中寻找统计规律，这对于统计数据量较大情况下的处理较为有效，但对于数据量少的贫信息系统的分析则较为棘手。</strong></p><p><strong>灰色系统理论研究的是贫信息建模，它提供了贫信息情况下解决系统问题的新途径</strong>。<strong>它把一切随机过程看做是在一定范围内变化的、与时间有关的灰色过程，对灰色量不是从寻找统计规律的角度，通过大样本进行研究，而是用数据生成的方法，将杂乱无章的原始数据整理成规律性较强的生成数列后再作研究</strong>。灰色理论认为系统的行为现象尽管是朦胧的，数据是杂乱无章的，但它毕竟是有序的，有整体功能的，在杂乱无章的数据后面，必然潜藏着某种规律，灰数的生成是从杂乱无章的原始数据中去开拓、发现、寻找这种内在规律。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106152800248.png" alt="维基百科上的介绍"></p><p>1989海洋出版社出版英文版《灰色系统论文集》，同年， 英文版国际刊物《灰色系统》杂志正式创刊。目前，国际、 国内200多种期刊发表灰色系统论文，许多国际会议把灰 色系统列为讨论专题。国际著名检索网站已检索我国学者 的灰色系统论著500多次。灰色系统理论应用范围已拓展 到工业、农业、社会、经济、能源、地质、石油等众多科 学领域，成功地解决了生产、生活和科学研究中的大量实 际问题，取得了显著成果。</p><p>灰色系统的应用范畴大致分为以下几方面：</p><ul><li>灰色关联分析</li><li>灰色预测（人口预测；灾变预测….等等）</li><li>灰色决策</li><li>灰色预测控制</li></ul><h2 id="2-灰色理论的基本概念"><a href="#2-灰色理论的基本概念" class="headerlink" title="2. 灰色理论的基本概念"></a>2. 灰色理论的基本概念</h2><h3 id="1-白色、黑色和灰色系统"><a href="#1-白色、黑色和灰色系统" class="headerlink" title="1. 白色、黑色和灰色系统"></a>1. 白色、黑色和灰色系统</h3><ul><li><strong>白色系统</strong>：白色系统是指一个系统的内部特征是完全已知的，即系统的信息是完全充分的。以一个函数为例，我们完全知道这个函数的解析式，因此我们完全知道函数（系统）内部的特征，并且能够给定一个输入，预测其输出。</li><li><strong>黑色系统</strong>：黑色系统是指一个系统的内部信息对外界来说是一无所知的，只能通过它与外界的联系来加以观测研究。同样，以函数为例，黑色系统即我们完全不知道解析式的函数，我们完全不知道这个函数（系统）的内部特征，只能通过<strong>大量的数据</strong>，利用插值等方法获得近似的函数解析式（利用统计获得系统的信息），然后给定新的输入，给出的预测不一定对。</li><li><strong>灰色系统</strong>：灰色系统内的一部分信息是已知的，另一部分信息是未知的，系统内各因素间有不确定的关系。同样，以函数为例，灰色系统是我们直到部分项的函数，即系统一部分信息是已知的，而另外一部分信息是未知的。</li></ul><h3 id="2-灰色预测法"><a href="#2-灰色预测法" class="headerlink" title="2. 灰色预测法"></a>2. 灰色预测法</h3><ul><li>灰色预测法是一种对含有不确定因素的系统，即灰色系统进行预测的方法</li><li>灰色预测是对既含有已知信息又含有不确定信息的系统进行预则，就是对在一定范围内变化的、与时间有关的灰色过程进行预测的过程</li></ul><p>大体上来说，灰色预测通过鉴别系统因素之间发展趋势的相异程度，即进行关联分析，并可对原始数据进行生成处 理来寻找系统变动的规律，生成有较强规律性的数 据序列,然后建立相应的微分方程模型，从而预测 事物未来发展趋势的状况</p><p>即灰色预测首先判断目标量和哪些量之间是有关系的。例如预测人口增长，那么受限通过灰色关联分析分析得到人口增长是和经济增长有关系、交通发达等等因素有关系。</p><p>接下来对原始数据进行生成处理，例如累加或者累减操作生成一个原始数据的序列。而后对该序列建立一个微分方程的模型，最后进行预测</p><p>注意，<strong>灰色预测法要求对预测对象的值的观测是等时距的</strong>。从而利用等时距观测到的反映预测对象特征的一系列数量值构造灰色预测模型，预测未来某一时刻的预测对象的特征量，或预测对象达到某一特征量的时间。</p><h3 id="3-灰色预测的四种常见类型"><a href="#3-灰色预测的四种常见类型" class="headerlink" title="3. 灰色预测的四种常见类型"></a>3. 灰色预测的四种常见类型</h3><h4 id="A-灰色时间序列预测"><a href="#A-灰色时间序列预测" class="headerlink" title="A. 灰色时间序列预测"></a>A. 灰色时间序列预测</h4><p>用观察到的反映预测对象特征的时间序 列来构造灰色预测模型，预测未来某一时刻 的特征量，或达到某一特征量的时间。比如股市分析</p><h4 id="B-畸变预测"><a href="#B-畸变预测" class="headerlink" title="B. 畸变预测"></a>B. 畸变预测</h4><p>通过灰色模型预测异常值出现的时刻， 预测异常值什么时候出现在特定时区内。例如地震预测、异常气候预测、设备异常分析</p><h4 id="C-系统预测"><a href="#C-系统预测" class="headerlink" title="C. 系统预测"></a>C. 系统预测</h4><p>通过对系统行为特征指标建立一组相互 关联的灰色预测模型，预测系统中众多 变量间的相互协调关系的变化。</p><h4 id="D-拓扑预测"><a href="#D-拓扑预测" class="headerlink" title="D. 拓扑预测"></a>D. 拓扑预测</h4><p>将原始数据做曲线，在曲线上按定值寻 找该定值发生的所有时点，并以该定值 为框架构成时点数列，然后建立模型预 测该定值所发生的时点。例如对寻找系统中某个变量等于定值时候的时间点。例如温度控制，温度为27度的时候要升温到30度。那么找到所有温度为27度的时间即拓扑预测。</p><h3 id="4-灰色关联度"><a href="#4-灰色关联度" class="headerlink" title="4. 灰色关联度"></a>4. 灰色关联度</h3><p>大千世界里的客观事物往往现象复杂，因素繁多。我们经常要对系统进行因素分析，这些<strong>因素中哪些对系统来讲是主要的，哪些是次要的，哪些需要发展，哪些需要抑制，哪些是潜在的，哪些是明显的？一般来讲，这些都是我们极为关心的问题</strong>。事实上，<strong>因素间关联性如何、关联程度如何量化等问题是系统分析的关键</strong>。</p><ul><li><strong>例如人口问题</strong>。人和社会在一起构成一个系统，影响人口发展变化的因素有社会方面的诸如计划生育、社会治安、社会生活方式等；有经济方面的诸如国民收入、社会福利、社会保险等；还有医疗方面的诸如医疗条件、医疗水平等.……也就是说，人口是多种因素互相关联、互相制约的系统，对这些因素进行分析将有有助于人们对人口的未来预测及人口控制工作。</li></ul><p>灰色关联度就是衡量因素间的关联性，对关联性进行量化的指标。</p><p><strong>因素分析的基本方法过去主要是采用回归分析（即在大量的数据的基础上，通过回归等手段获得因变量和自变量的解析式的这类方法）等办法</strong>，但回归分析的办法有很多欠缺，如要求大量数据、计算量大以及可能出现反常情况等。为克服以上弊病，就产生了灰色关联度分析</p><p><strong>灰色关联度是分析向量与向量之间以及矩阵与矩阵之间的关联度</strong>。既然计算关联度，一定是计算某一个待比较的数列与参照物（参考数列）之间的相关程度。</p><h2 id="3-灰色关系分析"><a href="#3-灰色关系分析" class="headerlink" title="3. 灰色关系分析"></a>3. 灰色关系分析</h2><h3 id="A-灰色关联度的计算"><a href="#A-灰色关联度的计算" class="headerlink" title="A. 灰色关联度的计算"></a>A. 灰色关联度的计算</h3><p>灰色关联其实计算的是对比数列和参考数列之间的相似程序/离散程度</p><ol><li><p>选取参考数列</p><script type="math/tex; mode=display">X_0=\{X_0(k)|k=1,2,\cdots,n\}=(X_0(1), X_0(2),\cdots, X_0(n))</script><p>上式中，$k$表示时刻</p></li><li><p>假设存在$m$个比较数列</p><script type="math/tex; mode=display">X_i=\{X_i(k)|k=1,\cdots,n\}=(X_i(1), X_i(2),\cdots, x_i(n)),\qquad i=1,2,\cdots,m</script><p>则称</p><script type="math/tex; mode=display">\zeta_i(k)=\frac{\min_{i}\min_k|X_0(k)-x_i(k)|+\rho\max_i\max_k|X_0(k)-X_i(k)|} {|X_0(k)-X_i(k)|+\rho \max_i\max_k|X_0(k)-X_i(k)|}</script><p>为比较数列$X_i$对参考数列$X_0$在$k$时刻的<strong>关联系数</strong>。其中$\rho\in[0,\infin)$为<strong>分辨系数</strong>，一般而言，$\rho\in[0,1]$。$\rho$越大，分辨率越大；$\rho$越小，分辨率越小，$\rho$一般取0.5。直观的理解即$m$个比较数列全局的最小差距和最大差距的和与当前数列的第$k$项和全局的最大和。描述了当前项的分散度。</p></li><li><p>关联系数描述了比较数列和参考数列在某一时刻上的关联度，而对于数列整体而言，定义</p><script type="math/tex; mode=display">r_i=\frac 1 n\sum_{k=1}^n\zeta_i(k)</script><p>为比较数列$X_i$相对于参考数列$X_0$的关联度。</p></li><li><p>此外，由于计算关联系数的时候取了绝对值，因此无法通过关联度判断是正相关还是负相关，为此，引入下面的式子进行判断</p><script type="math/tex; mode=display">\begin {aligned}\sigma_i &= \sum_{k=1}^nkX_i(k)-\sum_{k=1}^nX_i(k)\sum_{k=1}^n\frac{k}{n}\\\sigma_n &= \sum_{k=1}^nk^2-(\sum_{k=1}^nk)2/n\end {aligned}</script><p>则有</p><script type="math/tex; mode=display">\begin{cases}sign(\frac{\sigma_i}{\sigma_n})=sign(\frac{\sigma_j}{\sigma_n}), & 则X_i和X_j正相关\\sign(\frac{\sigma_i}{\sigma_n})=-sign(\frac{\sigma_j}{\sigma_n}), & 则X_i和X_j负相关\\\end{cases}</script></li></ol><h3 id="B-灰色综合分析的案例"><a href="#B-灰色综合分析的案例" class="headerlink" title="B. 灰色综合分析的案例"></a>B. 灰色综合分析的案例</h3><blockquote><p>利用灰色关联分析对6位教师工作状况进行综合分析（即判断那个老师能力强，那个老师比较好）：</p><ol><li><p>分析指标包括：专业素质、外语水平、教学工作量、科研成果、 论文、著作与出勤</p></li><li><p>对原始数据经处理后得到以下数值</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106185111044.png" alt="指标表"></p></li></ol></blockquote><p>注意：</p><ol><li>在计算灰色关联度的时候，各个指标注意值域要相同 </li><li>这里由于是通过多个不同的指标来衡量老师，因此当然可以用层次分析法</li></ol><p>求解：</p><ol><li><p>计算$|x_0(k)-x_j(k)|$，如下表1</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106200138468.png" alt="表1"></p></li><li><p><strong>求最值</strong>：$\min=0，\max=7$</p></li><li><p>计算相关系数，如下表2</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106200238977.png" alt="表2"></p></li><li><p><strong>分别计算每个人各指标关联系数的均值（关联序）</strong>：如下表3</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106200315535.png" alt="表3"></p></li></ol><h3 id="C-灰色关联度计算代码"><a href="#C-灰色关联度计算代码" class="headerlink" title="C. 灰色关联度计算代码"></a>C. 灰色关联度计算代码</h3><p>Python实现的代码如下：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from typing import *from pathlib import Pathimport numpy as npfrom numpy.lib.function_base import iterableimport pandas as pdclass GrayRationalAnalysis(object):    def __init__(self, df: pd.DataFrame, reference_vector: Union[int, np.ndarray]) -> None:        super().__init__()        self.df = df        self.reference_vector = reference_vector        self.indices = df.columns    def run(self, rho=0.5):        refer_table = self.df.subtract(self.reference_vector, axis=1).abs()        min_value, max_value = refer_table.min().min(), refer_table.max().max()        correlation_table: pd.DataFrame = (min_value + rho * max_value) / (refer_table + rho * max_value)        print(correlation_table.sum(axis=1)/self.df.shape[1])    @staticmethod    def build_from_csv(csv_path: Union[str, Path], reference_vector: Union[int, np.ndarray]=9) -> 'GrayRationalAnalysis':        """        Notes:            build_from_csv用于从CSV文件中读取数据并构建灰色分析对象        """        csv_path = Path(csv_path) if isinstance(csv_path, str) else csv_path        df = pd.read_csv(csv_path, header=0, index_col=0)        if isinstance(reference_vector, int):            reference_vector: np.ndarray = np.full(df.shape[1], fill_value=reference_vector)        elif iterable(reference_vector):            reference_vector = np.array(reference_vector)            assert df.shape[1] == len(reference_vector), f"维度不匹配"        return GrayRationalAnalysis(df=df, reference_vector=reference_vector)if __name__ == "__main__":    gra = GrayRationalAnalysis.build_from_csv(Path(__file__).resolve().parent.joinpath("./test.csv"), reference_vector=[9,9,9,9,8,9,9]).run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-灰色生成数列"><a href="#4-灰色生成数列" class="headerlink" title="4. 灰色生成数列"></a>4. 灰色生成数列</h2><p>灰色系统理论认为，对于一个系统而言，尽管客观表象复杂，但总是有整体功能的，因此必然蕴含某种内在规律。关键在于如何选择适当的方式去挖掘和利用它。<strong>灰色系统是通过对原始数据的整理来寻求其变化规律的</strong>， 这是一种就数据寻求数据的现实规律的途径，即为灰色序列的生成。<strong>一切灰色序列都能通过某种生成弱化其随机性，显现其规律性</strong>。数据生成的常用方式：</p><ul><li>累加生成</li><li>累减生成</li><li>加权累加生成</li></ul><p>生成数列的目的在于原始的描述观测的特征量的值的数列具有一定的随机性，而通过多种不同的方式对原始数据进行变换（生成新的数列）的方法就可以减弱其随机性，使得原始数列的特征更加易于发现。</p><h3 id="A-累加生成数列"><a href="#A-累加生成数列" class="headerlink" title="A. 累加生成数列"></a>A. 累加生成数列</h3><p><strong>把数列各项（时刻）数据依次累加的过程称为累加生成过程（AGO）</strong>。由累加生成过程所得的数列称为<strong>累加生成数列</strong>。</p><p>设原始数列为</p><script type="math/tex; mode=display">x^{(0)}=(x^{(0)}(1), x^{(0)}(2), \cdots, x^{(0)}(n)</script><p>令</p><script type="math/tex; mode=display">x^{(1)}(k)=\sum_{i=1}^kx^{(0)}(i), \qquad k=1,2,\cdots,n</script><p>则称数列</p><script type="math/tex; mode=display">x^{(1)}=(x^{(1)}(1), x^{(1)}(2), \cdots, x^{(1)}(n)</script><p>为数列$x^{(0)}$的<strong>一次累加生成数列</strong>。类似的，称</p><script type="math/tex; mode=display">x^{(r)}=(x^{(r)}(1), x^{(r)}(2), \cdots, x^{(r)}(n),其中 x^{(r)}(k)=\sum_{i=1}^kx^{(r-1)}(i), \quad k=1,2,\cdots,n</script><p>为$x^{(0)}$的<strong>r次累加生成数列</strong></p><p>一般经济数列都是非负数列。累加生成能使任 意非负数列、摆动的与非摆动的，转化为非减 的、递增的。例如下图：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106204501736.png" alt="累加生成数列" style="zoom: 67%;"></p><p>那么原始数列每一项所含的随机影响相对于全体来说就无法造成大的影响，此时找出累加生成数列的规律，而后反推回去得到原始数列的预测就有可能，例如下面的例子。</p><p>对于每一年的作物产量进行预测，则由于每年都有病虫害问题导致年产量的曲线难以拟合，而进行一次累加后得到累计年产量曲线则表明在总体上作物产量是以指数关系增长的。对于钢产量也是同理。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106204702753.png" alt="累加生成数列容易观察得到总体服从的规律" style="zoom:67%;"></p><h3 id="B-累减生成数列"><a href="#B-累减生成数列" class="headerlink" title="B. 累减生成数列"></a>B. 累减生成数列</h3><p><strong>对于原始数据列依次做前后相邻的两个数据相减的运算过程称为累减生成过程（IAGO）</strong></p><p>设原始数列为</p><script type="math/tex; mode=display">x^{(1)}=(x^{(1)}(1), x^{(1)}(2), \cdots, x^{(1)}(n)</script><p>令</p><script type="math/tex; mode=display">x^{(0)}(k)=x^{(1)}(k)-x^{(1)}(k-1), \qquad k=2,3,\cdots,n</script><p>则称数列</p><script type="math/tex; mode=display">x^{(0)}=(x^{(0)}(1), x^{(0)}(2), \cdots, x^{(0)}(n)</script><p>为数列$x^{(1)}$的<strong>一次减生成数列</strong>。</p><p>其实从符号上可以看出，累加是累减的逆操作。</p><p>对于累减生成数列而言，其具有求导的性质，例如下面的例子</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106205143207.png" alt="累减数列具有求导的性质" style="zoom:50%;"></p><h3 id="C-加权邻值生成数列"><a href="#C-加权邻值生成数列" class="headerlink" title="C. 加权邻值生成数列"></a>C. 加权邻值生成数列</h3><p>设原始数列为</p><script type="math/tex; mode=display">x^{(0)}=(x^{(0)}(1), x^{(0)}(2), \cdots, x^{(0)}(n)</script><p>称$(x^{(0)}(k-1),x^{(0)}(k-1))$为一对邻值，其中称$x^{(0)}(k-1)$为前邻值，称$x^{(0)}(k-1)$为后邻值。</p><p>对于任意常数$\alpha\in [0,1]$，取</p><script type="math/tex; mode=display">z^{(0)}(k)=\alpha x^{(0)}(k)+(1-\alpha)x^{(0)}(k-1),\qquad k=2,3,\cdots,n</script><p>则由此得到的数列</p><script type="math/tex; mode=display">z^{(0)}=(z^{(0)}(1), z^{(0)}(2), \cdots, z^{(0)}(n)</script><p>称为数列$x^{(0)}$在权$\alpha$下的<strong>邻值生成数列</strong>，权$\alpha$称为生成系数</p><p>若$\alpha=0.5$，则称数列为均值生成数列，也称为等权邻值生成数列</p><h2 id="5-灰色模型"><a href="#5-灰色模型" class="headerlink" title="5. 灰色模型"></a>5. 灰色模型</h2><h3 id="A-GM-1-1"><a href="#A-GM-1-1" class="headerlink" title="A. $GM(1,1)$"></a>A. $GM(1,1)$</h3><blockquote><p>灰色系统理论是基于关联空间、光滑离散函数等概念定义灰导数与灰微分方程，进而用离散数据列建立微分方程形式的动态模型，即灰色模型是利用离散随机数经过生成变为随机性被显著削弱而且较有规律的生成数，建立起的微分方程形式的模型，这样便于对其变化过程进行研究和描述。</p></blockquote><p>上面的这段话的关键点：</p><ul><li>灰色系统理论中定义了定义灰导数和灰微分方程，而灰色模型是基于这些基本概念定义的</li><li>灰色模型是一个<strong>微分方程模型</strong>，该微分方程模型是在随机性被削弱的生成数的基础上构建的</li></ul><p>设原始数列为</p><script type="math/tex; mode=display">x^{(0)}=(x^{(0)}(1), x^{(0)}(2), \cdots, x^{(0)}(n)</script><p>且其一次累加数列为</p><script type="math/tex; mode=display">x^{(1)}=(x^{(1)}(1), x^{(1)}(2), \cdots, x^{(1)}(n)</script><p>则，定义数列$x^{(1)}$的<strong>灰导数</strong>为</p><script type="math/tex; mode=display">d(k)=x^{(0)}(k)=x^{(1)}(k)-x^{(1)}(k-1)</script><p>设$z^{(1)}(k)$为数列$x^{(1)}$的邻值生成数列，即</p><script type="math/tex; mode=display">z^{(1)}(k)=\alpha x^{(1)}(k)+(1-\alpha)x^{(1)}(k-1)</script><p>则定义$GM(1,1)$的<strong>灰微分方程</strong>为</p><script type="math/tex; mode=display">d(k)+az^{(1)}(k)=b\\或\\x^{(0)}(k)+az^{(1)}(k)=b</script><p>上式中，$x^{(0)}(k)$是灰导数。而称$a$为<strong>发展系数</strong>，$z^{(1)}(k)$为<strong>白化背景值</strong>，b为<strong>灰作用量</strong>。</p><p>将时刻$k=2,3,\cdots,n$带入灰微分方程得</p><script type="math/tex; mode=display">\begin{cases}x^{(0)}(2)+az^{(1)}(2)=b\\x^{(0)}(3)+az^{(1)}(3)=b\\\cdots\\x^{(0)}(n)+az^{(1)}(n)=b\\\end{cases}</script><p>将上式向量化，则设</p><script type="math/tex; mode=display">\vec u = \begin{bmatrix}a\\b\end{bmatrix}</script><script type="math/tex; mode=display">\vec Y = \begin{bmatrix}x^{(0)}(2)\\x^{(0)}(3)\\\vdots\\x^{(0)}(n)\end{bmatrix}</script><script type="math/tex; mode=display">B = \begin{bmatrix}-z^{(1)}(2) & 1\\-z^{(1)}(3) & 1\\\vdots\\-z^{(1)}(n) & 1\end{bmatrix}</script><p>则$GM(1,1)$可以表示为</p><script type="math/tex; mode=display">\vec Y=B\vec u</script><p>由于$\vec Y$和$B$都可以根据输入获得，因此问题的关键在于求解$\vec u$</p><p>微分方程是线性微分方程，因此可以采用一元线性回归，即最小二乘法求估计值</p><script type="math/tex; mode=display">\vec u = \begin{bmatrix}a\\b \end{bmatrix}=(B^TB)^{-1}B^TY</script><h3 id="B-白化型-GM-1-1"><a href="#B-白化型-GM-1-1" class="headerlink" title="B. 白化型$GM(1,1)$"></a>B. 白化型$GM(1,1)$</h3><p>$GM(1,1)$是离散的方程，因为其中的导数和微分都是灰导数和灰积分。然而在有的时候，我们如果数列中的每一项之间都是沿着时间收集的，即数列中的每一项都是和时间有关的。那么我们就希望能够用含有时间$t$的微分方程来描述。因此，含有时间$t$的灰色方程即白化型$GM(1,1)$</p><p>对于$GM(1,1)$中的灰微分方程</p><script type="math/tex; mode=display">x^{(0)}(k)+az^{(1)}(k)=b</script><p>若将灰导数$x^{(0)}(k)$的每一项$k$（$k=2,3,\cdots,n$）视为连续的变量$t$，即将项的次序视为时间。则$x^{(1)}$是时间$t$的函数，即$x^{(1)}=x^{(1)}(t)$。则$x^{(0)}(k)$就对应导数，即</p><script type="math/tex; mode=display">x^{(0)}(k)=x^{(0)}(t)=\frac{dx^{(1)}(t)}{dt}</script><p>而白化背景就相当于$\alpha x^{(1)}(t)$，故若将$GM(1,1)$视为连续的项，则有</p><script type="math/tex; mode=display">\frac{dx^{(1)}(t)}{dt}+\alpha x^{(1)}(t)=b</script><p>上式两边对$t$同时积分，有：</p><script type="math/tex; mode=display">\int_{k-1}^k(\frac{dx^{(1)}(t)}{dt})dt+\int_{k-1}^k ax^{(1)}(t)dt = \int_{k-1}^k bdt</script><p>左边第一项为$\frac{dx^{(1)}(t)}{dt}$的原函数的第$k$项减第$k-1$的值，即</p><script type="math/tex; mode=display">x^{(1)}{(k)}-x^{(1)}(k-1)=x^{(0)}(k)</script><p>而第二项要求$x^{(1)}(t)$的原函数，则</p><script type="math/tex; mode=display">\int_{k-1}^k ax^{(1)}dt\approx az^{(1)}</script><h2 id="6-GM-1-1-的建模步骤"><a href="#6-GM-1-1-的建模步骤" class="headerlink" title="6. $GM(1,1)$的建模步骤"></a>6. $GM(1,1)$的建模步骤</h2><p>设原始数列为</p><script type="math/tex; mode=display">x^{(0)}=(x^{(0)}(1), x^{(0)}(2), \cdots, x^{(0)}(n)</script><ol><li><p><strong>数据的检验与处理</strong>： 为了保证$GM(1,1)$建模方法的可行性，需要对原始数列做必要的检验处理。</p><ol><li><p><strong>计算原始数列的级比</strong>：</p><script type="math/tex; mode=display">\lambda(k)=\frac{x^{(0)}(k-1)}{x^{(0)}(k)},\qquad k=2,2,\cdots,n</script></li><li><p>若所有级比都落在区间</p><script type="math/tex; mode=display">X=(e^{-\frac{2}{n+1}}, e^{\frac{2}{n+1}})</script><p>内，则可以直接对原始数列$x^{(0)}$建立$GM(1,1)$模型并进行灰色预测，否则由于不满足灰色模型的理论，因此不能直接用灰色灰色模型</p></li><li><p>否则需要对原始数列做适当的变换处理，例如平移（加常数）</p></li></ol></li><li><p><strong>建立$GM(1,1)$模型</strong>：</p><ol><li><p>假设通过第一步，得到了满足要求的数列$x^{(0)}$</p></li><li><p>则建立白化模型</p><script type="math/tex; mode=display">x^{(0)}(k)+az^{(1)}(k)=b</script><p>通过线性回归求得$a$和$b$的值，从而得到模型</p><script type="math/tex; mode=display">x^{(1)}(t)=(x^{(0)}(1)-\frac b a)e^{-a(t-1)}+\frac b a</script></li><li><p>从而得到预测值</p><script type="math/tex; mode=display">x^{(1)}(k+1)=(x^{(0)}(1)-\frac b a)e^{-ak}+\frac b a,\qquad k=1,2,\cdots,n-1</script></li><li><p>最终得到预测值</p><script type="math/tex; mode=display">x^{(0)}(k+1)=x^{(1)}(k+1)-x^{(1)}(k),\qquad k=1,2,\cdots,n-1</script></li></ol></li><li><p><strong>检验预测值</strong>：为了检测$GM(1,1)$的预测是否正确，还需要对预测进行检测</p><ol><li><p><strong>残差检验</strong>：计算相对残差，即原值减去预测值比上原值</p><script type="math/tex; mode=display">\varepsilon(k)=\frac{x^{(0)}(k)-\hat {x}^{(0)}(k)}{x^{(0)}(k)},\qquad k=1,2,\cdots,n</script><p>若对于所有的$|\varepsilon(k)|&lt;0.1$，则可以认为模型的预测达到较高的精度；否则，若对于所有的$|\varepsilon(k)|&lt;0.2$，则认为模型的预测达到一般精度</p></li><li><p><strong>级比检验</strong>：计算</p><script type="math/tex; mode=display">\rho(k)=1-\frac{1-0.5a}{1+0.5a}\lambda(k)</script><p>若对于所有的$|\rho(k)|&lt;0.1$，则认为模型的预测达到了较高的精度；否则，若对于所有的$|\rho(k)|&lt;0.2$，则认为模型达到了一般的要求</p></li></ol></li></ol><h2 id="7-灰色预测Python求解"><a href="#7-灰色预测Python求解" class="headerlink" title="7. 灰色预测Python求解"></a>7. 灰色预测Python求解</h2><p>基于Numpy和Pandas实现的灰色预测模型代码如下</p><h3 id="A-代码"><a href="#A-代码" class="headerlink" title="A. 代码"></a>A. 代码</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">from pathlib import Pathimport refrom typing import Unionimport numpy as npimport pandas as pdimport scipy.stats as scistclass GrayForcast(object):    def __init__(self, series: Union[pd.DataFrame, pd.Series]) -> None:        super().__init__()        self.index: pd.Index = series.index        self.x0 = series.to_numpy()    def train(self, verbose: bool = True):        # 计算级比        right_moved: np.ndarray = np.array([0, *(self.x0[:-1])])        self.lambdas: np.ndarray = right_moved / self.x0        # 级比检验        n = len(self.x0)        assert (l:=(np.exp(-2/n) < self.lambdas[1:]) & (self.lambdas[1:] < np.exp(2/n))).all(), f"级比检验未通过:{l}, 其中第{list(np.where(l==False)[0])}位:{self.x0[1:][~l]} 出错，数据不适合直接进行灰色预测"        if verbose:            print("级比检验通过")        # GM(1,1)建模        # 一次累加        self.x1 = np.cumsum(self.x0)        # 构建B和Y矩阵        Y = self.x0[1:].reshape(-1, 1)        right_moved = np.array([*(self.x1[:-1])])        left_moved = np.array([*(self.x1[1:])])        B = np.vstack(tup=(-1 * (left_moved + right_moved) / 2, np.ones_like(right_moved))).T        # 线性回归        self.u = np.linalg.inv(B.T @ B) @ B.T @ Y        # 模型检验        x0_pred = self.predict(items=7)        # 残差检验        relative_residual = np.abs((self.x0 - x0_pred) / self.x0)        if (l:= (relative_residual < 0.1)).all():            print("残差检验通过，所有残差小于0.1，达到高精度")        else:            if (l:= (relative_residual < 0.2)).all():                print("残差检验通过，所有残差小于0.2，达到一般精度要求")            else:                assert False, f"残差检验未通过，第{np.where(l==False)[0]}位:{relative_residual[~l]}大于0.2"        # 级比检验        rho = 1- (1 - self.u[0, 0] * 0.5) / (1 + self.u[0, 0] * 0.5) * self.lambdas        if (l:= (rho[1:] < 0.1)).all():            print("级比检验通过，所有级比小于0.1，达到高精度")        else:            if (l:= (rho[1:] < 0.2)).all():                print("级比检验通过，所有级比小于0.2，达到一般精度要求")            else:                assert False, f"级比检验未通过，第{np.where(l==False)[0]}位:{rho[1:][~l]}大于0.2"        rho[0] = np.nan        if verbose:            df = np.vstack(tup=(self.x0, x0_pred, self.x0-x0_pred, relative_residual*100, rho))            df = pd.DataFrame(df.T, index=self.index, columns=["原始值","预测值","残差","相对残差(%)","级比偏差"])            print(df)    def predict(self, items: int) -> np.ndarray:        a, b = self.u[0, 0], self.u[1,0]        def x1_kp1(k: int):            if k == 0:                return self.x0[0]            else:                return (self.x0[0] - b/a) * np.exp(-a * k) + b/a        x1_pred = np.array([x1_kp1(i) for i in range(items)])        right_moved = np.array([0, *(x1_pred[:-1])])        x0_pred = x1_pred - right_moved        return x0_pred    @staticmethod    def preprocess_donothing(gf: "GrayForcast") -> "GrayForcast":        return gf    @staticmethod    def build_from_csv(csv_path: Union[str, Path], target_col: Union[None, int, str]=None) -> "GrayForcast":        csv_path = csv_path if isinstance(csv_path, Path) else Path(__file__).resolve().parent.joinpath(csv_path)        df : pd.DataFrame = pd.read_csv(csv_path, header=0, index_col=0)        assert (multiple:=df.shape[1] != 1) and target_col is not None, f"CSV文件存在多个序列：{df.columns}，请指定target_col参数指定需要预测的序列"        if multiple:            if isinstance(target_col, str):                target_col = df.T.loc[target_col]            elif isinstance(target_col, int):                target_col = df.iloc[:, target_col]        else:            target_col = df        return GrayForcast(series=target_col)    @staticmethod    def build_from_excel(csv_path: Union[str, Path], target_col: Union[None, int, str]=None) -> "GrayForcast":        csv_path = csv_path if isinstance(csv_path, Path) else Path(__file__).resolve().parent.joinpath(csv_path)        df : pd.DataFrame = pd.read_excel(csv_path, header=0, index_col=0)        assert (multiple:=df.shape[1] != 1) and target_col is None, f"xlsx文件存在多个序列：{df.columns}，请指定target_col参数指定需要预测的序列"        if multiple:            if isinstance(target_col, str):                target_col = df.loc[target_col]            elif isinstance(target_col, int):                target_col = df.iloc[:, target_col]        else:            target_col = df        return GrayForcast(series=target_col)if __name__ == "__main__":    gf = GrayForcast.build_from_csv(csv_path="./test2.csv", target_col="噪声")    gf.train()    print(gf.predict(10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="B-使用说明"><a href="#B-使用说明" class="headerlink" title="B. 使用说明"></a>B. 使用说明</h3><p>代码从指定的表格中读取数据，然后先训练得到参数，最后通过预测指定，需要预测的项数即可</p><p>表格要求如下：第一列为序号，其余列为对比数列，对比数列沿列展开，若表格有多列则需要指定计算的列的名称</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107143018846.png" alt="示例表格"></p><p>使用结果如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107143325969.png" alt="计算结果"></p><h2 id="8-灰色预测案例"><a href="#8-灰色预测案例" class="headerlink" title="8. 灰色预测案例"></a>8. 灰色预测案例</h2><p>灰色预测模型处理的问题基本都是预测模型</p><h3 id="A-投资理财问题"><a href="#A-投资理财问题" class="headerlink" title="A. 投资理财问题"></a>A. 投资理财问题</h3><blockquote><p>银行有各种投资理财产品，客户可根据自己的资金实力和 投资偏好来自由选择，并且一般会有“10天犹豫期”，在 这10天里如果对自己购得的理财产品不放心或者不满意通 常情况下是可以退买的，这时候是不收手续费的。否则逾 期退买将收取一定的手续费。 通过对客户退买行为数据的分析，发现客户购得理财产品 后的每一天继续持有的客户比例依次是[92.810 97.660 98.800 99.281 99.537 99.537 99.817 0.00](单位%)，从这组数列可以看出退买高发期是在前几天，后续退买的可能性持续衰减。建立$GM(1,1)$模型对以上数据进行分析。</p></blockquote><h3 id="B-道路噪声平均值"><a href="#B-道路噪声平均值" class="headerlink" title="B. 道路噪声平均值"></a>B. 道路噪声平均值</h3><blockquote><p>北方某城市1986～1992 年道路交通噪声平均声级数据见表6，单位为db(A)</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106225804772.png" alt="表6" style="zoom:50%;"></p></blockquote><p>利用上面的代码，准备好表格数据，然后开始预测</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107143325969.png" alt="道路噪声平均值"></p><h3 id="C-公司利润预测"><a href="#C-公司利润预测" class="headerlink" title="C. 公司利润预测"></a>C. 公司利润预测</h3><blockquote><p>已知某公司1999-2008年的利润为(单位：元/年)： [89677,99215,109655,120333,135823,159878,182321,209407, 246619,300670],现在要预测该公司未来几年的利润情况。</p></blockquote><p>把上面的数据制作成下面的表格</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107144656000.png" alt="公司利润表" style="zoom:50%;"></p><p>得到未来五年利润的预测如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107144924383.png" alt="未来五年的利润预测"></p><h3 id="D-SARS病毒影响"><a href="#D-SARS病毒影响" class="headerlink" title="D. SARS病毒影响"></a>D. SARS病毒影响</h3><blockquote><p>2003年的SARS疫情对中国部分行业的经济发展产生了一 定的影响，特别是对帮分疫情较严重的省市的相关行业所造成的影响是明显的，经济影响主要分为直接经济影响和 间接影响。直接经济影响涉及到商品零售业、旅游业、综合服务等行业。很多方面难以进行定量地评估，现仅就 SARS疫情较重的某市商品零售业、旅游业和综合服务业的影响进行定量的评估分析。</p><p>究竟SARS疫情对商品零售业、旅游业和综合服务业的影 响有多大，已知该市从1997年1月到2003年10月的商品零 售额、接待旅游人数和综合服务收入的统计数据如下表1 、表2、表3．</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107150033656.png" alt="表1，单位：亿元" style="zoom:67%;"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107150057008.png" alt="表2，单位：亿元" style="zoom: 67%;"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220107150130466.png" alt="表三，单位：亿元" style="zoom:67%;"></p><p>试根据这些历史数据建立预测评估模型，评估2003年SARS疫 情给该市的商品零售业、旅游业和综合服务业所造成的影响。</p></blockquote><p>对SARS病毒影响的评估，那么可以用没有疫情和有疫情的对比实现。例如要探究SARS对零售业的影响，那么其实可以首先预测出来没有SARS零售业本来的指标，然后和有SARS的指标进行对比，从而给出对SARS病毒的影响。</p><p>因此思路如下：</p><p>根据所掌握的历史统计数据可以看出，在正常情况下，全 年的平均值较好地反映了相关指标的变化规律，这样可以 把预测评估分成两部分：</p><ol><li>利用灰色理论建立灰微分方程模型，由1997~2002年的 平均值预测2003年平均值</li><li>通过历史数据计算每个月的指标值与全年总值的关系 ，从而可预测出正常情况下2003年每个月的指标值，再与 实际值比较可以估算出SARS疫情实际造成的影响</li></ol><p>具体求解略</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 灰色关联分析 </tag>
            
            <tag> 灰色预测 </tag>
            
            <tag> 灰色模型 </tag>
            
            <tag> Grey relational analysis </tag>
            
            <tag> Grey Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法5-层次分析法</title>
      <link href="/2022/01/04/shu-xue-jian-mo-suan-fa-5-ceng-ci-fen-xi-fa/"/>
      <url>/2022/01/04/shu-xue-jian-mo-suan-fa-5-ceng-ci-fen-xi-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍了数学建模中常见的分析方法：层次分析法</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/v2-986c79a5dfbf54baa7dbe8c29d5f6734_1440w.jpg" alt="层次分析法"></p><h1 id="数学建模算法5-层次分析法"><a href="#数学建模算法5-层次分析法" class="headerlink" title="数学建模算法5-层次分析法"></a>数学建模算法5-层次分析法</h1><p>层次分析法是数学建模中非常常用的算法之一，通过层次分析法，我们能够完成对一个复杂的问题的定性与定量分析，并且在分析的同时做出决策。</p><h2 id="1-层次分析法介绍"><a href="#1-层次分析法介绍" class="headerlink" title="1. 层次分析法介绍"></a>1. 层次分析法介绍</h2><p><strong>层次分析法（Analytic Hierarchy Process，AHP）</strong>是美国运筹学家匹茨堡大学教授萨蒂（T.L.Santy）于上世纪70年代初，为美国国防部研究《根据各个工业部门对国家福利的贡献大小而进行电力分配》课题时，应用网络系统理论和多目标综合评价方法，提出的一种层次权重决策分析方法。</p><p>这种方法的特点是在对复杂的决策问题的本质、影响因素及其内在关系等进行深入分析的基础上，<strong>利用较少的定量信息使决策的思维过程数学化</strong>，从而为多目标、多准则或无结构特性的复杂决策问题提供简便的决策方法。是对难于完全定量的复杂系统作出决策的模型和方法。</p><p>简单的说，其优点在于：</p><ul><li>可以使用少量的信息（数据）来指导进行决策，相比于以往的其他模型，他们都是完全的定量化的，因此需要大量的数据。</li><li>层次分析法非常善于对不易于定量的问题进行分析。</li></ul><p>人们在对社会、经济以及管理领域的问题进行系统分析时，面临 的经常是一个由相互关联、相互制约的众多因素构成的复杂系统。 层次分析法则为研究这类复杂的系统，提供了一种新的、简洁的、 实用的决策方法。</p><p>层次分析法是一种解决多目标的复杂问题的定性与定量相结合的决策分析方法。</p><p><strong>该方法将定量分析与定性分析结合起来， 用决策者的经验判断各衡量目标能否实现的标准之间的相对重要程度，并合理地给出每个决策方案的每个标准的权数，利用权数求出各方案的优劣次序，从而比较有效地应用于那些难以用定量方法解决的课题。</strong></p><p>层次分析法是社会、经济系统决策中的有效工具。其特征是合理地将定性与定量的决策结合起来，按照思维、心理的规律把<strong>决策过程层次化、数量化</strong>。是系统科学中常用的一种系统分析 方法。</p><p>该方法自1982年被介绍到我国以来，以其定性与定量相结合地 处理各种决策因素的特点，以及其系统灵活简洁的优点，迅速地在我国社会经济各个领域内，如工程计划、资源分配、方案 排序、政策制定、冲突问题、性能评价、能源系统分析、城市 规划、经济管理、科研评价等，得到了广泛的重视和应用。</p><p>层次分析法的三大运用：</p><ul><li>用于最佳方案的选取（选择运动员、选择地址）<ul><li>例如四个远动员A、B、C、D，我们分别从耐力、爆发、敏捷几个因素去评价运动员的好坏</li><li>例如医院选址，那么对多个不同的地点，可以从低价、人口密度等因素评价医院选址的好坏</li></ul></li><li>用于评价类问题（评价水质状况、评价环境）<ul><li>同上</li></ul></li><li>用于指标体系的优选（兼顾科学和效率）<ul><li>例如现在有9个指标，要从中选取出来6个指标，那么对指标剔除评价标准，例如科学性和效率性</li></ul></li></ul><h2 id="2-层次分析法的基本原理"><a href="#2-层次分析法的基本原理" class="headerlink" title="2. 层次分析法的基本原理"></a>2. 层次分析法的基本原理</h2><h3 id="A-决策"><a href="#A-决策" class="headerlink" title="A. 决策"></a>A. 决策</h3><p>决策是指在面临多种方案时需要<strong>依据一定的标准选择某一种方案</strong>。 日常生活中有许多决策问题。例如：</p><ul><li>在海尔、新飞、容声和雪花四个牌号的电冰箱中选购一 种。要考虑品牌的信誉、冰箱的功能、价格和耗电量。</li><li>在泰山、杭州和承德三处选择一个旅游点。要考虑景点 的景色、居住的环境、饮食的特色、交通便利和旅游的费用。</li><li>在基础研究、应用研究和数学教育中选择一个领域申报 科研课题。要考虑成果的贡献（实用价值、科学意义），可行性 （难度、周期和经费）和人才培养</li><li>在小丽、小美、小静中选择一个适合自己的女朋友。要 考虑基本颜值，身材比例、教育程度、家境情况、地域关系等</li></ul><h3 id="B-基本原理"><a href="#B-基本原理" class="headerlink" title="B. 基本原理"></a>B. 基本原理</h3><p>层次分析法根据问题的性质和要达到的总目标，将<strong>问题分解为不同的组成因素</strong>，并<strong>按照因素间的相互关联影响以及隶属关系将因素按不同层次聚集组合，形成一个多层次的分析结构模型</strong>，从而最终<strong>使问题归结为最低层(供决策的方案、措施等)相对于最高层(总目标)的相对重要权值的确定或相对优劣次序的排序</strong>。</p><h2 id="3-层析分析法的步骤和方法"><a href="#3-层析分析法的步骤和方法" class="headerlink" title="3. 层析分析法的步骤和方法"></a>3. 层析分析法的步骤和方法</h2><p> 运用层次分析法构造系统模型时，大体可以分为以下四个步骤：</p><ol><li>建立层次结构模型</li><li>构造判断(成对比较)矩阵</li><li>层次单排序及其一致性检验</li><li>层次总排序及其一致性检验</li></ol><h3 id="A-建立层次结构模型"><a href="#A-建立层次结构模型" class="headerlink" title="A. 建立层次结构模型"></a>A. 建立层次结构模型</h3><p>在这一层，我们将决策的目标、考虑的因素（决策准则）和决策对象按它们之间的相互关系分为最高层、中间层和最低层，绘出层次 结构图。一般来说，三层分别是：</p><ul><li><strong>最高层</strong>：决策的目的、要解决的问题。比如去旅游</li><li><strong>最低层</strong>：决策时的备选方案。比如去桂林还是去西安还是去浙江</li><li><strong>中间层</strong>：考虑的因素、决策的准则。预算、想去的景区等等</li></ul><p>此外，<strong>对于相邻的两层，称高层为目标层，低层为因素层</strong>。</p><p>举例来说，</p><ul><li><p><strong>大学毕业生就业选择问题</strong>：获得大学毕业学位的毕业生，在“双向选择”时，用人单位与毕业生都有各自的选择标准和要求。就毕业生来说选择单位的标准和要求是多方面的，例如：</p><ul><li>能发挥自己才干作出较好贡献（即工作岗位适合发挥自己的专长）</li><li>工作收入较好（待遇好）</li><li>生活环境好（大城市、气候等工作条件等）</li><li>单位名声好（声誉等）</li><li>工作环境好（人际关系和谐等）</li><li>发展晋升机会多（如新单位或前景好）等</li></ul><p>那么根据上面的指标，绘制得到的层次结构图为：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104233008393.png" alt="大学生毕业就业选择问题"></p></li><li><p><strong>选择旅游目的地</strong>：在3个目的地中按照景色、费用、居住条件等因素选择最终前往的城市</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104233208220.png" alt="旅游目的地选择问题"></p></li></ul><p>因此，第一步建立层次结构模型的整个思维过程的归纳如下：</p><ul><li>将决策问题分为3个或多个层次</li><li><strong>最高层</strong>：<strong>目标层</strong>，表示解决问题的目的，即层次分析要达到的总目标。通常只有一个总目标。</li><li><strong>中间层</strong>：<strong>准则层、指标层、……</strong>。表示采取某种措施、政策、方案等为了实现预定总目标所涉及的中间环节；根据指标的不同，可以是准则层、指标层、 策略层、约束层等。</li><li><p><strong>最低层</strong>：<strong>方案层</strong>。表示将选用的解决问题的各种措施、政策、方 案等。通常有几个方案可选。</p></li><li><p>每层有若干元素，层间元素的关系用相连直线表示。</p></li><li>层次分析法所要解决的问题是关于最低层对最高层的相对权重问题，按此相对权重可以对最低层中的各种方案、措施进行排序，从 而在不同的方案中作出选择或形成选择方案的原则。即我们首先给目标层和准则层之间有一个权重向量，然后方案层中的每一个方案都有一个准则层对应的得分向量。两个向量相乘得到得分，那么我们就可以根据得分进行排序，获得初步的方案</li></ul><h3 id="B-构造判断-成对比较-矩阵"><a href="#B-构造判断-成对比较-矩阵" class="headerlink" title="B. 构造判断(成对比较)矩阵"></a>B. 构造判断(成对比较)矩阵</h3><p>在确定各层次各因素之间的权重时，如果只是定性的结果，则 常常不容易被别人接受，因而Santy等人提出：一致矩阵法，即:</p><ol><li>不把所有因素放在一起比较，而是两两相互比较。即所有中间层的准则/因素间进行两两比较</li><li>对此时采用相对尺度，以尽可能减少性质不同的诸因素相互比较的困难，以提高准确度。即使用谁更重要，谁更不重要这样的判断，而非谁比谁好多少，谁比谁好几倍。例如身高的比较，用高一点，高很多这种，而非高1.7厘米</li></ol><p>判断矩阵是表示本层所有因素针对上一层某一个因素的相对重要性的比较。判断矩阵的元素$a_{ij}$用Santy的1—9标度方法给出。</p><p>注意，心理学家认为成对比较的因素不宜超过9个，即每层不要超过9个因素。</p><p>而具体的1-9的标度的具体的含义如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104234600062.png" alt="1-9标度的含义"></p><p>此外，指标1对于指标2的标度为5，那么指标2对指标1的标度为$\frac 1 5$。</p><p>例如对于旅游目的地选取问题，我们根据前一步的得到的准则层，对其中的准则之间进行两两比较，得到下面的判断矩阵</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104234906589.png" alt="判断矩阵"></p><p>但其实此时得到的判断矩阵是有问题，例如有$\frac {C_1}{C_2}=\frac 1 2$，而$\frac{C_2}{C_3}=7$，那么$\frac{C_1}{C_3}=\frac 7 2$，但是上述我们给出的$\frac {C_1}{C_3}$却是4，因此是存在不一致问题。</p><p>因此，在判断矩阵中，<strong>允许不一致，但要确定不一致的允许范围</strong></p><p>若矩阵中任意三个相关联的数字是一致的，即$a_{ik}\cdot a_{kj}=a_{ij}$，那么此时<strong>称对比矩阵为一致阵，反之为不一致阵</strong>。</p><p>一致阵的性质有：</p><ul><li>A的秩为1，A的唯一非零特征根为n，即矩阵的行/列数。（$A\vec w=n\vec w$）</li><li>非零特征根n所对应的特征向量归一化后可作为权向量</li></ul><p>而对于不一致(但在允许范围内)的成对比较阵A， Santy等人建议用对应于最大特征根的特征向量作为权向量</p><p>而允许范围的判断及界定则由第三步完成</p><h3 id="C-层次单排序以及其一致性检验"><a href="#C-层次单排序以及其一致性检验" class="headerlink" title="C. 层次单排序以及其一致性检验"></a>C. 层次单排序以及其一致性检验</h3><blockquote><p>注意，如果是一致阵的话，权重向量已经获得，而第三步都是针对不一致阵的。</p></blockquote><h4 id="1-层次单排序"><a href="#1-层次单排序" class="headerlink" title="1) 层次单排序"></a>1) 层次单排序</h4><p>所谓层次单排序，即指对特征根最大的特征向量中的分量进行归一化操作之后，让各元素的值的和为1的过程。而归一化之后的向量记为$W$。</p><p>因为$W$的元素为同一层次因素对于上一层次因素相对重要性的排序权值，这一过程称为层次单排序。</p><h4 id="2-一致性检验"><a href="#2-一致性检验" class="headerlink" title="2) 一致性检验"></a>2) 一致性检验</h4><p>然而我们在这里其实还并不知道我们的不一致阵的不一致程度是否在允许范围内，因此需要对这里层次单排序之后的权向量进行一致性检验。即衡量一个不一致阵的不一致性，然后根绝量化后的不一致性进行判断。衡量不一致性，其实可以用不一致阵和一致阵的偏差来进行描述，因此要借助下面的两个定理：</p><ol><li><strong>定理一：$n$阶一致阵的唯一非零特征根为$n$</strong></li><li><strong>定理二：$n$阶正互反阵$A$的最大特征根$\lambda\ge n$, 当且仅当$\lambda=n$时，A为一致阵</strong></li></ol><p>因此就可以通过衡量$\lambda$与$n$的关系来描述$A$的不一致性。即由于$\lambda$连续的依赖于$a_{ij}$，则$\lambda$比$n$ 越大，$A$的不一致性越严重。则此时用最大特征值对应的特征向量作为被比较因素对上层某因素影响程度的权向量，其不一致程度越大，引起的判断误差越大。 因而可以用$\lambda-n$数值的大小来衡量$A$的不一致程度。</p><p>因此，定义<strong>不一致性指标$CI$</strong>：</p><script type="math/tex; mode=display">CI=\frac {\lambda-n} {n-1}</script><p>因此，有</p><ul><li>$CI$等于0，有完全的一致性</li><li>$CI$接近于0，有满意的一致性</li><li>$CI$越大，不一致越严重</li></ul><p>因此衡量一个不一致阵是否是可以接受的，关键就是看这个不一致阵的$CI$是否在某个范围内。因此关键就在于选取这个范围。又已知$CI=0$表示完全的一致性，因此其实只需要得到一个大于0的上界即可。</p><p>为了获得这个上界，那么可以通过和随机构造的随机矩阵的CI的值进行比较，来衡量我们给出的非一致判断阵和随机给出的判断阵之间的关系，从而衡量我们给出的判断阵是否合理，若合理即表示虽然不一致，但是在允许范围内。</p><p>因此，引入入<strong>随机一致性指标$RI$</strong>。$RI$的计算方法如下：</p><ul><li><p>随机构造500个的成对比较矩阵$A_1$，$A_2$，……，$A_{500}$</p></li><li><p>对每个大小的矩阵计算$CI$，得到$CI_i,i=1,\cdots,500$</p></li><li><p>得到$RI$，计算公式如下：</p><script type="math/tex; mode=display">RI=\frac{CI_1+CI_2+\cdots+CI_500}{500}=\frac{\frac {\lambda_1+\lambda_2+\cdots+\lambda_500}{500}-n}{n-1}</script></li></ul><p>对不同大小的判断镇分别计算RI，得到下表</p><div class="table-container"><table><thead><tr><th style="text-align:center">N</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th></tr></thead><tbody><tr><td style="text-align:center">RI</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0.58</td><td style="text-align:center">0.90</td><td style="text-align:center">1.12</td><td style="text-align:center">1.24</td><td style="text-align:center">1.32</td><td style="text-align:center">1.41</td><td style="text-align:center">1.45</td><td style="text-align:center">1.49</td><td style="text-align:center">1.51</td></tr></tbody></table></div><p>然后再定义<strong>一致性比率$CR$</strong>：</p><script type="math/tex; mode=display">CR=\frac {CI}{RI}</script><p>那么当$CR$小于0.1的时候，认为不一致阵A的不一致程度在允许范围内，有满意的一致性，通过了一致性检验，可以使用最大特征值对应的特征向量归一化之后的结果作为权向量。否则重新构造判断矩阵。</p><p>继续上面的旅游的例子，我们对其进行一致性检验。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220105004755325.png" alt="层次单排序及其一致性检验的例子"></p><p>因此，旅游问题中对我们给出的判断矩阵可以得到从我们的观点出发，每个因素的得分向量为：</p><script type="math/tex; mode=display">\vec w =[0.263, 0.475, 0.055, 0.090, 0.110]^T</script><p>因此，在我们看来，费用是我们在考虑目的地时候最重要的因素，接下来是景色，最后是旅途、饮食和居住</p><h3 id="D-层次总排序以及其一致性检验"><a href="#D-层次总排序以及其一致性检验" class="headerlink" title="D. 层次总排序以及其一致性检验"></a>D. 层次总排序以及其一致性检验</h3><h4 id="1-层次总排序"><a href="#1-层次总排序" class="headerlink" title="1) 层次总排序"></a>1) 层次总排序</h4><p>层次总排序指的是计算所有因素相对于总目标的相对重要性的权值的过程</p><p>这一过程从最高层到最底层依次进行。</p><p>例如前面的旅游目的地选取。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104233208220.png" alt="旅游目的地选择问题"></p><p>我们通过第三步已经有了准则层，即$C_1,C_2,C_3,C_4,C_5$之间的相对重要性。我们接下来是让方案层中的三个目的地对准则层中的每一个准侧进行比较。即在景色的角度来说，桂林比黄山、北戴河好到哪里去。此时又可以进行第二三步，即构造比较矩阵，进行层次单排序。</p><p>由于针对一个指标就可以获得一个层次单排序后的向量，例如对景色会得到一个景色单排序向量，因此最终会得到一个矩阵。</p><p>对于上面的旅游选择问题，最后得到的矩阵形状为$5\times3$，记该矩阵为$B$。接下来将准则层的得分向量左乘$B$矩阵，就得到了在方案层的层次总排序</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220105010617987.png" alt="层次总排序" style="zoom: 67%;"></p><h4 id="2-一致性检验-1"><a href="#2-一致性检验-1" class="headerlink" title="2) 一致性检验"></a>2) 一致性检验</h4><p>类似的，我们从几个不同的指标对每个方案的打分都是主观的，因此对于单个指标的对比矩阵，会出现不一致的情况。因此还要继续进行一致性检验。</p><p>我们对每一个指标$A_j$都可以计算其一致性指标$CI_j$、随机一致性指标$RI_j$，$j=1,2,\cdots,m$，则层次总排序的一致性比率为:</p><script type="math/tex; mode=display">CR=\frac{a_1CI_1+a_2CI_2+\cdots+a_mCI_m}{a_1RI_1+a_2RI_2+\cdots+a_mRI_m}</script><p>同样，当$CR\leq 0.1$时候，则表示通过层次一致性检验，注意，这里的$A=[a_1,a_2,\cdots,a_n]$是经过归一化之后准则的权重向量值</p><p>我们继续上面的旅游的例子，那么有</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220105012126634.png" alt="层次总排序以及其一致性检验1"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220105012208466.png" alt="层次总排序以及其一致性检验2"></p><p>组合权向量即方案最终的得分。计算方法就是用准则层的每个准则得分和某个城市在这几个准则上的得分做内机，最后得到的分数</p><h2 id="4-层次分析法总结"><a href="#4-层次分析法总结" class="headerlink" title="4. 层次分析法总结"></a>4. 层次分析法总结</h2><p>最后，对层次分析法的流程做一个总结</p><ol><li>建立层次结构模型。该结构图包括目标层，准则层，方案层</li><li>构造成对比较矩阵。从第二层开始用成对比较矩阵和1-9尺度</li><li>计算单排序权向量并做一致性检验。对每个成对比较矩阵计算最大特征值及其对应的特征向量，利用一致性指标、随机一致性指标和一致性比率做一致性检验。 若检验通过，特征向量（归一化后）即为权向量；若不通过， 需要重新构造成对比较矩阵</li><li>计算总排序权向量并做一致性检验。计算最下层对最上层总排序的权向量，利用总排序一致性比率，进行检验。若通过，则可按照总排序权向量表示的结果进 行决策，否则需要重新考虑模型或重新构造那些一致性比率较大的成对比较矩阵</li></ol><h2 id="5-层次分析法Python求解"><a href="#5-层次分析法Python求解" class="headerlink" title="5. 层次分析法Python求解"></a>5. 层次分析法Python求解</h2><p>由于层次分析法全部都是矩阵乘法，因此Numpy和Pandas即可求解，下面的这个只是一个初级版本，实现了层次分析法，但是没有实现从表格中读取，也没有给出GUI的输入，后面等开始大美赛前再完善一下吧</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport pandas as pdfrom typing import *from colorama import Fore, Styleclass AnalyticHierarchyProcess(object):    RI = (0, 0, 0.58, 0.9, 1.12, 1.32, 1.41, 1.45, 1.49)    def __init__(self, criteria: Union[List[str], int], plans: Union[List[str], int], method="manual") -> None:        super().__init__()        assert method in ["csv", "manual"]        self.criteria_name = [f"准则{i}" for i in range(criteria)] if isinstance(criteria, int) else criteria        self.criteria = self.get_criteria(criteria_names=self.criteria_name, method=method)        self.plan_names = [f"方案{i}" for i in range(plans)] if isinstance(plans, int) else plans        self.plan_scores = self.get_plan_scores(self.plan_names, self.criteria_name, method=method)    def matrix2str(self, column: List[str], index: List[str]) -> str:        ss = pd.DataFrame(self.criteria, index=index, columns=column)        return ss.__str__()    def run(self):        print("开始层次单排序")        eigvalue, eigvector = np.linalg.eig(self.criteria)        if len(eigvalue) == 1:            print("标准对比矩阵为一致阵")            w = eigvector        else:            print("标准对比矩阵为非一致阵，开始进行一致性检验")            ci = (max(eigvalue) - len(self.criteria)) / (len(self.criteria) - 1)            if (cr := ci/self.RI[len(self.criteria) -1]) < 0.1:                print(f"层次单排序一致性检验一致性比率CR={cr:>.3f}，通过检验")                w = eigvector[:, np.argmax(eigvalue)]            else:                print(self.matrix2str(column=self.criteria_name, index=self.criteria_name))                assert False, f"层次单排序一致性检验未通过， CR={cr:>.3f}"        # 归一化处理，softmax        w = w / sum(w)        print("开始层次总排序")        m = []        ci_all = []        ri_all = []        for c_name, c_score in zip(self.criteria_name, self.plan_scores):            print(f"针对 {Fore.GREEN}{c_name}{Style.RESET_ALL} 进行层次单排序")            eigvalue, eigvector = np.linalg.eig(c_score)            if len(eigvalue) == 1:                print(f"{Fore.GREEN}{c_name}{Style.RESET_ALL} 的对比矩阵为一致阵")                m.append(eigvector / sum(eigvector))            else:                print(f"{Fore.GREEN}{c_name}{Style.RESET_ALL} 的对比矩阵为非一致阵")                ci = (max(eigvalue) - len(c_score)) / (len(c_score) - 1)                if (cr := ci/self.RI[len(c_score) -1]) < 0.1:                    print(f"{Fore.YELLOW}{c_name}{Style.RESET_ALL}层次单排序一致性检验一致性比率CR={cr:>.3f}，通过检验")                    e = eigvector[:, np.argmax(eigvalue)]                    m.append(e / sum(e))                else:                    print(self.matrix2str(self.plan_names, self.plan_names))                    assert False, f"{Fore.YELLOW}{c_name}{Style.RESET_ALL}层次单排序一致性检验未通过， CR={cr:>.3f}"            ci_all.append(ci)            ri_all.append(self.RI[len(c_score)-1])        assert (cr:=(np.array(ci_all) @ w) / (np.array(ri_all) @ w)) < 0.1, f"层次总排序一致性检验未通过，CR={cr:>.3f}"        m = np.array(m)        final_score = w @ m        print(f"最终得分:{final_score}")    @staticmethod    def get_criteria(criteria_names: List[str], method: str) -> np.ndarray:        if method == "manual":            criteria = np.eye(N=(l:=len(criteria_names)))            print("="*200)            print("请输入评价标准之间的相对重要性（1-9，1，3，5，7，9分别表示标准A比标准B：同等重要、稍微重要、比较重要、很重要、绝对重要，2，4，6，8分别为中位数）")            print("若标准A不如标准B重要，则输入1/标准B比标准A的相对重要性，例如标准A不如标准B重要，而标准B比标准A为3，那么标准A比标准B为1/3")            print("+"*200)            for i in range(l):                for j in range(i+1,  l):                    if "/" not in (inp:=input(f"请输入 {Fore.GREEN}{criteria_names[i]}{Style.RESET_ALL} 对 {Fore.GREEN}{criteria_names[j]}{Style.RESET_ALL} 的相对重要性：")):                        criteria[i, j] = int(inp)                    else:                        upper, lower = [int(j) for j in inp.split("/")]                        criteria[i, j] = upper / lower                if i+1 < l:                    print("+"*200)            position = np.where(criteria==0)            criteria[position] = 1 / criteria.transpose()[position]            print("输入的评价标准之间的对比矩阵为：")            print(criteria)            print("="*200)        elif method == "csv":            pass        return criteria    @staticmethod    def get_plan_scores(plan_names: List[str], criteria_names: List[str], method: str) -> np.ndarray:        if method == "manual":            plan_scores = np.repeat(np.eye(N=len(plan_names)).reshape(1, len(plan_names), len(plan_names)), repeats=len(criteria_names), axis=0)            print("="*200)            print("请输入不同方案之间就某一个标准的的相对重要性（1-9，1，3，5，7，9分别表示标准A比标准B：同等重要、稍微重要、比较重要、很重要、绝对重要，2，4，6，8分别为中位数）")            print("若就标准X，方案A不如方案B重要，则输入1/方案B比方案A的相对重要性，例如就标准X，方案A不如方案B重要，而方案B比方案A为3，那么方案A比方案B为1/3")            for i in range(len(criteria_names)):                print(f"就 {Fore.YELLOW}{criteria_names[i]}{Style.RESET_ALL} 对方案之间的得分进行比较".center(200, "+"))                for j in range(l := len(plan_names)):                    for k in range(j+1, l):                        if "/" not in (inp:=input(f"请从 {Fore.YELLOW}{criteria_names[i]}{Style.RESET_ALL} 的角度，输入 {Fore.GREEN}{plan_names[j]}{Style.RESET_ALL} 对 {Fore.GREEN}{plan_names[k]}{Style.RESET_ALL} 的相对重要性：")):                            plan_scores[i, j, k] = int(inp)                        else:                            upper, lower = [int(j) for j in inp.split("/")]                            plan_scores[i, j, k] = upper / lower                position = np.where(plan_scores[i] == 0)                plan_scores[i, position[0], position[1]] = 1 / plan_scores[i].transpose()[position]            print("输入的不同评价标准下方案间的对比矩阵为：")            for c, s in zip(criteria_names, plan_scores):                print(c)                print(s)            print("="*200)        elif method == "csv":            pass        return plan_scoresif __name__ == "__main__":    ahp = AnalyticHierarchyProcess(criteria=["景色", "费用", "居住", "饮食", "旅途"], plans=["苏杭", "北戴河", "桂林"])    ahp.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106135400089.png" alt="层次分析法运行结果"></p><h2 id="6-层次分析法例题"><a href="#6-层次分析法例题" class="headerlink" title="6. 层次分析法例题"></a>6. 层次分析法例题</h2><h3 id="A-队员选拔问题"><a href="#A-队员选拔问题" class="headerlink" title="A. 队员选拔问题"></a>A. 队员选拔问题</h3><h4 id="A-问题"><a href="#A-问题" class="headerlink" title="A. 问题"></a>A. 问题</h4><blockquote><p>设某学校数学建模教练组根据实际需要，拟从报名参赛的20名队员中选出15名优秀队员代表学校参赛。 表1给出了20名队员的基本条件的量化情况。 请根据这些条件对20名队员进行综合评价，从中选出15名综合素质较高的优秀队员</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106140221242.png" alt="队员基本情况表" style="zoom: 50%;"></p></blockquote><h4 id="B-问题分析"><a href="#B-问题分析" class="headerlink" title="B. 问题分析"></a>B. 问题分析</h4><p>这是一个半定性与半定量、多因素的综合选优排序问题． 鉴于数学建模竞赛不仅要考查学生的学科知识、还要考查学生的 作能力、计算机应用能力、团结协助能力等多方面的因素，要 从20名队员中选拔出优秀参赛队员，就要对表1中所列的六个因素进行比较分析，综合排序选优，从而选取前几名学生。</p><h4 id="C-假设"><a href="#C-假设" class="headerlink" title="C. 假设"></a>C. 假设</h4><ol><li>题目中所确定的考评条件是合理的，能够反映出参选队员的建模能力</li><li>各参选队员的量化得分是按统一的量化标准得出的</li><li>对参选队员的量化打分是公平的，所有参选队员对打分结果无异议</li><li>选拔队员所考虑的六个因素在选拔优秀队员中所起的作用依次为学科知识竞赛成绩、思维敏捷度、知识面宽广度、写作能力、计算机应用能力、团结协助能力，并且相邻两个因素的影响程度之差基本相同</li></ol><h4 id="D-模型建立"><a href="#D-模型建立" class="headerlink" title="D. 模型建立"></a>D. 模型建立</h4><p>根绝题目要求和分析与假设，建立如下的层次结构图</p><ol><li><strong>第一层为目标层</strong>：选拔优秀参赛队员</li><li><strong>第二层为准则层</strong>：选拔优秀队员时所考虑的6个因素，依次为学科知识竞赛成绩、思维敏捷度、知识面宽广度、写作能力、计 算机应用能力、协助能力</li><li><strong>第三层为方案层</strong>：参选的20名队员</li></ol><p>结构图如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106143423911.png" alt="队员选拔问题层次结构图"></p><h4 id="E-模型求解"><a href="#E-模型求解" class="headerlink" title="E. 模型求解"></a>E. 模型求解</h4><ol><li><p><strong>确定准则层对目标层的权重向量</strong>：根据假设，构造准则层$C$的准则间的比较矩阵</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106143632490.png" alt="准则层C的比较矩阵" style="zoom:50%;"></p></li><li><p><strong>确定方案层对准则层的权重向量</strong>：根据表1和模型假设，构造方案层$P$中20个队员对准则层$C$中各因素$C_k$的两两比较矩阵。构造方式为分数的两两比较</p></li><li><p><strong>求解</strong>：结果如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220106144434996.png" alt="求解结果"></p></li></ol><h4 id="F-模型分析"><a href="#F-模型分析" class="headerlink" title="F. 模型分析"></a>F. 模型分析</h4><ul><li>由表1，20名队员六项条件互有强弱，利用层次分析法 得到了一种合理的综合排序方案，结果选出了综合实力较强的 15名队员</li><li>第13号队员各项条件总体较强，排在了第一位</li><li>第9号和第10号队员各项条件总体较弱，排在后两位</li></ul><h2 id="7-层次分析法的综合评价"><a href="#7-层次分析法的综合评价" class="headerlink" title="7. 层次分析法的综合评价"></a>7. 层次分析法的综合评价</h2><p>最后，给出层次分析法的整体上的一个评价</p><p>首先是优点：</p><ul><li><strong>系统性</strong>：把所研究的问题看成一个系统，按照分解、比较判断、 综合分析的思维方式进行决策分析，也是实际中继机理分析方法、统 计分析方法之后发展起来的又一个重要的系统分析工具．</li><li><strong>实用性</strong>：把定性与定量方法结合起来，能处理许多传统的优化 方法无法处理的实际问题，应用范围广．而且将决策者和决策分析者 联系起来，体现了决策者的主观意见，决策者可以直接应用它进行决 策分析，增加了决策的有效性和实用性．</li><li><strong>简洁性</strong>：具有中等文化程度的人都可以学习掌握层次分析法的基 本原理和步骤，计算也比较简便，所得结果简单明确，容易被决策者 了解和掌握．</li></ul><p>然后是其缺点：</p><ul><li>局限性是粗略、主观．首先是它的比较、判断及结果都是粗糙的， 不适于精度要求很高的问题</li><li>其次是从建立层次结构图到给出两两比较矩阵，人的主观因素作用 很大，使决策结果较大程度地依赖于决策人的主观意志，可能难以为 众人所接受</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 层次分析法 </tag>
            
            <tag> Analytic Hierarchy Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法4-非线性规划</title>
      <link href="/2022/01/04/shu-xue-jian-mo-suan-fa-4-fei-xian-xing-gui-hua/"/>
      <url>/2022/01/04/shu-xue-jian-mo-suan-fa-4-fei-xian-xing-gui-hua/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲解了数学建模中常见的一类问题：非线性规划，及其求解</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/v2-69cfe96a3fb52b79353c03cadb085a3b_1440w.jpg" alt="非线性规划"></p><h1 id="数学建模算法4-非线性规划"><a href="#数学建模算法4-非线性规划" class="headerlink" title="数学建模算法4-非线性规划"></a>数学建模算法4-非线性规划</h1><p>在前面的几篇文章中，我们介绍了线性规划、整数规划以及01规划，并且给出了如何利用Python来对他们进行求解。</p><p>但是在显示问题中，的确有很多规划问题他们的约束都不是线性的，或者他们的目标函数也不是线性的。可是我们在数学建模的过程中，我们自己提出来的模型很有可能是非线性的规划问题，此时就我们就不得不对非线性的规划问题进行求解。</p><p>为此，本文介绍了什么是非线性规划问题，以及如何利用Python求解非线性规划问题。</p><h2 id="1-非线性规划问题介绍"><a href="#1-非线性规划问题介绍" class="headerlink" title="1. 非线性规划问题介绍"></a>1. 非线性规划问题介绍</h2><p>如果目标函数或约束条件中包含非线性函数，就称这种规划问题为<strong>非线性规划问题（Nonlinear Programming，NP）</strong>。一般说来，解非线性规划要比解线性规划问题困难得多。而且，也不像线性规划有单纯形法这一通用方法，非线性规划目前还没有适于各种问题的一般算法，各个方法都有自己特定的适用范围。例如：</p><ul><li>20世纪50年代，H.W.Kuhn 和 A.W.Tucker 提出了非线性规划的基本定理，为非线性规划奠定了理论基础 </li><li>50、60 年代出现了许多解非线性规划问题的有效算法</li><li>80年代后，随着计算机技术的快速发展，非线性规划方法取得了长足进步，在信赖域法、稀疏拟牛顿法、并行计算、内点法和有限存储法等领域取得了丰硕的成果。</li></ul><p>不过就和前面的文章一样，我们其实并不需要关注这些算法的原理以及如何如何实现这个算法，我们只需要会用就行了，因此下面就围绕非线性规划问题进行求解。</p><h2 id="2-非线性规划的标准形式"><a href="#2-非线性规划的标准形式" class="headerlink" title="2. 非线性规划的标准形式"></a>2. 非线性规划的标准形式</h2><p>类似于线性规划的标准形式，非线性规划的约束条件可以划归称两类：第一类是$\leq型，第二类是$$=$型。</p><p>我们下面给出来非线性规划的标准形式：</p><script type="math/tex; mode=display">\min Z=f(x)\\\begin{cases}h_1(x)\leq 0\\h_2(x)\leq 0\\\cdots\\h_p(x)\leq 0\\g_1(x)\leq 0\\g_2(x)\leq 0\\\cdots\\g_q(x)\leq 0\\\end{cases}</script><p>对后面两个式子进行缩写，得到</p><script type="math/tex; mode=display">\min Z=f(x)\\\begin{cases}h_i(x)\leq 0, &i=1,\cdots,p\\g_i(x)\leq 0, &i=1,\cdots,q\\lb\leq x \leq ub\end{cases}</script><h2 id="3-非线性规划问题的Python求解"><a href="#3-非线性规划问题的Python求解" class="headerlink" title="3. 非线性规划问题的Python求解"></a>3. 非线性规划问题的Python求解</h2><p>使用Python求解非线性规划问题，主要使用SciPy中的minimize函数，这个函数实际上是多个优化算法的接口。</p><p>该函数的函数头如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">scipy.optimize.minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，我们需要关注的变量只有下面几个：</p><ul><li><p>fun：以Python中的函数的形式定义的目标函数</p></li><li><p>x0：在有些求解非线性约束的方法中（例如拟牛顿法）需要梯度来帮助求解，因此需要一个初始值进行迭代</p></li><li><p>bounds：每个变量的上下限</p></li><li><p>constrains：元组形式的约束条件，其中每个约束条件是元组中的一个项，用一个字典表示</p><p>以字典形式表示的约束条件按照如下方式</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">{'type': 'ineq', 'fun': functionname}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>type是约束的类型，是等式约束还是不等式约束，等式约束为eq，不等式约束为ineq，<strong>默认不等式约束为大于等于0</strong></li><li>fun是以Python的函数的形式定义的约束的函数</li></ul></li></ul><p>此外，需要注意的是，约束的函数和目标变量的函数都是需要接受一个变量作为输入，这个变量即决策变量组成的向量，而决策向量的形状由x0决定</p><p>例如对下面的非线性规划问题进行求解</p><script type="math/tex; mode=display">\min f(x)=x_1^2+x_2^2+x_3^2\\\begin{cases}x_1^2-x_2+x_3^2\ge 0\\-x_1-x_2^2-x_3^2\ge 20\\-x_1-x_2^2+2=0\\x_2+2x_3^2=3\\x_1,x_2,x_3\ge 0\end{cases}</script><h3 id="A-定义决策变量"><a href="#A-定义决策变量" class="headerlink" title="A. 定义决策变量"></a>A. 定义决策变量</h3><p>定义决策变量很简单，直接写一个函数就行了，注意这个函数的输入是和x0形状相同的Numpy的array</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport scipy.optimize as scoptdef objective(x: np.ndarray):    return sum(x ** 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="B-定义约束"><a href="#B-定义约束" class="headerlink" title="B. 定义约束"></a>B. 定义约束</h3><p>注意，约束的定义也是写成Python中的函数，函数的参数也是Numpy的array</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def constrain1(x: np.ndarray):    return x[0] ** 2 - x[1] + x[2] ** 2def constrain2(x):    return -(x[0] + x[1] ** 2 + x[2] ** 3 - 20)def constrain3(x):    return -x[0] - x[1] ** 2 + 2def constrain4(x):    return x[1] + 2 * x[2] ** 2 - 3def x0_bound(x):    return x[0] - 0def x1_bound(x):    return x[1] - 0def x2_bound(x):    return x[2] - 0constrains = (    {"type": "ineq", "fun": constrain1},    {"type": "ineq", "fun": constrain2},    {"type": "eq", "fun": constrain3},    {"type": "eq", "fun": constrain4},    {"type": "ineq", "fun": x0_bound},    {"type": "ineq", "fun": x1_bound},    {"type": "ineq", "fun": x2_bound},)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-调用求解"><a href="#C-调用求解" class="headerlink" title="C. 调用求解"></a>C. 调用求解</h3><p>调用函数求解，依次填入参数即可</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">x0 = np.array([1, 2, 3])result: scopt.OptimizeResult = scopt.minimize(fun=objective, x0=x0, constraints=constrains)print(result.message)print(result.x)print(result.fun)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求解结果</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104173928413.png" alt="求解结果"></p><h3 id="D-完整代码"><a href="#D-完整代码" class="headerlink" title="D. 完整代码"></a>D. 完整代码</h3><p>完整的代码如下，注意约束条件也可以指定bounds参数</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport scipy.optimize as scoptdef objective(x: np.ndarray):    return sum(x ** 2)def constrain1(x: np.ndarray):    return x[0] ** 2 - x[1] + x[2] ** 2def constrain2(x):    return -(x[0] + x[1] ** 2 + x[2] ** 3 - 20)def constrain3(x):    return -x[0] - x[1] ** 2 + 2def constrain4(x):    return x[1] + 2 * x[2] ** 2 - 3def x0_bound(x):    return x[0] - 0def x1_bound(x):    return x[1] - 0def x2_bound(x):    return x[2] - 0constrains = (    {"type": "ineq", "fun": constrain1},    {"type": "ineq", "fun": constrain2},    {"type": "eq", "fun": constrain3},    {"type": "eq", "fun": constrain4},    # {"type": "ineq", "fun": x0_bound},    # {"type": "ineq", "fun": x1_bound},    # {"type": "ineq", "fun": x2_bound},)bounds = [(0, None) for i in range(3)]x0 = np.array([1, 2, 3])result: scopt.OptimizeResult = scopt.minimize(fun=objective, x0=x0, constraints=constrains, bounds=bounds)print(result.message)print(result.x)print(result.fun)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-非线性规划例子"><a href="#4-非线性规划例子" class="headerlink" title="4. 非线性规划例子"></a>4. 非线性规划例子</h2><p>下面介绍即非线性规划的数学模型的例子</p><h3 id="A-选址供应问题"><a href="#A-选址供应问题" class="headerlink" title="A. 选址供应问题"></a>A. 选址供应问题</h3><p>问题的具体描述如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220105042024932.png" alt="选址供应问题"></p><h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1) 问题分析"></a>1) 问题分析</h4><p>第一问中需要进行决策的变量就是从某个料场到某个工地需要运输多少的水泥，例如从料场A运输到工地1。因此考虑到有两个料场，每个料场都可以去六个工地，因此决策变量实际上用12个。</p><p>而第二问则需要决策的变量变成了两个新料场的位置，因此需要决策变量就成了两个新料场的坐标，因此第二问的决策变量有4个。</p><p>因此两问分别对应两个规划问题。</p><h4 id="2-建立模型"><a href="#2-建立模型" class="headerlink" title="2) 建立模型"></a>2) 建立模型</h4><ol><li><p>第一问</p><p>记工地的位置为$(a_i,b_i)$，水泥日用量为$d_i,i=1,\cdots,6$；料场的位置记为$(x_j, y_j),j=1,2$。则设料场$j$向工地$i$的运输量为$X_{ij}$</p><p>则针对第一问，建立的数学模型如下</p><script type="math/tex; mode=display">\min f=\sum_{j=1}^2\sum_{i=1}^6X_{ij}\sqrt {(x_i-a_i)^2+(y_i-b_i)^2}\\\begin{cases}\sum_{j=1}^2 X_{ij}=d_i, & i=1,\cdots,6\\\sum_{i=1}^6 X_{ij}\leq e_{ij}, &j=1,2\end{cases}</script></li></ol><ol><li>第二问</li></ol><h4 id="3-问题求解"><a href="#3-问题求解" class="headerlink" title="3) 问题求解"></a>3) 问题求解</h4><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 非线性规划 </tag>
            
            <tag> Non-Linear Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法3-01规划</title>
      <link href="/2022/01/03/shu-xue-jian-mo-suan-fa-3-01-gui-hua/"/>
      <url>/2022/01/03/shu-xue-jian-mo-suan-fa-3-01-gui-hua/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲解了数学建模中常见的一类问题：01规划，及其求解</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220103165339023.png" alt="01规划问题"></p><h1 id="数学建模算法3-01规划"><a href="#数学建模算法3-01规划" class="headerlink" title="数学建模算法3-01规划"></a>数学建模算法3-01规划</h1><p>前面我们介绍了数学规划中的线性规划、整数规划。其实对于整数规划来说，还有一类特殊的规划问题就是决策变量的取值只能为0或者1，这样的问题我们称为0-1规划。</p><p>01规划问题通常出现在指派问题中，例如一共有很多种任务，多个不同的人完成每种任务需要的时间不同，求最短耗时。那么这里是否派A去做任务X就是一个只能取0或者1的变量。因此这样的问题就可以用01规划来解决。更多可以用01规划求解的问题在后面会进行介绍。</p><h2 id="1-01规划问题介绍"><a href="#1-01规划问题介绍" class="headerlink" title="1. 01规划问题介绍"></a>1. 01规划问题介绍</h2><p>其实对于01规划问题来说，如果假设所有的变量的取值都是0或者1，并且所有变量之间都是独立的，那么我们其实用整数规划就能求解。因为所有变量独立的01规划问题相比于整数规划问题，只是单纯的限制了每个决策变量的定义域为$0\leq x_i\leq 1$。</p><p>所以对于所有变量独立的01规划来说，给所有的01变量添加大于等于0且小于等于1的约束即可。</p><p>然而01规划中，真正难处理的是01变量之间会相互影响的01规划。例如上面的投资问题，设$x_i$表示是否投资第$i$个项目，那么$x_i$的取值只能在0和1之间。</p><p>但是项目I、II、III之间会相互影响，即是否投资项目II会影响到项目I、项目III的投资，而项目I是否投资又会影响到项目V是否投资。</p><p>因此，称处01变量之间相互制约的条件为<strong>互斥条件</strong>，而为了处理含互斥条件的的01问题，在原有的约束的基础上引入<strong>互斥约束</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220103165339023.png" alt="01规划问题"></p><p>再举一个例子（如下图），新工序和原工序都是线性约束，但是在考虑两种工序到底用哪一个才能使得收益最大的时候，就可以另设一个01变量$y$表示是否用原工序。此时问题就成了混合线性规划问题。</p><p>当然这里也可以设$x_0$表示是否用原工序，$x_1$表示是否用新工序，那么再额外引入一个互斥约束为$x_1+x_1=1$。</p><p>注意，之所以要$M$是一个充分大的数（无穷），是因为$3x_1+5x_2\leq\infin$这个约束条件等价于没有，因为$x_1$和$x_2$都可以取任意的值</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220103170758245.png" alt="互斥约束问题"></p><h2 id="2-01规划问题的数学化"><a href="#2-01规划问题的数学化" class="headerlink" title="2. 01规划问题的数学化"></a>2. 01规划问题的数学化</h2><p>要对01规划进行进行求解，就需要首先写出来01规划的标准式，然后针对标准式运用算法进行求解</p><h3 id="A-leq-类型"><a href="#A-leq-类型" class="headerlink" title="A. $\leq$类型"></a>A. $\leq$类型</h3><p>设从下面$p$个约束条件中选择$q$个约束条件</p><script type="math/tex; mode=display">\begin{cases}\sum_{j=1}^n a_{1j}x_j \leq b_1\\\sum_{j=1}^n a_{2j}x_j \leq b_2\\\sum_{j=1}^n a_{3j}x_j \leq b_3\\\cdots\\\sum_{j=1}^n a_{pj}x_j \leq b_p\\\end{cases}</script><p>设</p><script type="math/tex; mode=display">y_i=\begin{cases}0, &选择第i个约束条件\\1, &不选择第i个约束条件\end{cases}</script><p>则需要添加的互斥约束为：</p><script type="math/tex; mode=display">\begin{cases}\sum_{j=1}^n a_{ij}x_j \leq b_i+My_i, & i=1,2,\cdots,p\\\sum_{i=1}^p y_i=p-q, &i=1,2,\cdots,p\end{cases}</script><p>上面这两个约束也非常好理解：</p><ul><li>不选的约束的和加起来等于$p-q$</li><li>不选这个约束则表示让该改约失效，即加上一个充分大的数即可</li></ul><h2 id="3-01规划问题举例"><a href="#3-01规划问题举例" class="headerlink" title="3. 01规划问题举例"></a>3. 01规划问题举例</h2><h3 id="A-固定费用问题"><a href="#A-固定费用问题" class="headerlink" title="A. 固定费用问题"></a>A. 固定费用问题</h3><blockquote><p>服装公司租用生产线拟生产T恤、衬衫和裤子。 每年可用劳动力8200h，布料8800m2。生产每类商品需要的劳动力、布料以及售价等信息如下表所示。求该怎样生产产品可以获得最大收益。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220103174537365.png" alt="商品信息表" style="zoom:67%;"></p></blockquote><p>上述问题中的变量其实有两类，第一类是某个商品该生产多少件，第二类是是否租用该商品的生产线。很明显，第二类变量是01变量。</p><p>设$y_i$表示是否要租用第$i$类生产线，$x_j$表示第$j$类商品生产多少件，那么上述问题的数学模型如下：</p><script type="math/tex; mode=display">\max_{\vec x,\vec y} Z=150x_1+220x_2+300x_3-200000y_1-150000y_2-100000y_3\\\begin{cases}3x_1+2x_2+6x_3\leq 8200, &x_1\leq M_1y_1且x_2\leq M_2y_2且x_3\leq M_3y_3\\0.8x_1+1.1x_2+1.5x_2\leq 8800, &x_1\leq M_1y_1且x_2\leq M_2y_2且x_3\leq M_3y_3\\x_1,x_2,x_3\ge 0\\x_1,x_2,x_3均为整数\\y_1,y_2,y_3=0或1\end{cases}</script><h3 id="B-指派问题"><a href="#B-指派问题" class="headerlink" title="B. 指派问题"></a>B. 指派问题</h3><blockquote><p>甲乙丙丁四个人，ABCD四项工作，每个人完成每项工作用时如下表。要求每人只能做一项工 作，每项工作只由一人完成，问如何指派总时间最短？</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220103183021177.png" alt="工作用时表"></p></blockquote><p>上述问题中，一个人完成四个工作有4个时间，那么4个人就一种16个时间。针对这16个时间，引入变量$x_{ij}$</p><script type="math/tex; mode=display">x_{ij}=\begin{cases}1, &第i个人做第j个工作\\0, &第i个人不做第j个工作\end{cases}</script><p>则指派问题的数学模型如下</p><script type="math/tex; mode=display">\begin{align}\min Z=&3x_{11}+5x_{12}+8x_{13}+4x_{14}+\\& 6x_{21}+8x_{22}+5x_{23}+4x_{24}+\\& 2x_{31}+5x_{32}+8x_{33}+5x_{34}+\\& 9x_{41}+2x_{42}+5x_{43}+2x_{44}\end{align}</script><script type="math/tex; mode=display">\begin{cases}x_{11}+x_{12}+x_{13}+x_{14}=1\\x_{21}+x_{22}+x_{23}+x_{24}=1\\x_{31}+x_{32}+x_{33}+x_{34}=1\\x_{41}+x_{42}+x_{43}+x_{44}=1\\x_{11}+x_{21}+x_{31}+x_{41}=1\\x_{12}+x_{22}+x_{32}+x_{42}=1\\x_{13}+x_{23}+x_{33}+x_{43}=1\\x_{14}+x_{24}+x_{34}+x_{44}=1\\\end{cases}</script><p>上述八个约束中，前四个约束为一个人只能做一项工作，而后四个约束为一个工作只能由一个人完成。</p><h3 id="C-指派问题的标准形式"><a href="#C-指派问题的标准形式" class="headerlink" title="C. 指派问题的标准形式"></a>C. 指派问题的标准形式</h3><p>$n$个人和$n$个工作，已知第$i$个人完成第$j$个工作的代价$c_{ij}$，要求每项工作只能由一个人完成，每个人只能完成其中的一项工作，问如何分配工作可以使总代价最少？</p><script type="math/tex; mode=display">C = (c_{ij})_{n\times n}\begin{bmatrix}c_{11} & c_{12} & \cdots & c_{1n}\\c_{21} & c_{22} & \cdots & c_{2n}\\\vdots & \vdots & \ddots & \vdots\\c_{n1} & c_{n2} & \cdots & c_{nn}\\\end{bmatrix}</script><p>称矩阵$C$为指派问题的系数矩阵</p><p>设$x_{ij}$表示第$i$个人做第$j$项工作的状态，即</p><script type="math/tex; mode=display">x_{ij}=\begin{cases}1, & 第i个人做第j项工作\\0, & 第i个人不做第j项工作\end{cases}</script><p>则称</p><script type="math/tex; mode=display">X = (x_{ij})_{n\times n}\begin{bmatrix}x_{11} & x_{12} & \cdots & x_{1n}\\x_{21} & x_{22} & \cdots & x_{2n}\\\vdots & \vdots & \ddots & \vdots\\x_{n1} & x_{n2} & \cdots & x_{nn}\\\end{bmatrix}</script><p>为指派问题的解矩阵。由于指派问题的要求，解矩阵每行每列都仅有一个1，类似于八皇后问题的退化版。</p><p>而指派问题的数学模型为</p><script type="math/tex; mode=display">\min z=\sum_{i=1}^n\sum_{j=1}^nc_{ij}x_{ij}\\\begin{cases}\sum_{j=1}^nx_{ij}=1, & i=1,\cdots,n\\\sum_{i=1}^nx_{ij}=1, & i=1,\cdots,n\\x_{ij}=0或x_{ij}=1, & i=1,\cdots,n\end{cases}</script><h3 id="D-非标准形式的指派问题"><a href="#D-非标准形式的指派问题" class="headerlink" title="D. 非标准形式的指派问题"></a>D. 非标准形式的指派问题</h3><h4 id="1-最大化指派问题"><a href="#1-最大化指派问题" class="headerlink" title="1) 最大化指派问题"></a>1) 最大化指派问题</h4><p>指派问题中是要求画的总时间最少，然而在一些指派问题的变体中，要求优化目标最大，则此时取系数矩阵中最大的元素$c’=\max C$，令</p><script type="math/tex; mode=display">C'=c'-C</script><p>然后转化为了指派问题，对其你找指派问题进行求解即可</p><h4 id="2-人数和工作数不相等"><a href="#2-人数和工作数不相等" class="headerlink" title="2) 人数和工作数不相等"></a>2) 人数和工作数不相等</h4><p>在指派问题中，有$n$个人做$n$项工作，然而在一些变体问题中却会存在两者数量不相等的情况，为此</p><ul><li><strong>人少工作多</strong>：添加虚拟的人，使得人数和工作数相等，注意，添加的虚拟人的代价都是0</li><li><strong>人多工作少</strong>：添加虚拟的工作，使得人数和工作数相等，注意，添加的虚拟工作的代价都是0</li></ul><h4 id="4-多面手问题"><a href="#4-多面手问题" class="headerlink" title="4) 多面手问题"></a>4) 多面手问题</h4><p>标准的指派问题中要求一个人只能做一项工作，然而若一个人可以做三四项工作，那么把这个人变为几个相同的人即可</p><h4 id="5-禁止某人做某工作"><a href="#5-禁止某人做某工作" class="headerlink" title="5) 禁止某人做某工作"></a>5) 禁止某人做某工作</h4><p>为此，将该人做某工作的代价记为无穷大即可</p><h2 id="4-匈牙利算法解01规划问题"><a href="#4-匈牙利算法解01规划问题" class="headerlink" title="4. 匈牙利算法解01规划问题"></a>4. 匈牙利算法解01规划问题</h2><p>下面将结合指派问题讲解如何用匈牙利算法求解01规划问题</p><p>匈牙利算法步骤如下：</p><ol><li><p>对指派问题的系数矩阵$(c_{ij})$进行变换，使其变为$(b_{ij})$，$(b_{ij})$满足在每行每列中都有0元素。变换步骤如下</p><ul><li>对$(c_{ij})$每行元素减去该行最小元素</li><li>从得到的新的矩阵每列元素减去该列的最小元素</li></ul></li><li><p>进行试指派，以寻求最优解</p><p>在$(b_{ij})$中找尽可能多的独立0元素，若能找出$n$个独立0元素（独立0元素指该元素所在的行和列数不相等），就以这$n$个独立0元素对应解矩阵$(x_{ij})$中的元素为1，其余为0，这就得到最优解。找独立0元素，常用的步骤为：</p><ol><li>从只有一个0元素的行(列)开始，给这个0元素加圈，记作◎ 。然后划去◎ 所在列(行)的其它0元素，记作Ø；这表示这列所代表的任务已指派 完，不必再考虑别人了。</li><li>给只有一个0元素的列(行)中的0元素加圈，记作◎；然后划去◎ 所 在行的0元素，记作Ø ．</li><li>反复进行(1)，(2)两步，直到尽可能多的0元素都被圈出和划掉为止</li><li>若仍有没有划圈的0元素，且同行(列)的0元素至少有两个， 则从剩有0元素最少的行(列)开始，比较这行各0元素所在列中0元 素的数目，选择0元素少的那列的这个0元素加圈(表示选择性多的 要“礼让”选择性少的)。然后划掉同行同列的其它0元素。可反 复进行，直到所有0元素都已圈出和划掉为止</li><li>若◎ 元素的数目m 等于矩阵的阶数n，那么这指派问题的 最优解已得到。若m &lt; n, 则转入下一步</li></ol></li><li><p>作最少的直线覆盖所有0元素</p><ol><li>对没有◎的行打√号</li><li>对已打√号的行中所有含Ø元素的列打√号</li><li>再对打有√号的列中含◎ 元素的行打√号</li><li>重复(2)，(3)直到得不出新的打√号的行、列为止</li><li>对没有打√号的行画横线，有打√号的列画纵线，这就得到覆盖 所有0元素的最少直线数 l 。l 应等于m，若不相等，说明试指派过 程有误，回到第二步(4)，另行试指派；若 l＝m &lt; n，须再变换当前 的系数矩阵，以找到n个独立的0元素，为此转第四步</li></ol></li><li><p>变换矩阵(bij)以增加0元素</p><ol><li>在没有被直线覆盖的所有元素中找出最小元素，然后打√各行都减去 这最小元素；打√各列都加上这最小元素（以保证系数矩阵中不出现 负元素）。新系数矩阵的最优解和原问题仍相同。转回第二步</li></ol></li></ol><p>实际上，单纯的看自然语言的描述不好懂，因此下面根据不同的例子来进行讲解匈牙利算法。</p><h3 id="A-例子一"><a href="#A-例子一" class="headerlink" title="A. 例子一"></a>A. 例子一</h3><p>求解下面的指派问题</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104150537191.png" alt="例子一" style="zoom:50%;"></p><ol><li>第一步：对系数矩阵进行变换</li></ol><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104150601301.png" alt="第一步：变换系数矩阵" style="zoom:50%;"></p><ol><li><p>第二步：试指派，寻找最优解，寻找独立的0元素</p><ol><li><p>寻找独立0元素<br> <img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104150735537.png" alt="第二步：试指派" style="zoom:50%;"></p></li><li><p>判断是否完成求解</p><p>  <img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104150954853.png" alt="第二步:判断是否完成求解"></p></li></ol></li></ol><h3 id="B-例子二"><a href="#B-例子二" class="headerlink" title="B. 例子二"></a>B. 例子二</h3><p>求解下面的指派问题</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104151405833.png" alt="例子二" style="zoom:50%;"></p><ol><li><p>第一步：变换系数矩阵</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104151706104.png" alt="变换系数矩阵"></p></li><li><p>第二步：试指派</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104151735596.png" alt="试指派"></p></li><li><p>第三步：覆盖0元素</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104151823539.png" alt="覆盖0元素"></p></li><li><p>第四步：变换系数矩阵，增加0元素</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104152021619.png" alt="变换系数矩阵"></p></li><li><p>第二步：继续进行试指派</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104152113689.png" alt="试指派"></p></li></ol><h2 id="5-01规划Python求解"><a href="#5-01规划Python求解" class="headerlink" title="5. 01规划Python求解"></a>5. 01规划Python求解</h2><blockquote><p>以下内容参考博客：<a href="https://www.cnblogs.com/youcans/p/14854596.html">https://www.cnblogs.com/youcans/p/14854596.html</a></p></blockquote><p>我们上面讲解了该如何使用匈牙利算法求解01规划问题，然而落实到真实的求解上，我们其实可以直接用PuLP即可，没有必要自己去写出来匈牙利算法，逼近CBC以及为我们准备好了。</p><p>下面以一个问题来进行举例</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104152607093.png" alt="例题"></p><h3 id="A-建模"><a href="#A-建模" class="headerlink" title="A. 建模"></a>A. 建模</h3><p>定义决策变量</p><script type="math/tex; mode=display">x_i=\begin{cases}0, &不选第i个项目\\1, &选择第i个项目\end{cases}</script><p>则模型为</p><script type="math/tex; mode=display">\max Z=150x_1+210x_2+60x_3+80x_4+180x_5\\\begin{cases}210x_1+300x_2+100x_3+130x_4+260x_5\leq 600\\x_1+x_2+x_3=1\\x_3+x_4\leq 1\\x_5\leq x_1\\x_i=0或1, & i=1,\cdots,5\end{cases}</script><h3 id="B-Python求解"><a href="#B-Python求解" class="headerlink" title="B. Python求解"></a>B. Python求解</h3><p>求解的具体过程我们其实还是使用PuLP库。类似于整数规划问题，我们只需要指定01变量的类别为”Binary”即可。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pulpimport numpy as npproblem: pulp.LpProblem = pulp.LpProblem(name="最大化投资问题", sense=pulp.LpMaximize)xs = np.array([pulp.LpVariable(name=f"x{i}", lowBound=0, cat=pulp.LpBinary) for i in range(5)])profits = np.array([150, 210, 60, 80, 180])contrain1 = np.array([1, 1, 1, 0, 0])contrain2 = np.array([0, 0, 1, 1, 0])contrain3 = np.array([-1, 0, 0, 0, 1])problem.setObjective(profits @ xs)problem += (contrain1 @ xs == 1, "约束1")problem += (contrain2 @ xs <= 1, "约束2")problem += (contrain3 @ xs <= 0, "约束3")if pulp.LpStatus[problem.solve()] == "Optimal":    v: pulp.LpVariable    for v in problem.variables():        print(f"{v.name}={v.varValue}")    print(f"max Z={pulp.value(problem.objective)}")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行后的结果为</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">Result - Optimal solution foundObjective value:                410.00000000Enumerated nodes:               0Total iterations:               0Time (CPU seconds):             0.00Time (Wallclock seconds):       0.00Option for printingOptions changed from normal to allTotal time (CPU seconds):       0.00   (Wallclock seconds):       0.00x0=1.0x1=0.0x2=0.0x3=1.0x4=1.0max Z=410.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220104154056572.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linear Programming </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 01规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的推导式</title>
      <link href="/2022/01/03/python-zhong-de-tui-dao-shi/"/>
      <url>/2022/01/03/python-zhong-de-tui-dao-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是我CSDN中的文章，完成于2019年，现将其迁移到我的个人博客网站。</p><p>This blog has been finished 2 years ago, in 2019, and was uploaded to CSDN. Now, this blog is transfer to my blog website.</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/20201221215820109.png" alt="Python中的推导式"></p><h1 id="Python推导式-Compression"><a href="#Python推导式-Compression" class="headerlink" title="Python推导式/Compression"></a>Python推导式/Compression</h1><p><strong>推导式 ( Compression )是Python语言的一大特色</strong>：</p><ul><li><p>相比于其他语言而言，推导式使得Python能够便捷的进行循环，创建出特定的字典、列表等可迭代对象</p></li><li><p>使用推导式可以避免代码的冗长，简化代码风格，使得代码更加的<strong>Pythonic</strong></p></li></ul><p>本文就将详细介绍Python中的推导式</p><p>推导式可以分为下面几种:</p><ul><li><strong>列表推导式</strong></li><li><strong>字典推导式</strong></li><li><strong>集合推导式</strong></li><li><strong>生成器推导式</strong></li></ul><h2 id="1-List-Comprehension"><a href="#1-List-Comprehension" class="headerlink" title="1. List Comprehension"></a>1. List Comprehension</h2><p>列表推导式指的是可以用于生成列表的推导式</p><h3 id="A-Simple-List-Comprehension"><a href="#A-Simple-List-Comprehension" class="headerlink" title="A. Simple List Comprehension"></a>A. Simple List Comprehension</h3><p>简单的列表推导式的语法如下,这样我们就能够快捷的创建列表</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">[ 表达式 for 变量 in 可迭代对象 ]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">>>> List1=[x for x in 'abcd']>>> List2=[y**2 for y in range(6)]>>> List3=[i+1 for i in [-1,-2,-3,-4]]>>> print(List1)>>> print(List2)>>> print(List3)['a', 'b', 'c', 'd'][0, 1, 4, 9, 16, 25][0, -1, -2, -3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下(<code>In [1]</code>中的内容可以不管)</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/20201221215759612.png" alt="简单的列表推导式"></p><h3 id="B-List-Comprehension-with-conditions"><a href="#B-List-Comprehension-with-conditions" class="headerlink" title="B. List Comprehension with conditions"></a>B. List Comprehension with conditions</h3><p>上面我们创建了简单的推导式,实际上还可以创建带条件的推导式,这样我们能够创建更复杂的表达式</p><p>带条件的列表推导式如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">[ 表达式 for 变量 in 可迭代对象 if 条件 ]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">>>>List4=[x for x in range(6) if x%2==0]>>>List5=[i**2 for i in range(10) if i**2 in range(10)]>>>print(List4)>>>print(List5)[0, 2, 4][0, 1, 4, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/20201221215809455.png" alt="带条件的列表推导式"></p><h3 id="C-Multi-variable-Comprehension"><a href="#C-Multi-variable-Comprehension" class="headerlink" title="C. Multi-variable Comprehension"></a>C. Multi-variable Comprehension</h3><p>我们前面的列表推导式实际上都只有一个变量,但是我们其实可以使用多变量的列表推导式</p><p>具体时候类似于两个for循环嵌套,因此又可以称为嵌套列表式/多变量推导式</p><p>以双变量和三变量为例的列表推导式如下, 按照这样的规则实际上可以扩展到n个变量的嵌套列表推导式</p><p><strong>双变量列表推导式</strong></p><pre class="line-numbers language-lang-python"><code class="language-lang-python">[ 表达式(可含变量1和变量2) for 变量1 in 可迭代对象1 for 变量2 in 可迭代对象2 ]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>三变量列表推导式</strong></p><pre class="line-numbers language-lang-python"><code class="language-lang-python">[ 表达式(可含变量1和变量及变量3) for 变量1 in 可迭代对象1 for 变量2 in 可迭代对象2 for 变量3 in 可迭代兑现3]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">>>> List6=[(x,y) for x in range(-2,2) for y in [0,1]]>>> List7=[x+y+z for x in range(-2,2) for y in range(3) for z in [0,1]]>>> print(List6)>>> print(List7)[(-2, 0), (-2, 1), (-1, 0), (-1, 1), (0, 0), (0, 1), (1, 0), (1, 1)][-2, -1, -1, 0, 0, 1, -1, 0, 0, 1, 1, 2, 0, 1, 1, 2, 2, 3, 1, 2, 2, 3, 3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/20201221215820109.png" alt="多变量推导式"></p><h3 id="C-Complex-Comprehension"><a href="#C-Complex-Comprehension" class="headerlink" title="C. Complex Comprehension"></a>C. Complex Comprehension</h3><p>实际上我们能够结合带条件的列表推导式和嵌套列表推导式,由此可以有一些非常Pythonic的操作</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">>>>List8=[(x,y) for x in range(-20,20,1) for y in range(-20,20,1) if y==x**2 ]>>>print(List8)[(-4, 16), (-3, 9), (-2, 4), (-1, 1), (0, 0), (1, 1), (2, 4), (3, 9), (4, 16)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的代码就是求<code>y=x**2</code>的曲线上的点的代码</p><p>其实后续结合Numpy,Pandas,Matplotlib等诸多第三方库还可以进行绘图,</p><p>此外还能通元组赋值, zip和enumerate等函数产生妙用</p><p>具体就不一一细讲了,总之列表作Python中最常用的结构型数据类型, 列表推导式的妙用非常多</p><h2 id="2-Dictionary-Comprehension"><a href="#2-Dictionary-Comprehension" class="headerlink" title="2. Dictionary Comprehension"></a>2. Dictionary Comprehension</h2><p>类似于列表推导式, 字典推导式也可以结合条件语句以及多变量嵌套</p><h3 id="A-Simple-Dictionary-Comprehension"><a href="#A-Simple-Dictionary-Comprehension" class="headerlink" title="A. Simple Dictionary Comprehension"></a>A. Simple Dictionary Comprehension</h3><p>简单的字典推导式只使用一个变量, 因此键和键值的表达式中都需要有变量</p><p>声明语句如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">{ 键表达式 : 值表达式 for 表达式 in 可迭代对象 }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">>>>Dict1={i : i**2 for i in range(6)}>>>print(Dict1){0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/20201221215830693.png" alt="字典推导式"></p><h3 id="B-Multi-Variable-Dictionary-Comprehension"><a href="#B-Multi-Variable-Dictionary-Comprehension" class="headerlink" title="B. Multi-Variable Dictionary Comprehension"></a>B. Multi-Variable Dictionary Comprehension</h3><p>实际上一般在创建字典的时候,我们使用的键和键值是不一样的,因此我们更常见的做法是使用嵌套的字典推导式/多变量字典推导式, 即使用多个变量分别作为键和值来进行循环,这样来创建不同的键值对</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">{ 键表达式 : 值表达式 for 变量1 in 可迭代对象1 for 变量2 in 可迭代对象2 }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例如下:</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">Dict1={letter : i for i in range(6) for letter in "abcdef"}Dict1>>>{'a': 5, 'b': 5, 'c': 5, 'd': 5, 'e': 5, 'f': 5}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201221215840522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDg4MjQy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="C-Dictionary-Comprehension-with-conditions"><a href="#C-Dictionary-Comprehension-with-conditions" class="headerlink" title="C. Dictionary Comprehension with conditions"></a>C. Dictionary Comprehension with conditions</h3><p>其实和嵌套的字典推导式一样,略</p><h3 id="D-Complex-Dictionary-Comprehension"><a href="#D-Complex-Dictionary-Comprehension" class="headerlink" title="D. Complex Dictionary Comprehension"></a>D. Complex Dictionary Comprehension</h3><p>复杂字典推导式能够实现各种骚气的功能</p><p>具体就不细说了,我下面给一个例子,更多的使用还需要大家自己开发</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">>>> Sentece='This is a sentence waiting to be count that how many times does letters occur in this sentence'>>> Dict2={letter : Sentece.lower().count(letter) for letter in list('abcdefghijklmnopqrstuvwxyz') }>>> import pprint>>> pprint.print(Dict2){'a': 4, 'b': 1, 'c': 5, 'd': 1, 'e': 11, 'f': 0, 'g': 1, 'h': 4, 'i': 7, 'j': 0, 'k': 0, 'l': 1, 'm': 2, 'n': 8, 'o': 5, 'p': 0, 'q': 0, 'r': 2, 's': 8, 't': 12, 'u': 2, 'v': 0, 'w': 2, 'x': 0, 'y': 1, 'z': 0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子的作用就是查询这一句话中26个字母出现的字数,可以看到在C/C++中需要写很多行代码才能实现的功能在Python中只需要一行就能结束</p><h2 id="3-集合推导式"><a href="#3-集合推导式" class="headerlink" title="3. 集合推导式"></a>3. 集合推导式</h2><p>集合推导式和列表推导是一样的,三种用法都一样,就不赘述了</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">{ 表达式 for 表达式 in 可迭代变量}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子如下:</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">Set1={x for x in range(6)}Set1>>>{0, 1, 2, 3, 4, 5}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 杂项 </tag>
            
            <tag> Python Comprehension </tag>
            
            <tag> Python 推导式 </tag>
            
            <tag> CSDN Blog Transfer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法2-整数规划</title>
      <link href="/2022/01/02/shu-xue-jian-mo-suan-fa-2-zheng-shu-gui-hua/"/>
      <url>/2022/01/02/shu-xue-jian-mo-suan-fa-2-zheng-shu-gui-hua/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲解了数学建模中常见的一类问题：整数规划，及其求解</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/2305037-20210603134210658-726109005.png" alt="整数规划"></p><h1 id="数学建模算法2-整数规划"><a href="#数学建模算法2-整数规划" class="headerlink" title="数学建模算法2-整数规划"></a>数学建模算法2-整数规划</h1><p>在上一篇文章中，我们介绍了线性规划问题及其算法求解。线性规划问题的关键就在于：</p><ol><li>有限的资源（写出来约束）</li><li>最大化价值（写出来目标函数）</li></ol><p>判断一个问题是否可以通过线性规划求解就是看这个问题是否通过划归而具有上面的两个特点。</p><p>线性规划其实有一个隐含的条件，就是要求决策变量（需要通过线性规划决策值的变量）是连续的。但是在现实中，并不所有线性规划问题的决策变量都是连续的，有的时候，我们的决策变量是一个整数。</p><p>例如任务指派问题，在有限的人数的情况下尽可能少的派人去完成问题，这个问题符合上面的两个特点。但是其决策变量人数并不是一个连续的变量，因此直接套用线性规划是不行的。那么可能就会有人要问了，线性规划给出的小数解可能不符合要求，那么取整不就可以了？</p><p>但其实简单的取整是不能处理所有的这样的问题的，例如封面图：线性规划给出的最优解是右侧的点，对这个点的x、y坐标无论怎样取整，得到的解都不在可行域内，甚至周围几个点也都不在可行域内。因此针对这类问题我们为他们取了一个名字：<strong>整数规划（Integer Programming，IP）</strong>，并对整数问题的求解方法进行研究。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/2305037-20210603134210658-726109005.png" alt="整数规划"></p><h2 id="1-整数规划的发展历史"><a href="#1-整数规划的发展历史" class="headerlink" title="1. 整数规划的发展历史"></a>1. 整数规划的发展历史</h2><p>上面的lead-in其实已经相当于介绍了，那么这里就介绍一下整数规划的发展历史吧。</p><p>整数规划是从1958年由R.E.戈莫里提出线性规划的割平面法之后形成独立分支的 ，30多年来发展出很多方法解决各种问题。解整数规划最典型的做法是逐步生成一个相关的问题，称它是原问题的衍生问题。对每个衍生问题又伴随一个比它更易于求解的松弛问题（衍生问题称为松弛问题的源问题）。通过松弛问题的解来确定它的源问题的归宿，即源问题应被舍弃，还是再生成一个或多个它本身的衍生问题来替代它。随即 ，再选择一个尚未被舍弃的或替代的原问题的衍生问题，重复以上步骤直至不再剩有未解决的衍生问题为止。现今比较成功又流行的方法是<strong>分支定界法</strong>和<strong>割平面法</strong>，它们都是在上述框架下形成的。 </p><p><strong>需要注意的是，目前对于整数规划并不存在求解一切整数规划问题的方法（二次的约束、不连续的约束），目前流行的求解方法往往只适用于线性整数规划</strong></p><h2 id="2-整数规划的定义"><a href="#2-整数规划的定义" class="headerlink" title="2. 整数规划的定义"></a>2. 整数规划的定义</h2><p>通过上面的介绍，我们应该明白了什么是整数规划，即决策变量是整数的规划问题。<strong>如果规划的约束和目标函数都是线性的话，则称为线性整数规划</strong>。考虑到我们在数学建模的过程中往往都是对线性整数规划进行的求解，因此<strong>我们也把线性整数规划简称为整数规划</strong>，并且在<strong>后文中如果我们没有特地声明，那么所说的整数规划统统指线性整数规划</strong></p><p>上面是我们主观的理解，下面给出百度百科和维基百科上的定义：</p><blockquote><p><strong>From BaiduBaike</strong>：</p><p>整数规划是指规划中的变量（全部或部分）限制为整数，若在线性模型中，变量限制为整数，则称为整数线性规划。所流行的求解整数规划的方法往往只适用于整数线性规划。<br>一类要求问题的解中的全部或一部分变量为整数的数学规划。从约束条件的构成又可细分为线性，二次和非线性的整数规划。 </p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220102015830244.png" alt="百度百科对整数规划的介绍"></p><p><strong>From Wikipedia</strong>：</p><p>PS: 维基百科没有针对整数规划的词条。整数规划的定义在线性规划词条下。</p><p>要求所有的未知量都为整数的线性规划问题叫做<strong>整数规划</strong>（integer programming, IP）或<strong>整数线性规划</strong>（integer linear programming, ILP）问题。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220102020123747.png" alt="维基百科对整数规划的介绍"></p></blockquote><h2 id="3-整数规划的分类"><a href="#3-整数规划的分类" class="headerlink" title="3. 整数规划的分类"></a>3. 整数规划的分类</h2><p>针对问题中决策变量的不同，整数规划可以分为下面的几类：</p><ul><li><strong>纯整数规划（Pure Integer Programming，PIP）</strong>：所有的决策变量要求都是整数的整数规划，但是为解决问题引入的松弛变量或者剩余变量不要求取整</li></ul><blockquote><p><strong>松弛变量与剩余变量</strong>：</p><p>在求解多变量不等式问题的时候，通常形式是这样的：$x_1+x_2\leq 10$；有的时候为了便于求解，希望能够减少不等式中的变量个数。因此针对上式，引入第三个变量$x_3$，使得$x_1+x_2+x_3=10$，则原不等式变换为一个等式和一个单变量不等式$x_3\ge 0$。</p><p>此时称变量$x_3$为<strong>松弛变量</strong>。直观的理解就是$=$是更加严格的条件，而变量$x_3$让严格的条件松弛称为需要求解问题。</p><p>此外，若$x_1+x_2\ge 10$，则引入变量$x_3$，使得$x_1+x_2-x_3=10$，则$x_3\ge0$，此时称$x_3$为<strong>剩余变量</strong>。即比要求的$=10$多出来的部分</p></blockquote><ul><li><strong>混合整数规划（Mixed Integer Programming，MIP）</strong>：部分决策变量均要求为整数的整数规划</li><li><strong>纯0－1整数规划（Pure 0-1 Integer Programming）</strong>：所有决策变量均要求为0－1的整数规划</li><li><strong>混合0－1规划（Mixed 0-1 Integer Programming）</strong>：部分决策变量均要求为0－1的整数规划</li></ul><h2 id="4-整数规划和线性规划的关系"><a href="#4-整数规划和线性规划的关系" class="headerlink" title="4. 整数规划和线性规划的关系"></a>4. 整数规划和线性规划的关系</h2><h3 id="A-解之间的关系"><a href="#A-解之间的关系" class="headerlink" title="A. 解之间的关系"></a>A. 解之间的关系</h3><p>整数规划实际上是线性规划的一个特例，即在正常的线性规划上加上了非线性的整数约束。因此，根据线性规划解的特点，可以得到整数规划和线性规划解之间的关系：</p><ul><li><strong>最优解一致</strong>：<strong>整数规划去掉整数约束后的线性规划（称为伴随问题或者松弛问题）</strong>的最优解为整数，那么整数规划与线性规划的最优解一致。</li><li><strong>最优解变差</strong>：整数规划的伴随问题的最优解是小数，且整数规划存在可行解，那么整数规划的存在最优解，只是最优解相比伴随问题的最优解变差</li><li><strong>无最优解</strong>：伴随问题可行域内无整数解，故整数规划可能没有最优解</li></ul><h3 id="B-标准形式的关系"><a href="#B-标准形式的关系" class="headerlink" title="B. 标准形式的关系"></a>B. 标准形式的关系</h3><p>由于整数规划只是给决策变量多加了一个要求是整数的这个约束，因此两者的标准式之间基本没有差别</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220102173128816.png" alt="标准形式之间的关系"></p><h2 id="5-适合整数规划求解的问题"><a href="#5-适合整数规划求解的问题" class="headerlink" title="5. 适合整数规划求解的问题"></a>5. 适合整数规划求解的问题</h2><h3 id="A-合理下料问题"><a href="#A-合理下料问题" class="headerlink" title="A. 合理下料问题"></a>A. 合理下料问题</h3><blockquote><p>设用某型号的圆钢可以用于生产零件$A_1$， $A_2$，……，$A_m$ 。在一根圆钢上下料（切割）的方式有$B_1$，$B_2$，……，$B_n$ 种，每种下料方式可以得到各种零件的毛坯数以及用于生产的每种零件的需要量，如下表所示。问怎样安排下料方式，使得在满足生产需要的同时所用的圆钢数量最少？</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220102164618099.png" alt="每种下料方式可产生各种零件毛坯数量以及所需各类零件毛坯数量表" style="zoom:50%;"></p></blockquote><p>上面这个问题，需要的零件作为受限的资源，需要收益（消耗的圆钢）最少因此是一个数学规划问题</p><p>设$x_j$表示用$B_j$种下料方式生产的圆钢，则此时问题的数学模型为：</p><script type="math/tex; mode=display">\min_{x_1,\cdots,x_n}z = \sum_{j=1}^n x_j\\\begin {cases}\sum_{j=1}^n {a_{ij}x_j} \ge b_i &i=1,\cdots,n\\x_j \ge 0, &i=1,\cdots,n\\x_j为整数\end {cases}</script><h3 id="B-建厂问题"><a href="#B-建厂问题" class="headerlink" title="B. 建厂问题"></a>B. 建厂问题</h3><blockquote><p>某公司计划在m个地点建厂，可供选择的地点有$A_1$，$A_2$，……，$A_m$ ，在这些地点建立的工厂的生产能力分别是$a_1$， $a_2$，……，$a_m$（假设生产同一产品）。第 $i$个工厂的建设费用为$f_i,\ i=1,2,\cdots,m$。又有 $n$ 个地点$B_1$，$B_2$，……，$B_n$ 需要销售这 种产品，其销量分别为$b_1$，$b_2$，……，$b_n$ 。从工厂运往销地的单位运费为$c_{ij}$。试决定应在哪些地方建厂，既可以满足各地需要，又使总建设费用和总运输费用最少？</p></blockquote><p>同样，销量是限制的资源，而总费用作为收益需要最优，因此是一个规划问题</p><p>根据题意，可以列出下表</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220102170039401.png" alt="需求-产能-销量-建设费用表" style="zoom:50%;"></p><p>设$x_{ij}$为从工厂$i$运往销地$j$的运输量（$i=1,\cdots,m;j=1,\cdots n$），另设</p><script type="math/tex; mode=display">Y_{ij}=\begin{cases}1, &在A_i处建厂\\0, &不在A_i处建厂\end{cases}</script><p>则建厂问题数学模型为:</p><script type="math/tex; mode=display">\min_{x_{ij},y_i} Z=\sum_{j=1}^m\sum_{i=1}^nc_{ij}x_{ij}+\sum_{i=1}^mf_iy_i\\\begin {cases}\sum_{j=1}^n x_{ij} \leq a_iy_i,&i=1,\cdots,m\\\sum_{i=1}^m x_{ij} \ge b_j, &j=1,\cdots,n\\x_{ij}\ge 0, &i=1,\cdots,m;j=1,\cdots,n\\y_i=1或y_i=0, &i=1,\cdots,m\end{cases}</script><h2 id="6-整数规划的求解"><a href="#6-整数规划的求解" class="headerlink" title="6. 整数规划的求解"></a>6. 整数规划的求解</h2><p>从数学模型上看整数规划似乎是线性规划的 一种特殊形式，求解只需在线性规划的基础上， 通过四舍五入取整，寻求满足整数要求的解即可。 但实际上两者却有很大的不同，通过四舍五入有得到的整数解也不一定就是最优解，有时甚至不能保证所得到的解是整数可行解。</p><p>因此，针对整数规划就有了其他的求解算法。目前，对于求解整数规划常用的方法有：<strong>分支定界法</strong>和<strong>割平面法</strong>；对于0-1规划问题，常用的算法有<strong>隐枚举法</strong>和<strong>匈牙利算法</strong></p><h3 id="A-分支定界算法"><a href="#A-分支定界算法" class="headerlink" title="A. 分支定界算法"></a>A. 分支定界算法</h3><p><strong>分支定界算法的基本就是当作为松弛问题的线性规划问题的解为整数解的时候，整数规划的最优解就是松弛问题的最优解</strong></p><p>因此，分支定界算法的基本思想就是不断地对可行域进行划分（每次划分可行域实际上是添加新的约束），然后对所有的子可行域进行线性规划直到找到解为整数的解，此时该解可能为整数规划的一个最优解。</p><p>算法的自然语言描述如下：</p><ul><li><p>首先不考虑整数限制先求出相应松弛问题的最优解$\vec x=[x^0_1, \cdots, x^0_n]$</p><ul><li><p>若松弛问题无可行解，则ILP无可行解</p></li><li><p>若求得的松弛问题最优解符合整数要求，则是ILP的最优解</p></li><li><p>若不满足整数条件，则从最优解中选择一个不满足整数条件的变量，对其构造新的约束添加到松弛问题中形成两个子问题<br>添加的新的约束为</p><script type="math/tex; mode=display">x_i\leq \lfloor x^0_i\rfloor或者x_i \ge \lceil x^0_i\rceil</script></li><li><p>依次在缩小的可行域中求解新构造的线性规划的最优解</p></li></ul></li><li><p>重复上述过程，直到子问题无解或有整数最优解（被查清）</p></li></ul><p>算法流程图如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220102180932802.png" alt="分支定界算法流程图"></p><p>下面结合两个个例子来讲解分支定界算法</p><blockquote><p>求下面的整数规划问题</p><script type="math/tex; mode=display">\max_{x_1, x_2} z=3x_1+2x_2\\\begin {cases}2x_1+3x_2 \leq 4\\2x_1+x_2 \leq 24\\x_1, x_2 \ge 0\\x_1, x_2为整数\end{cases}</script></blockquote><p>求解步骤如下：</p><ol><li><p><strong>求解松弛问题的解</strong></p><script type="math/tex; mode=display">\max_{x_1, x_2} z=3x_1+2x_2\\\begin {cases}2x_1+3x_2 \leq 4\\2x_1+x_2 \leq 24\\x_1, x_2 \ge 0\\\end{cases}</script><p>得</p><script type="math/tex; mode=display">\begin {cases}x_1=3.25\\x_2=2.5\\z_{max}=14.75\\\end{cases}</script><p>此时松弛问题有解，但是决策变量$x_1$，$x_2$都不是整数，因此对两个变量每个都要添加新的约束</p></li><li><p><strong>首先对决策变量$x_1$添加约束</strong></p><script type="math/tex; mode=display">\max_{x_1, x_2} z=3x_1+2x_2\\\begin {cases}2x_1+3x_2 \leq 4\\2x_1+x_2 \leq 24\\x_1\le 3\\x_1, x_2 \ge 0\\\end{cases}</script><p>求解，得</p><script type="math/tex; mode=display">\begin {cases}x_1=3\\x_2=2.67\\z_{max}=14.33\\\end{cases}</script><p>添加另外一种约束</p><script type="math/tex; mode=display">\max_{x_1, x_2} z=3x_1+2x_2\\\begin {cases}2x_1+3x_2 \leq 4\\2x_1+x_2 \leq 24\\x_1\ge 4\\x_1, x_2 \ge 0\\\end{cases}</script><p>求解得到第一个可能的解</p><script type="math/tex; mode=display">\begin {cases}x_1=4\\x_2=1\\z_{max}=14\\\end{cases}</script></li><li><p><strong>接下来对决策变量$x_2$添加约束</strong></p><script type="math/tex; mode=display">\max_{x_1, x_2} z=3x_1+2x_2\\\begin {cases}2x_1+3x_2 \leq 4\\2x_1+x_2 \leq 24\\x_1\le 3\\x_2\leq 2\\x_1, x_2 \ge 0\\\end{cases}</script><p>得到一个可能的解</p><script type="math/tex; mode=display">\begin {cases}x_1=3\\x_2=2\\z_{max}=13\\\end{cases}</script><p>然后添加另外一种约束</p><script type="math/tex; mode=display">\max_{x_1, x_2} z=3x_1+2x_2\\\begin {cases}2x_1+3x_2 \leq 4\\2x_1+x_2 \leq 24\\x_1\le 3\\x_2\ge 3\\x_1, x_2 \ge 0\\\end{cases}</script><p>得到解</p><script type="math/tex; mode=display">\begin {cases}x_1=2.2\\x_2=3\\z_{max}=13.5\\\end{cases}</script></li><li><p>接下来重复步骤，直到所有的子问题的子问题的解都是整数解或者无解</p></li></ol><p>最终通过对所有的可能的解进行比较，得到最终的解为</p><script type="math/tex; mode=display">\begin {cases}x_1=4\\x_2=1\\z_{max}=14\\\end{cases}</script><p>再举一个例子</p><blockquote><p>求下面的整数规划的解</p><script type="math/tex; mode=display">\max_{x_1, x_2} z=x_1+x_2\\\begin {cases}x_1+\frac9{14}x_2 \leq \frac{51}{14}\\-2x_1+x_2 \leq \frac 1 3\\x_1, x_2 \ge 0\\x_1, x_2为整数\end{cases}</script></blockquote><p>同样，类似于上面的不断添加约束，最后得到一个搜索树，注意下面这个是深度优先的搜索树</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220102193325813.png" alt="问题二的搜索树"></p><h3 id="B-割平面算法"><a href="#B-割平面算法" class="headerlink" title="B. 割平面算法"></a>B. 割平面算法</h3><p>割平面算法的核心思想就是：</p><ol><li>对线性规划问题P添加约束等价于进一步缩小可行域（割去可行域）</li><li>对松弛问题P不断添加约束条件，即可行域不断地割去一块，使得非整数解恰好在割去的区域中而没有割去原问题的可行解，得到新问题P’</li><li>对问题P’继续进行线性规划，直到<ol><li>松弛问题无解，则整数规划问题无解</li><li>松弛问题最优解为整数向量，则整数规划的解就是松弛问题的解</li></ol></li></ol><p>下面结合一个例子讲解割平面算法</p><blockquote><p>求下面的整数规划</p><script type="math/tex; mode=display">\max_{x_1,x_2}z=x_1+x_2\\\begin{cases}-x_1+x_2\leq 1\\3x_1 +x_2 \leq4\\x_1, x_2 \ge 0\\x_1, x_2均为整数\end{cases}</script></blockquote><p>上面这个例子的可行域如下，松弛问题的最优解为$(\frac 43,\frac34)$，因此对其进行分割。</p><p>割平面算法要求分割的时候分割的区域不能包含整数解，因此选择分割的两个区域为上边和右边的两个蓝色三角形。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220102222730181.png" alt="上述例子的可行域"></p><p>对这两个区域进行分割后（添加约束后），新的问题P’为</p><script type="math/tex; mode=display">\max_{x_1,x_2}z=x_1+x_2\\\begin{cases}-x_1+x_2\leq 1\\3x_1 +x_2 \leq4\\x_1, x_2 \ge 0\\x_1\leq 1\\x_2\leq 1\\x_1, x_2均为整数\end{cases}</script><p>此时对P’的松弛问题进行求解，得到解为</p><script type="math/tex; mode=display">\begin {cases}x_1=1\\x_2=1\\z_{max}=2\\\end{cases}</script><p>此时松弛问题的解为整数解，因此算法结束。 </p><p>因此，割平面算法最关键的步骤就是在于判断该怎样对平面进行切割。具体来说进行切割的方法为引入松弛变量和剩余变量。这里就不再展开了。</p><h2 id="7-整数规划的Python求解"><a href="#7-整数规划的Python求解" class="headerlink" title="7. 整数规划的Python求解"></a>7. 整数规划的Python求解</h2><p>虽然我们上面介绍了如何在线性规划的基础上对整数规划问题进行求解的算法。但其实我们并不需要自己动手实现他们。正如我们前面所说的，数学建模的目的在于运用这个算法去解决实际问题而非去动手显示这些算法。</p><p>对整数规划问题进行求解，我们当然可以在前面介绍的SciPy的linprog的基础上自己动手实现这些算法，然而其实有其他的库已经帮助我们进行了这一步了，因此我们直接调用即可。</p><p>具体来说，这个库就是<code>PuLP</code>库，这是他的<a href="https://coin-or.github.io/pulp/index.html">官网</a>：<a href="https://coin-or.github.io/pulp/index.html">https://coin-or.github.io/pulp/index.html</a></p><p>从原理上来说，PuLP这个库是基于其他的线性规划求解程序，在PuLP这个库来说，这些求解线性规划的程序称为求解器。求解器提供了命令行的接口和API，因此PuLP其实就是对这些API做了一层Python Binding，从而实现的在Python中求解整数规划问题。</p><p>PuLP中默认的求解器是开源的CBC求解器，此外还支持很多其他的开源或者商业的求解器。不过CBC用来解决我们一般的几百个决策变量的规划问题肯定是足够了。</p><p>下面针对下面这个线性规划问题使用PuLP进行求解</p><script type="math/tex; mode=display">\max_{x_1, x_2} z=x_1+x_2\\\begin {cases}x_1+\frac9{14}x_2 \leq \frac{51}{14}\\-2x_1+x_2 \leq \frac 1 3\\x_1, x_2 \ge 0\\x_1, x_2为整数\end{cases}</script><h3 id="A-定义问题"><a href="#A-定义问题" class="headerlink" title="A. 定义问题"></a>A. 定义问题</h3><p>PuLP求解线性规划问题第一步就是创建一个线性规划问题（Linear Program Problem，LpProblem）。PuLP中将线性规划问题抽象为一个类，而诸如约束条件、优化目标、决策变量等等都是该类下的属性</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pulpproblem: pulp.LpProblem = pulp.LpProblem(name="线性规划例子", sense=pulp.LpMaximize)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们在初始化该类的时候需要指定该问题的名称，以及优化的类型，是最大值还是最小值</p><h3 id="B-创建决策变量"><a href="#B-创建决策变量" class="headerlink" title="B. 创建决策变量"></a>B. 创建决策变量</h3><p>同样，决策变量也被抽象为了一个类，因此我们需要对其进行初始化</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">x1 = pulp.LpVariable(name="x1", cat=pulp.LpInteger, lowBound=0)x2 = pulp.LpVariable(name="x2", cat=pulp.LpInteger, lowBound=0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们在创建决策变量的时候首先需要指定决策变量的名称，然后指定其类型，因为我们要求解的整数规划问题，因此我们指定这两个变量的取值是整数。</p><p>此外我们还指定了这两个变量的下界都是0，类似与SciPy中连续的线性规划，我们不指定上界（上届为None）的时候，默认是无穷</p><h3 id="C-设置优化目标和约束"><a href="#C-设置优化目标和约束" class="headerlink" title="C. 设置优化目标和约束"></a>C. 设置优化目标和约束</h3><p>我们设置优化目标和添加约束的时候，既可以通过LpProblem类的接口显示的添加，也可以通过其重载的运算符完成</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">problem.setObjective(x1 + x2)problem += x1 + 9/14 * x2 <=51/14, "约束1"problem += pulp.LpConstraint(e=(-2 * x1 + x2), sense=pulp.LpConstraintLE, rhs=1/3, name="约束2")# problem += -2 * x1 + x2 <= 1/3, "约束2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面我们设定优化目标是$x_1+x_2$，然后分别通过problem重载的+=符号、提供的类进行约束添加</p><p>我们此时可以打印一下problem，就能够看到添加了目标和约束之后的问题</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">>>> print(problem)线性规划例子:MAXIMIZE1*x1 + 1*x2 + 0SUBJECT TO约束1: x1 + 0.642857142857 x2 <= 3.64285714286约束2: - 2 x1 + x2 <= 0.333333333333VARIABLES0 <= x1 Integer0 <= x2 Integer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220103151645040.png" alt="运行结果"></p><h3 id="D-求解"><a href="#D-求解" class="headerlink" title="D. 求解"></a>D. 求解</h3><p>由于并不是所有的问题都是可解的因此在对问题进行求解后，实际上问题会有很多种状态，所有的解的状态保存在pulp.LpStatus这个常量中</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">>>> import pprint>>> pprint.print(pulp.LpStatus){-3: 'Undefined', -2: 'Unbounded', -1: 'Infeasible', 0: 'Not Solved', 1: 'Optimal'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，</p><ul><li>Optimal表示已经得到了最优解</li><li>Not Sloved，即problem在求解前的状态</li><li>Infeasible，即问题不存在可行解，例如我们的约束中出现了$2\leq x \leq -1$这样的条件</li><li>Unbounded，即得到的答案是无穷，例如优化目标为$z=3x$，而约束为$1\leq x$</li><li>Undefined，即问题可能存在最优解，但是求解器的求解算法没有得出解</li></ul><p>因此，在我们对问题求解之后，只有Optimal才会得到最终的答案，所以我们求解结束之后输出的时候需要检查一下状态</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">print(problem)if pulp.LpStatus[status] == "Optimal":    variable: pulp.LpVariable    for variable in problem.variables():        print(f"{variable.name}={variable.varValue}")    print(pulp.value(problem.objective))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="E-完整代码"><a href="#E-完整代码" class="headerlink" title="E. 完整代码"></a>E. 完整代码</h3><p>完整代码如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pulpproblem: pulp.LpProblem = pulp.LpProblem(name="线性规划例子", sense=pulp.LpMaximize)x1 = pulp.LpVariable(name="x1", cat=pulp.LpInteger, lowBound=0)x2 = pulp.LpVariable(name="x2", cat=pulp.LpInteger, lowBound=0)problem.setObjective(x1 + x2)problem += x1 + 9/14 * x2 <=51/14, "约束1"problem += pulp.LpConstraint(e=(-2 * x1 + x2), sense=pulp.LpConstraintLE, rhs=1/3, name="约束2")# problem += -2 * x1 + x2 <= 1/3, "约束2"status = problem.solve()# print(status)print(problem)if pulp.LpStatus[status] == "Optimal":    variable: pulp.LpVariable    for variable in problem.variables():        print(f"{variable.name}={variable.varValue}")    print(pulp.value(problem.objective))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行后的输出</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">Welcome to the CBC MILP Solver Version: 2.10.3 Build Date: Dec 15 2019 command line - /home/jack/anaconda3/envs/mm/lib/python3.9/site-packages/pulp/apis/../solverdir/cbc/linux/64/cbc /tmp/5cf19a184e774fe995d025bd3de8e4c9-pulp.mps max timeMode elapsed branch printingOptions all solution /tmp/5cf19a184e774fe995d025bd3de8e4c9-pulp.sol (default strategy 1)At line 2 NAME          MODELAt line 3 ROWSAt line 7 COLUMNSAt line 18 RHSAt line 21 BOUNDSAt line 24 ENDATAProblem MODEL has 2 rows, 2 columns and 4 elementsCoin0008I MODEL read with 0 errorsOption for timeMode changed from cpu to elapsedContinuous objective value is 4.83333 - 0.00 secondsCgl0003I 0 fixed, 1 tightened bounds, 0 strengthened rows, 0 substitutionsCgl0004I processed model has 2 rows, 2 columns (2 integer (0 of which binary)) and 4 elementsCutoff increment increased from 1e-05 to 0.9999Cbc0012I Integer solution of -4 found by DiveCoefficient after 0 iterations and 0 nodes (0.00 seconds)Cbc0001I Search completed - best objective -4, took 0 iterations and 0 nodes (0.00 seconds)Cbc0035I Maximum depth 0, 0 variables fixed on reduced costCuts at root node changed objective from -4.83333 to -4.83333Probing was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)Gomory was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)Knapsack was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)Clique was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)MixedIntegerRounding2 was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)FlowCover was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)TwoMirCuts was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)ZeroHalf was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)Result - Optimal solution foundObjective value:                4.00000000Enumerated nodes:               0Total iterations:               0Time (CPU seconds):             0.00Time (Wallclock seconds):       0.00Option for printingOptions changed from normal to allTotal time (CPU seconds):       0.00   (Wallclock seconds):       0.00线性规划例子:MAXIMIZE1*x1 + 1*x2 + 0SUBJECT TO约束1: x1 + 0.642857142857 x2 <= 3.64285714286约束2: - 2 x1 + x2 <= 0.333333333333VARIABLES0 <= x1 Integer0 <= x2 Integerx1=2.0x2=2.04.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220103153434192.png" alt="求解后的输出"></p><h2 id="8-整数规划的例子"><a href="#8-整数规划的例子" class="headerlink" title="8. 整数规划的例子"></a>8. 整数规划的例子</h2><p>最后举一个真实的整数规划的数学建模的例子结束这一章</p><h3 id="A-最优生产问题"><a href="#A-最优生产问题" class="headerlink" title="A. 最优生产问题"></a>A. 最优生产问题</h3><blockquote><p>已知AM工厂是一个拥有四个车间的玩具生产厂商，该厂商今年新设计出A、B、C、D、E、F六种玩具模型，根据以前的生产情况及市场调查预测，得知生产每单位产品所需的工时、每个车间在一季度的工时上限以及产品的预测价格，如下表所示。问∶每种设计产品在这个季度各应生产多少，才能使AM工厂这个季度的生产总值达到最大?</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220103154101580.png" alt="工时上限以及价格表" style="zoom:67%;"></p></blockquote><h3 id="B-基本假设"><a href="#B-基本假设" class="headerlink" title="B. 基本假设"></a>B. 基本假设</h3><ul><li>利润越高越好</li><li>各个种类玩具都为整数</li></ul><h3 id="C-符号假设"><a href="#C-符号假设" class="headerlink" title="C. 符号假设"></a>C. 符号假设</h3><ul><li>设各种玩具生产数量为$x_i, i=1,\cdots,6$，则$x_i$为整数</li><li>设利润为$Z$，则$Z=20x_1+14x_2+16x_3+36x_4+32x_5+30x_6$</li></ul><h3 id="D-模型建立"><a href="#D-模型建立" class="headerlink" title="D. 模型建立"></a>D. 模型建立</h3><p>根据题意，得到下面的整数规划模型</p><script type="math/tex; mode=display">\max_{\vec x} z=[20,14,16,36,32,30]\vec x^T\\\begin {cases}[0.01, 0.01,0.01,0.03,0.03,0.03]\vec x^T\leq 850\\[0.02, 0, 0, 0.05, 0, 0]\vec x^T\leq700\\[0, 0.02,0,0,0.05,0]\vec x^T\leq100\\[0,0,0.03,0,0,0.08]\vec x^T\leq900\\x_i \ge 0,&i=1,\cdots,6\end {cases}</script><h3 id="E-编程求解"><a href="#E-编程求解" class="headerlink" title="E. 编程求解"></a>E. 编程求解</h3><p>代码如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pulpimport numpy as npproblem: pulp.LpProblem = pulp.LpProblem(name="玩具最优生产问题", sense=pulp.LpMaximize)variables = np.array([pulp.LpVariable(name=f"x_{i}", cat=pulp.LpInteger, lowBound=0) for i in range(6)], dtype=object)jia = np.array([0.01, 0.01,0.01,0.03,0.03,0.03])yi = np.array([0.02, 0, 0, 0.05, 0, 0])bing = np.array([0, 0.02,0,0,0.05,0])ding = np.array([0,0,0.03,0,0,0.08])profits = np.array([20,14,16,36,32,30])problem += jia @ variables <= 850, "甲工厂工时约束"problem += yi @ variables <= 700, "乙工厂工时约束"problem += bing @ variables <= 100, "丙工厂工时约束"problem += ding @ variables <= 900, "丁工厂工时约束"problem.setObjective(profits @ variables)print(problem)if pulp.LpStatus[problem.solve()] == "Optimal":    variable: pulp.LpVariable    for variable in problem.variables():        print(f"{variable.name} = {variable.varValue}")    print(pulp.value(problem.objective))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">玩具最优生产问题:MAXIMIZE20*x_0 + 14*x_1 + 16*x_2 + 36*x_3 + 32*x_4 + 30*x_5 + 0SUBJECT TO甲工厂工时约束: 0.01 x_0 + 0.01 x_1 + 0.01 x_2 + 0.03 x_3 + 0.03 x_4 + 0.03 x_5 <= 850乙工厂工时约束: 0.02 x_0 + 0.05 x_3 <= 700丙工厂工时约束: 0.02 x_1 + 0.05 x_4 <= 100丁工厂工时约束: 0.03 x_2 + 0.08 x_5 <= 900VARIABLES0 <= x_0 Integer0 <= x_1 Integer0 <= x_2 Integer0 <= x_3 Integer0 <= x_4 Integer0 <= x_5 IntegerResult - Optimal solution foundObjective value:                1250000.00000000Enumerated nodes:               0Total iterations:               0Time (CPU seconds):             0.00Time (Wallclock seconds):       0.00Option for printingOptions changed from normal to allTotal time (CPU seconds):       0.00   (Wallclock seconds):       0.00x_0 = 35000.0x_1 = 5000.0x_2 = 30000.0x_3 = 0.0x_4 = 0.0x_5 = 0.01250000.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linear Programming </tag>
            
            <tag> Math Modeling </tag>
            
            <tag> 整数规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法1-线性规划</title>
      <link href="/2022/01/01/shu-xue-jian-mo-suan-fa-1-xian-xing-gui-hua/"/>
      <url>/2022/01/01/shu-xue-jian-mo-suan-fa-1-xian-xing-gui-hua/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲解了数学建模中常见的一类问题：线性规划，及其求解</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/359b033b5bb5c9eab88c9fcdd439b6003af3b3a5" alt="线性规划" style="zoom:150%;"></p><h1 id="数学建模算法1-线性规划"><a href="#数学建模算法1-线性规划" class="headerlink" title="数学建模算法1-线性规划"></a>数学建模算法1-线性规划</h1><p>线性规划是数学建模中非常常见的一类问题，这类问题的求解算法也是必须要掌握的。本文就在介绍线性规划问题的基础上讲解了如何通过编程进行求解。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>在人们的生产实践中，经常会遇到如何利用现有资源来安排生产，以取得最大经济效益的问题。更广泛的，<strong>是在某些变量有约束的条件下，求另外一些以来被约束变量的变量的最大最小值问题</strong>。针对这类问题的求解，形成了数学中的运筹学的一个重要分支——数学规划。而线性规划（Linear Programming，LP）就是数学规划中的一个组分。</p><blockquote><p>数学规划是用于求解有约束变量函数的极值问题。而线性规划是数学规划的一部分。</p></blockquote><p>自从1947年G. B. Dantzig提出求解线性规划的算法——单纯形法以来，线性规划在理论上越来越成熟，在实际的运用中也越来越广泛。尤其是计算机的发展使得能够处理成千上万个约束条件和目标变量的线性规划问题之后，线性规划的适用领域越来越广泛，成为了现代管理中经常采用的一种方法。</p><p>单纯形算法利用多面体的顶点构造一个可能的解，然后沿着多面体的边走到目标函数值更高的另一个顶点，直至到达最优解为止。虽然这个算法在实际上很有效率，在小心处理可能出现的“循环”的情况下，可以保证找到最优解，但它的最坏情况可以很坏：可以构筑一个线性规划问题，单纯形算法需要问题大小的指数倍的运行时间才能将之解出。事实上，有一段时期内人们曾不能确定线性规划问题是NP完全问题还是可以在多项式时间里解出的问题。</p><p>第一个在最坏情况具有多项式时间复杂度的线性规划算法在1979年由前苏联数学家Leonid Khachiyan提出。这个算法建基于非线性规划中Naum Shor发明的椭球法（ellip-soid method），该法又是Arkadi Nemirovski（2003年冯‧诺伊曼运筹学理论奖得主）和D. Yudin的凸集最优化椭球法的一般化。</p><p>理论上，“椭球法”在最恶劣的情况下所需要的计算量要比“单形法”增长的缓慢，有希望用之解决超大型线性规划问题。但在实际应用上，Khachiyan的算法令人失望：一般来说，单纯形算法比它更有效率。它的重要性在于鼓励了对内点算法的研究。内点算法是针对单形法的“边界趋近”观念而改采“内部逼近”的路线，相对于只沿着可行域的边沿进行移动的单纯形算法，内点算法能够在可行域内移动。<br>1984年，贝尔实验室印度裔数学家卡马卡（Narendra Karmarkar）提出了投影尺度法（又名Karmarkar’s algorithm）。这是第一个在理论上和实际上都表现良好的算法：它的最坏情况仅为多项式时间，且在实际问题中它比单纯形算法有显著的效率提升。自此之后，很多内点算法被提出来并进行分析。一个常见的内点算法为Mehrotra predictor-corrector method。尽管在理论上对它所知甚少，在实际应用中它却表现出色。</p><p>单形法沿着边界由一个顶点移动到“相邻”的顶点，内点算法每一步的移动考量较周详，“跨过可行解集合的内部”去逼近最佳解。当今的观点是：对于线性规划的日常应用问题而言，如果算法的实现良好，基于单纯形法和内点法的算法之间的效率没有太大差别，只有在超大型线性规划中，顶点几成天文数字，内点法有机会领先单形法。<br>线性规划的求解程式在各种各样的工业最优化问题里被广泛使用，例如运输网络的流量的最优化问题，其中很多都可以不太困难地被转换成线性规划问题。 </p><h2 id="2-线性规划的定义"><a href="#2-线性规划的定义" class="headerlink" title="2. 线性规划的定义"></a>2. 线性规划的定义</h2><p>先看一个例子</p><blockquote><p>某机床厂能够生产甲、乙两种机床，各自的销售利润为四千和三千元。生产甲机床需要A、B两种机器加工，加工时间分别为2小时每台和1小时每台；生产乙机床需要A、B、C三种机器，加工时间为每种机器各一个小时。若每天A、B、C机器分别只能运行10小时、8小时和7小时。问该厂每天应该生产多少甲、乙机床，才能使得总利润最大？</p></blockquote><p>针对上述问题，求解过程如下：</p><p>设该厂生产$x_1$台甲机床，$x_2$台乙机床，总利润为$z$，则上述问题数学模型为</p><script type="math/tex; mode=display">\max_{x_1, x_2} z =4x_1 + 3x_2\\\begin {cases}2x_1+x+2&\leq &10\\x_1+x_2&\leq &8\\x_2 &\leq &7\\x_1, x_2 &\geq &0\end {cases}</script><p>上面这个问题中，我们称变量$x_1, x_2$为<strong>决策变量</strong>，称变量$z$为<strong>目标变量</strong>，由于目标变量$z$一般都是决策变量的函数，因此有时候也称目标变量为<strong>目标函数</strong>。而对决策变量做出的限制，即上面的四个不等式，称为<strong>约束条件</strong>。</p><p>有了上面的定义后，我们接下来就可以给出线性规划的定义：<strong>称目标函数和约束条件都是线性函数的规划问题为线性规划</strong></p><p>因此，线性规划问题是指在<strong>一组</strong>线性约束的条件下求<strong>一组</strong>线性目标函数最大或最小值的问题。</p><p>一般来说，在约束下的决策变量的值域往往是一个连续的区域，因此称所有符合约束的决策变量的值组成的集合称为该问题的<strong>可行域</strong>，记为R。称可行域中每一个元素$\vec x=[x_1,x_2,\cdots,x_n]$为<strong>可行解</strong>。称所有可行解中可以使目标函数达到最大值的可行解为<strong>最优解</strong></p><p>线性规划问题的求解，最关键的步骤其实是如何把具体的问题抽象成一个线性规划问题。实际建模的时候，一般不会出现像上面这样如此明显的问法。此外第二个问题就是决策变量的选择。</p><h2 id="3-线性规划的变形"><a href="#3-线性规划的变形" class="headerlink" title="3. 线性规划的变形"></a>3. 线性规划的变形</h2><p>上面说到，线性规划问题的难度不在于求解，而在于将问题转变为一个线性规划问题。因此下面介绍一些常见的线性规划问题的变形</p><h3 id="A-非线性目标函数——换元"><a href="#A-非线性目标函数——换元" class="headerlink" title="A. 非线性目标函数——换元"></a>A. 非线性目标函数——换元</h3><p>在一些情况下，目标函数虽然不是线性的，但是可以通过换元的方法实现转换。例如下面的线性规划模型</p><script type="math/tex; mode=display">\max_{x_1, x_2, \cdots, x_n} z = |x_1| + |x_2| + \cdots + |x_n|\\\begin {cases}a_1 x_1 + a_2x_2 + \cdots + a_nx_n &\leq & a\\b_1 x_1 + b_2x_2 + \cdots + b_nx_n &= & b\end {cases}</script><p>为此，设$x_i=u_i-v_i$,，$|x_i|=u_i+v_i$，则上面的线性规划模型变为</p><script type="math/tex; mode=display">\max_{u_1, \cdots, u_n; v_1, \cdots, v_n} z = (u_1+\cdots u_n) + (v_1\cdots v_n)\\\begin {cases}(a_1 u_1 + \cdots + a_nu_n) - (a_1 v_1 + \cdots + a_nv_n) &\leq & a\\(b_1 u_1 + \cdots + b_nu_n) - (b_1 v_1 + \cdots + b_nv_n) &= & b\\u1+v_1,\ \ \  \cdots,\ \ \  u_n+v_n &> &0\end {cases}</script><p>则转化为一个标准的线性规划问题</p><h2 id="4-线性规划问题的公式化-向量化"><a href="#4-线性规划问题的公式化-向量化" class="headerlink" title="4. 线性规划问题的公式化/向量化"></a>4. 线性规划问题的公式化/向量化</h2><p>对线性规划问题进行向量化（表达成矩阵形式）之后，我们能够进一步的利用各种数学工具对其进行求解。</p><p>对于决策变量，用一个列向量表示$\vec x=[x_1, x_2, \cdots，x_n]^T$；由于目标变量可能有多个，因此也用一个向量表示目标向量$\vec c=[c_1, c_2,\cdots, c_n]$。则目标函数的系数可以用一个矩阵$C$来表示:</p><script type="math/tex; mode=display">\begin {aligned}\vec c &= C^T \times \vec x \\& = \begin {bmatrix}c_{11} & c_{12} & \cdots & c_{1n}\\c_{21} & c_{22} & \cdots & c_{2n}\\\vdots & \vdots & \ddots & \vdots\\c_{n1} & c_{n2} & \cdots & c_{nn}\end {bmatrix} \times \vec x\end{aligned}</script><p>接下来对约束条件进行向量化。约束条件其实可以分为三类，第一类是$\leq$类型的（即$A\vec x\leq \vec b$），第二类是$=$类型的（即$A_{eq}\vec x\leq b_{eq}$），第三类是约定变量范围的（即$\vec{lb}\leq\vec x \leq\vec{ub}$）</p><p>因此，整个线性规划问题的向量形式（标准形式）如下：</p><script type="math/tex; mode=display">\max_{\vec x} \vec z = C^T \vec x\\\begin {cases}A\vec x &\leq &\vec b\\A_{eq} \vec x & = & \vec b_{eq}\\\vec {lb} &\leq &\vec x &\leq &\vec {ub}\end {cases}</script><p>因此，稍后用程序求解线性规划问题的时候，所需要的变量就是：$\vec C$、$\vec A$、$\vec b$、$\vec A_{eq}$、$\vec b_{eq}$、$\vec {lb}$、$\vec {ub}$</p><h2 id="5-线性规划Python求解"><a href="#5-线性规划Python求解" class="headerlink" title="5. 线性规划Python求解"></a>5. 线性规划Python求解</h2><p>对于线性规划问题，对其求解办法的研究和利用线性规划求解问题是两回事。对于数学建模来说，我们其实只需要利用线性规划去求解问题即可，并不需要花费很多的时间在研究线性规划求解方法的学习上，毕竟求解线性规划问题的算法已经有很多了。其实不仅仅对于线性规划，后面讲解的诸多问题，我们只需要掌握求解方法即可，而不用过分深入求解原理。</p><p>Python中使用<code>scipy</code>库中的<code>optimize</code>模块中的<code>linprog</code>函数求解</p><p>注：以下内容参考<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html">scipy官方的linprog文档</a>（<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html）">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html）</a></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101191341829.png" alt="SciPy的官方文档" style="zoom:50%;"></p><p>可以看到，对于 $\leq$类型，SciPy的变量名是ub（upper bound），$=$则是eq，范围则是$bounds$</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101191536675.png" alt="需要用到的参数" style="zoom:50%;"></p><p>需要注意的就是bounds的格式，bounds是一个元组对的列表，第一个元素是下限，第二个元素是上限，若没有上限/下限则为None。</p><p>此外，由于约束条件中不一定三种类型都有，因此如果没有的话指定为None即可</p><p>最后的返回值是 scipy.optimize.OptimizeResult对象，可用的属性如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101192003430.png" alt="返回对象的属性" style="zoom: 67%;"></p><p>需要注意的是，返回的最优结果是最小值，因此我们如果要求最大值要给$C$矩阵取反</p><p>下面给出一个例子</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101195241900.png" alt="线性规划求解的例子"></p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport scipy.optimizeimport scipy.optimize as scoptc = np.array([-2, -3, 5])A = np.array([-2, 5, -1, 1, 3, 1]).reshape(2, -1)b = np.array([-10, 12])A_eq = np.ones(shape=(1, 3))B_eq = 7bounds = [[0, None], [0, None], [0, None]]result: scipy.optimize.OptimizeResult = scopt.linprog(c=c, A_ub=A, b_ub=b, A_eq=A_eq, b_eq=B_eq, bounds=bounds)print(f"min value of z: {result.fun}")print(f"corresponding xs: {result.x}")print()print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101193044389.png" alt="运行结果"></p><h2 id="6-线性规划建模例子"><a href="#6-线性规划建模例子" class="headerlink" title="6. 线性规划建模例子"></a>6. 线性规划建模例子</h2><p>最后以一个mini-数学建模的例子来结尾，这个例子就是使用线性规划求解的。</p><h3 id="A-最优投资问题"><a href="#A-最优投资问题" class="headerlink" title="A. 最优投资问题"></a>A. 最优投资问题</h3><p>​    市场上有$n$种资产$s_i,\ i=1, 2, \cdots ,n$可以选择。现用数额为$M$的资金来进行一个时期的投资。在这一时期内购买资产$s_i$的平均收益率为$r_i$，风险损失率为$q_i$。此外，投资越分散，总的风险越少，而总风险可用所有购买的资产的风险中的最大的一个风险来度量。</p><p>​    购买资产$s_i$时要付交易费，费率为$p_i$;，当购买额不超过给定值$u_i$（$M\gg u_i$）时，交易费率按购买额为$u_i$计算。另外，假定同期银行存款利率是$r_0$，存银行既无交易费又无风险（设$r_0= 5%$）。</p><p>​    n= 4时相关数据如下表。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101195640092.png" alt="表1.1" style="zoom:50%;"></p><p>​    试给该公司设计一种投资组合方案，即用给定资金$M$，有选择地购买若干种资产或存银行生息，使净收益尽可能大，使总体风险尽可能小。 </p><h3 id="B-符号规定"><a href="#B-符号规定" class="headerlink" title="B. 符号规定"></a>B. 符号规定</h3><p>对问题做出如下的符号规定</p><ul><li>设$s_i$表示第$i$种投资项目，如股票、债券等。则$i=0, 1, 2, \cdots, n$，其中$s_0$表示存入银行</li><li>$r_i$， $p_i$， $q_i$分别表示资产$s_i$的平均收益、交易费率以及风险损失，其中$r_0=0.05$，$p_0=0$，$q_0=0$</li><li>$u_i$表示交易$s_i$时候的费率</li><li>$x_i$表示投资$s_i$的金额</li><li>$a$表示投资的总风险</li><li>$Q$表示总收益</li></ul><h3 id="C-基本假设"><a href="#C-基本假设" class="headerlink" title="C. 基本假设"></a>C. 基本假设</h3><ol><li>为便于计算，假设$M=1$</li><li>投资越分散，总风险越小</li><li>总风险用购买的$s_i$中最大的一项描述</li><li>$n+1$种资产$s_i$之间的风险$q_i$是独立的</li><li>在投资期间内，$r_i$，$p_i$，$q_i$保持为定值，不受外界因素影响</li><li>净收益和总体风险只受$r_i$，$p_i$，$q_i$影响，不受其他因素影响</li></ol><h3 id="D-模型分析与建立"><a href="#D-模型分析与建立" class="headerlink" title="D. 模型分析与建立"></a>D. 模型分析与建立</h3><p>模型的总风险即指投资组可能的损失，因此</p><script type="math/tex; mode=display">a=\max\{q_ix_i| i=1,\cdots,n\}</script><p>此外，进行交易的时候购买资产<code>s_i</code>所指出的交易费用为一分段函数</p><script type="math/tex; mode=display">\begin {cases}p_i u_i, & x_i \leq u_i\\p_i x_i, & x_i \ge u_i\end {cases}</script><p>考虑到购买资产$s_i$时候的收益$r_i$，且$M\gg u_i$，则购买资产$s_i$产生的净收益为</p><script type="math/tex; mode=display">Q_i=(r_i-p_i)x_i</script><p>目标是使收益尽可能大，同时风险尽可能小，因此是一个多目标规划的模型，优化目标如下</p><script type="math/tex; mode=display">\begin {cases}\max (\sum_{i=0}^n (r_i-p_i)x_i)\\\min \max ({q_ix_i})\end {cases}</script><p>约束条件为</p><script type="math/tex; mode=display">\begin{cases}\sum_{i=0}^n (1+p_i)x_i = M, & i=0, \cdots,n\\x_i \ge 0, & i=0,\cdots,n\end{cases}</script><p>考虑到不同投资者在投资时的偏好不同，因此有如下三类模型：</p><h4 id="1-模型一：固定风险，优化收益"><a href="#1-模型一：固定风险，优化收益" class="headerlink" title="1. 模型一：固定风险，优化收益"></a>1. 模型一：固定风险，优化收益</h4><p>设投资损失的上界$l$作为投资者能够承担的最大单笔损失比例，则投资者的损失比例$\frac{q_ix_i}{M}\leq l$</p><p>此时，在加强的约束下，模型退化为</p><script type="math/tex; mode=display">\max_{x_0,\cdots,x_n}\sum_{i=0}^n(r_i-p_i)x_i\\\begin{cases}\frac{q_ix_i}{M} \leq l\\\sum_{i=0}^n(1+p_i)x_i=M, & i=0,\cdots, n\\x_i \ge0, & i=0,\cdots,n\end{cases}</script><h4 id="2-模型二：固定收益，最小化风险"><a href="#2-模型二：固定收益，最小化风险" class="headerlink" title="2. 模型二：固定收益，最小化风险"></a>2. 模型二：固定收益，最小化风险</h4><p>设投资者的收益固定为$k$，则模型退化为</p><script type="math/tex; mode=display">\min\max{q_ix_i}\\\begin {cases}\max (\sum_{i=0}^n (r_i-p_i)x_i \ge k\\\sum_{i=0}^n(1+p_i)x_i=M, & i=0,\cdots, n\\x_i \ge0, & i=0,\cdots,n\end{cases}</script><h4 id="3-模型三：收益与风险平衡"><a href="#3-模型三：收益与风险平衡" class="headerlink" title="3. 模型三：收益与风险平衡"></a>3. 模型三：收益与风险平衡</h4><p>投资者在权衡风险和收益的时候，不同的投资者会有不同的偏好，因此对风险和收益赋予权重$s$，称为投资偏好系数。则此时模型为</p><script type="math/tex; mode=display">\min(s\cdot \max{q_ix_i}-(1-s)\cdot\sum_{i=0}^n(r_i-p_i)x_i)\\\begin {cases}0\leq s\leq 1\\\sum_{i=0}^n(1+p_i)x_i=M, & i=0,\cdots, n\\x_i \ge0, & i=0,\cdots,n\end{cases}</script><h3 id="E-模型求解"><a href="#E-模型求解" class="headerlink" title="E. 模型求解"></a>E. 模型求解</h3><p>下面针对上述三个模型进行求解</p><h4 id="A-模型一"><a href="#A-模型一" class="headerlink" title="A. 模型一"></a>A. 模型一</h4><p>注意第一个约束条件是两个向量的哈达马积</p><script type="math/tex; mode=display">\min_{[x_0,\cdots,x_n]} -[0.05, 0.27, 0.19, 0.185, 0.185][x_0, x_1, x_2, x_3, x_4, x_5]^T\\\begin{cases}\max [0, 0.025 0.015 0.055, 0.026][x_0, x_1, x_2, x_3, x_4, x_5] \leq l\\[1, 1.01, 1.02, 1.045, 1.065][x_0, x_1, x_2, x_3, x_4, x_5]^T=1\\x_0, x_1, x_2, x_3, x_4 \ge0\end{cases}</script><p>$l$为求解时候变量，因此对其进行搜索，从$l$从0~0.05，即损失本金的5%</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport matplotlibimport matplotlib.pyplot as pltimport scipy.optimize as scoptimfrom typing import *r = np.array([5, 28, 21, 23, 25], dtype=float) * 0.01q = np.array([0., 2.5, 1.5, 5.5, 2.6], dtype=float) * 0.01p = np.array([0., 1, 2, 4.5, 6.5], dtype=float) * 0.01def model1():    global r, p, q    c = -(r - p)    A_eq = (1 + p).reshape(1, -1)    b_eq = 1    A_ub = np.repeat(q.reshape(1, -1), repeats=5, axis=0) * np.eye(N=5)    bounds = [(0, None)] * 5    results: List[scoptim.OptimizeResult] = []    for i in (x := np.arange(start=0, stop=0.05, step=1e-3)):        b_ub = np.ones(shape=5) * i        results.append(scoptim.linprog(c=c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds))    plt.plot(x, [-1 * x.fun for x in results], "o-", label="max profit - risk")    plt.xlabel("risk")    plt.ylabel("profit")    plt.legend()    plt.show()if __name__ == "__main__":    print(model1())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101224009040.png" alt="Results"></p><p>可以看出来：</p><ul><li>风险越大，收益越大，损失本金的5%最高可以达到超过本金25%的收益</li><li>在当前五种投资资产中，收益——风险曲线最终收敛到0.25左右，意味着当前投资策略的潜力如此</li><li>$l=0.006$附近有一个转折点，转折点左侧风险增加缓慢但是收益增加显著，而右侧则风险增加很多并且收益增加不多（5%的额外收益）。所以对于风险和收益没有特殊偏好的投资者来说，应该选择曲线的转折点作为最优投资组合，大约是$l=0.6%，Q=20%$，所对应投资方案为 风险度$u=0.006$，收益$Q=0.2019$，$x_0=0$，$x_1=0.24$，$x_2=0.4$，$x_3=0.1091$，$x_4=0.2212$。</li></ul><h4 id="B-模型二、三"><a href="#B-模型二、三" class="headerlink" title="B. 模型二、三"></a>B. 模型二、三</h4><script type="math/tex; mode=display">\min\max{[0, 0.025 0.015 0.055, 0.026][x_0, x_1, x_2, x_3, x_4, x_5]}\\\begin {cases} [0.05, 0.27, 0.19, 0.185, 0.185][x_0, x_1, x_2, x_3, x_4, x_5]^T \ge k\\[1, 1.01, 1.02, 1.045, 1.065][x_0, x_1, x_2, x_3, x_4, x_5]^T=1\\x_0, x_1, x_2, x_3, x_4 \ge0\end{cases}</script><p>模型二和模型三其实有一个问题，就是目标函数不是一个线性的，因为存在去max这一步，所以实际上是一个分段函数这是由于取最大风险的才导致的不连续。所以这里就不给出解答了。如果想要做出来的话，改一下目标函数</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 线性规划 </tag>
            
            <tag> Linear Programming </tag>
            
            <tag> Math Modeling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概念读书笔记-第一章：介绍-3</title>
      <link href="/2022/01/01/cao-zuo-xi-tong-gai-nian-du-shu-bi-ji-di-yi-zhang-jie-shao-3/"/>
      <url>/2022/01/01/cao-zuo-xi-tong-gai-nian-du-shu-bi-ji-di-yi-zhang-jie-shao-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《操作系统概念（第九版）》的第一章的读书笔记第三部分，主要介绍了操作系统的任务。</p><p>This blog is the second part of reading notes of  _Operating System Concepts (Ninth Edition)_ chapter 1: Introduction, which tells  the main task of Operating System.</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228175748055.png" alt="Chapter 1: Introduction"></p><h2 id="Operating-System-Concepts-Chapter-1-Introduction-3-Main-Tasks-of-Operating-System"><a href="#Operating-System-Concepts-Chapter-1-Introduction-3-Main-Tasks-of-Operating-System" class="headerlink" title="Operating System Concepts-Chapter 1: Introduction-3 Main Tasks of Operating System"></a>Operating System Concepts-Chapter 1: Introduction-3 Main Tasks of Operating System</h2><p>操作系统概念第一部分是Overview，包括第一章和第二章。</p><p>本章主要介绍了操作系统中一些基本概念和操作系统的发展历史/操作系统的种类，以及操作系统的任务。本章的第三部分主要讲解了操作系统的主要任务</p><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><p>从宏观的角度来说，操作系统的任务主要有以下几个：</p><ul><li>进程管理（Process Management）</li><li>内存管理（Memory Management）</li><li>文件管理（File Management）</li><li>设备管理（Device Management）</li></ul><p>因此，如果把操作系统当做人的话，操作系统就是一个多面手：</p><ul><li>进程管理员</li><li>内存管理员</li><li>文件管理员</li><li>设备管理员</li></ul><p>实际上，上面四个任务之间是需要相互配合、沟通的。例如进程的调度问题，就需要内存管理和进程管理；而文件管理由于文件会保存在磁盘上的，因此还需要设备管理的配合。</p><p>当然，以上的四个部分是作为操作系统的基石的，而操作系统是需要被用户所使用的，因此需要操作系统为用户提供一个<strong>用户命令界面（User Command Interface）</strong>以让用户使用操作系统。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101105618888.png" alt="image-20220101105618888" style="zoom:150%;"></p><p>下面就将详细的介绍这四个部分。</p><h2 id="2-Process-Management，进程管理"><a href="#2-Process-Management，进程管理" class="headerlink" title="2. Process Management，进程管理"></a>2. Process Management，进程管理</h2><p>通常而言，我们的程序写下来的时候，源代码是文本形式的文本文件，保存在磁盘上。而同样，我们用编译器把源代码编译为二进制可执行程序后，程序的内容从文本变成了二进制的指令，但是依旧保存在磁盘上。</p><p>我们运行程序的时候，首先需要把磁盘上的包含二进制指令的可执行程序从磁盘读入内存（因为磁盘太慢了），而后CPU执行程序的时候直接从内存中读取程序（的指令），运行即可。</p><p>因此，通常称在内存中的程序为<strong>进程（Process）</strong>。进程实际上就是正在执行的程序，是程序的的动态的程序实体。而保存在磁盘上的程序则是静态的程序实体。</p><p>一个进程实际上是CPU指令序列，此外进程在被CPU执行的时候还可能会需要其他的资源，例如某个文件中的数据、输出结果到某个文件，因此的<strong>一个进程如果想要完成其工作，就需要各种各样的资源</strong>：</p><ul><li>CPU、内存资源、I/O资源、文件资源</li><li>初始化数据</li></ul><p>计算机系统中的资源往往具有不可复制性，例如CPU只有一个，某个文件在磁盘中也只有一份。因此一个进程结束（Terminate）的时候需要释放（reclaim）所有的资源。</p><p>此外，CPU在某一个时间点只能运行一条指令，因此CPU中需要有一个寄存器，专门存储下一条指令在内存中的位置，这个寄存器叫做程序计数器（Program Counter，PC）或者指令指针（Instruction Pointer，IP）。</p><p>此外，由于现代的进程支持多线程，而每个线程在逻辑上都是独立的指令序列，因此多线程的程序中每个线程都会有自己的PC，而单线程的程序中只有一个PC。</p><p>通常来说，一个典型的操作系统系统会有非常多的进程，（例如我们通过htop命令看到的，目前系统中一共有204个进程，777个线程（但是注意，正在运行的进程很少，我截图的时候只有六个））、一些用户。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101113559220.png" alt="htop命令的输出"></p><p>因此，当我们说到操作系统的进程管理的时候，通常指代下面的一些操作系统需要完成的任务：</p><ul><li>创建和删除用户、系统进程</li><li>挂起和恢复进程（包括进程的调度）</li><li>提供进程间同步的机制</li><li>提供进程间通信的机制</li><li>提供死锁的处理机制</li></ul><p>因此，在后面的章节中，我们在进程管理部分就会介绍操作系统是如何完成上述任务的。</p><h2 id="3-Memory-Management，内存管理"><a href="#3-Memory-Management，内存管理" class="headerlink" title="3. Memory Management，内存管理"></a>3. Memory Management，内存管理</h2><p>我们在本章的前面部分介绍过，需要使用内存的原因是由于磁盘太慢了，让CPU直接从磁盘中读取指令会浪费大量的时间，因此在磁盘和CPU中添加了一个内存。</p><p>因此，CPU在执行进程的时候需要的所有的数据都是保存在内存中的，所有即将执行的指令也是都在内存中的。</p><p>然而，一个问题就是内存的大小是有限制的，那么就需要决定哪些进程在内存中，那些程序不在。此外，若某个需要运行的程序需要的内存大于剩余的内存怎么办？这些都是内存管理需要解决的问题。</p><p>因此，内存管理的任务如下：</p><ul><li>对内存块进行追踪，明确这块内存块当前正在被那个进程使用</li><li>决定哪个进程要被移入内存，哪个要被移出</li><li>根据需要对内存进行分配和释放</li></ul><p>查看proc下的meminfo文件，其中记录着系统当前的内存配置信息</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">cat /proc/meminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101135344831.png" alt="系统当前的内存配置信息"></p><h2 id="4-Storage-Management，存储管理"><a href="#4-Storage-Management，存储管理" class="headerlink" title="4. Storage Management，存储管理"></a>4. Storage Management，存储管理</h2><p>前面所说的内存是易失性的，因此为了能够将文件等数据永久的保存下来，我们需要将文件保存到存储器上。</p><p>如果没有操作系统的话，把文件保存到磁盘上将会是意见非常累的事情，因为我们需要自己动手写汇编语言，和磁盘的控制器进行交互。</p><p>然而，操作的任务就是向下沟通硬件，向上为用户提供服务。因此操作系统就需要对存储器进行管理，为用户提供存储器的统一的逻辑上的视图，即文件和目录。文件和目录这两个逻辑上的概念就是操作系统为我们提供的存储器在逻辑上的视图。通过这两个概念，我们很少会直接直接触到存储器。针对这个概念，操作系统还维护了保存、修改等操作；还有谁能阅读、谁能修改等权限。</p><p>此外，由于存储器的不同，因此还会一些问题：</p><ul><li>不同类型的存储器的访问速度不同，例如固态、机器、磁带</li><li>不同类型的存储器容量也不同、传输速率不同、访问方式也不同（有的可以随机访问，有的只能顺序访问，比如磁带只能顺序访问而固态/机械可以随机访问）</li></ul><p>这些差异都被操作系统给屏蔽了，我们在创建、保存文件并不会考虑到这些差异。</p><p>因此，操作系统的存储管理包括以下内容：</p><ul><li><strong>文件和目录的创建</strong>：文件的组织与管理，即文件、目录在一起构成的文件系统</li><li><strong>文件的权限管理</strong>：对文件的访问控制，即谁能读取文件、谁能修改</li></ul><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> Operating System Concepts Reading Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Operating System </tag>
            
            <tag> Reading Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概念读书笔记-第一章：介绍-2 操作系统的分类/历史</title>
      <link href="/2021/12/30/cao-zuo-xi-tong-gai-nian-du-shu-bi-ji-di-yi-zhang-jie-shao-2/"/>
      <url>/2021/12/30/cao-zuo-xi-tong-gai-nian-du-shu-bi-ji-di-yi-zhang-jie-shao-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《操作系统概念（第九版）》的第一章的读书笔记第二部分，主要介绍了操作系统的历史/分类。</p><p>This blog is the second part of reading notes of  _Operating System Concepts (Ninth Edition)_ chapter 1: Introduction, which tells  the histroy/types of Operating System</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228175748055.png" alt="Chapter 1: Introduction"></p><h1 id="Operating-System-Concepts-Chapter-1-Introduction-2-Histroy-Types-of-Operating-System"><a href="#Operating-System-Concepts-Chapter-1-Introduction-2-Histroy-Types-of-Operating-System" class="headerlink" title="Operating System Concepts-Chapter 1: Introduction-2 Histroy/Types of Operating System"></a>Operating System Concepts-Chapter 1: Introduction-2 Histroy/Types of Operating System</h1><p>操作系统概念第一部分是Overview，包括第一章和第二章。</p><p>本章主要介绍了操作系统中一些基本概念和操作系统的发展历史/操作系统的种类，以及操作系统的任务。本章的第二部分主要讲解了操作系统的发展历史/操作系统的分类。</p><p>注：本章部分内容参考《现代操作系统》(Modern Operating System)</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230175913496.png" alt="现代操作系统" style="zoom:50%;"></p><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h2><p>操作系统不仅仅是作为学术界的研究内容，其更加是产业界的产品，和用户紧密贴合。因此操作系统是随着时代在发展的。</p><p>总的来说，操作系统的发展是和计算机硬件的发展分不开的，因此伴随着计算机硬件的发展，操作系统的发展经历了以下几个阶段：</p><ul><li>1945-1955：第一代，真空管</li><li>1955-1965：第二代，晶体管</li><li>1965-1980：第三代，集成电路和多道程序设计</li><li>1980-现在：个人电脑</li><li>1990-现在：移动电脑（手机）</li></ul><p>在这些阶段中，出现了下面几种类型的操作系统</p><ul><li><strong>批处理系统（Simple Batch processing system）</strong></li><li><strong>多道程序系统（Multiplied Batch processing system）</strong></li><li><strong>分时系统（Time-sharing system）</strong></li><li><strong>实时系统（Real time system）</strong></li><li><strong>网络操作系统（Network operating system）</strong></li><li><strong>平行系统（Parallel Systems）</strong></li><li><strong>分布式系统（Distributed system）</strong></li></ul><h2 id="2-操作系统的历史"><a href="#2-操作系统的历史" class="headerlink" title="2. 操作系统的历史"></a>2. 操作系统的历史</h2><p>下面我们将回顾计算机的发展历史，并且伴随着计算机的发展穿插讲解同一时代的操作系统，以期望能够给读者一个操作系统的宏观发展史。在后面的操作系统的种类不分，将会对出现在历史上的各类操作系统进行详细的讲解</p><h3 id="A-第一代（1945-1955）：真空管和穿孔卡片"><a href="#A-第一代（1945-1955）：真空管和穿孔卡片" class="headerlink" title="A. 第一代（1945-1955）：真空管和穿孔卡片"></a>A. 第一代（1945-1955）：真空管和穿孔卡片</h3><p>第二次世界大战推动了计算机的发展，正如我们所熟知的，计算机（ENIAC）最早是为了计算炮弹的下落轨迹的。军事的发展在早期极大的推动了计算机发展。和ENIAC同时代的，还有许多计算机。例如，1944年阿兰·图灵等人在英国的因格兰建造了Colossus计算机，并在这台计算机上进行编程；Howard Aiken在哈佛大学建造了Mark I计算机；宾夕法尼亚大学的William Mauchley和他的学生J. Presper Eckert建造了ENIAC……</p><p>在这个时候，计算机的作用仅仅是用来进行复杂的数学运算，人们所做的是按照预先的设计，把电线连好，然后启动计算机，祈祷机器在两个小时后真空电子管不会烧掉并且能够给出正确的答案。在这个时候根本没有编程语言的概念，操作系统就更加无从说起了。这个时候的计算机也非常原始，很多计算机都是无法编程的，或者干脆就是用0101的机器语言编写的，之所以用机器语言编写，是因为它符合电路的通断，因此很容易就能够把写好的”代码”转换为电路的通断。</p><p>一直直到1950年以后，这个情况才稍微边的好一点了，读卡机的出现使得操作者可以提前把代码写在卡片上，然后计算机从卡片中读取程序，然后进行计算</p><h3 id="B-第二代（1955-1965）：晶体管和批处理系统"><a href="#B-第二代（1955-1965）：晶体管和批处理系统" class="headerlink" title="B. 第二代（1955-1965）：晶体管和批处理系统"></a>B. 第二代（1955-1965）：晶体管和批处理系统</h3><p>20世纪50年代，晶体管的发明极大地推动了计算机的发展，先前的计算机使用的真空管如果漏气就会被烧掉，因此稳定性不是很好，而晶体管的发明计算机已经边的非常有用，并且能够完成一些有用的任务。晶体管没有玻璃管壳，不需要真空，体积很小，生产成本很低，寿命比电子管长得多。因此，晶体管一问世，立即得到迅速发展且取代了电子管的位置。</p><p>这个时候的电脑现在被称为<strong>大型机（mainframe）</strong>，通常被锁在有专用空调的大房间中，由专业人员进行操作。因此其售价非常高昂，通常达到几百万美元。只有企业、重要的政府部门以及大学才可能接受并购买。</p><p>这个时候已经出现了编程语言的概念，有Fortran或者汇编语言，但是依旧没有操作系统的概念。这个时候的程序被称为<strong>作业（job）</strong>。程序可以通过<strong>穿孔卡片（Punched card）</strong>写在纸上，然后被计算机读入。</p><p><img src="http://pansci.asia/wp-content/uploads/2020/08/e4592ed6287a7d6c606f0856491ffaeb-560x251.jpg" alt="穿孔卡片"></p><blockquote><p>穿孔卡片如何表示数据？</p><p><strong>From Wikipedia</strong></p><p>1928年，IBM发明的80列、矩形孔卡片，成为事实上的标准。其工作原理如下：编号为0至9，总计10行；以及一块区域，用于第11、第12行（注意，没有编号为第10的行）。</p><p>每列的穿孔组合用于表示单个字符：</p><ul><li>数字通过在行0至行9直接打1个孔来表示。</li><li>空格符的表示，不需要打孔。</li><li>字母用2个孔表示：一个孔在第11、第12、第0行；另一个孔在第1至第9行。字母表被依次分为由9个字母组成的区（zones），每个区的字母依次在第1至第9行打孔。每个区分别在第11、第12、第0行打孔。第3区第1个字符保留未使用。</li><li>一些特殊字符使用了额外的单孔表示，或者双孔表示。</li><li>大多数特殊字符（如标点符号等）用3孔表示：第8行被穿孔；第0、第11、第12行有1个穿孔；第1到第7行有1个穿孔。第9行保留未使用。</li></ul></blockquote><p>用户提前编写好程序（以Fortran语言为例），然被送入计算机中，计算机中的Fortran编译器对读入的源程序进行编译编译，编译完成后得到编译好的程序。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/ae51f3deb48f8c54ef67e8a63a292df5e1fe7f86" alt="穿孔机器"></p><p>接下来计算机载入编译后的程序，然后读取数据进行运算，得到结果。最后将结果再通过打印机打印到纸上。因此一个典型的作业的卡片组如下图。首先是JOB卡片，表明用户的扣款账号，最大的运行时间（分钟）以及程序员。接下来是Fortran卡片，通知计算机把Fortran编译器从系统磁带上载入，接下来对后面程序员提前写好的Fortran程序进行编译。编译结束之后Load卡片通知计算机丢弃掉先前载入的Fortran编译器，载入编译好的程序。接下来Run卡片让程序开始运行，并以后面卡片上的数据作为输入。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230220709362.png" alt="典型的作业卡片组"></p><p>这个时候尽管有了程序的概念（虽然被称为工作），但是依然没有现在的操作系统的概念，程序的运行是直接把程序从卡片读入计算机内部，然后开始运行。因此，在同一个时间点内，计算机只能运行一个程序，并不会存在现代的调度、中断这些用来实现并行的概念。</p><p>此外，正式由于这个时候的计算机非常昂贵，因此人们就想办法尽量提高计算机的利用率，即减少计算机的机时浪费。为此就产生了<strong>批处理系统（Batch System）</strong>。批处理系统的核心思想就是首先用一台便宜的机器从穿孔卡片中读取程序，然后把程序写入到磁带上，接下来用昂贵的计算机来直接从磁带中读取程序，然后进行运算。例如用便宜的IBM 1401完成从卡片中读取、写入到磁带，计算发生在昂贵的IBM 7904上。</p><blockquote><p>之所以还需要使用穿孔卡片的原因在于在那个时候还没有键盘、鼠标这类便捷的输入设备，唯一对人类友好的输入方式就是穿孔卡片。而让人类直接读写磁带显然不可能。</p></blockquote><p>因此对于<strong>批处理系统</strong>，一个典型的工作流程就是IBM 1401首先读取穿孔卡片两个小时，并把两个小时内读取到的程序全部输出到磁带上。接下来，操作员把磁带送到IBM 7904上，IBM 7904会依次读取磁带中的程序，进行计算，最后把计算结果输出到一个磁带上去，最后再用一个IBM 1401负责读取磁带中的结果，并打印到纸上。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230220236208.png" alt="批处理系统的工作流程"></p><p>第二代的大型机主要用于科学与工程计算，例如解微分方程。</p><p>此外，由于第二代计算机并不存在现代意义上的操作系统，当时的操作系统仅仅是包含编译器在内的一套软件，在存储器（磁带）中，系统和用户程序是相邻的</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101010010089.png" alt="Memory Layout"></p><h3 id="C-第三代（1965-1980）：集成电路和多道程序设计"><a href="#C-第三代（1965-1980）：集成电路和多道程序设计" class="headerlink" title="C. 第三代（1965-1980）：集成电路和多道程序设计"></a>C. 第三代（1965-1980）：集成电路和多道程序设计</h3><p>相比于第二代计算机，第三代计算机的一个进步就是在计算机中采用了（小规模的）集成电路(Integrated Circuit，IC)。因此计算机的性能得到了巨大的提升。此外，第三代计算机的主存储器采用半导体，因而现代计算机中的内存/主存在此时出现。</p><p>在第三代计算机发展的初期，即1965年左右，这个时候每个计算机厂商需要维护两条产品线，一条是面向科学计算的大型机（mainframe），另外一条是面向文字处理的商用计算机（银行业、保险业、金融业），例如IBM 1401。</p><p>而维护两条生产线的代价是高昂的，因为厂商需要针对两种不同的设备维护相同的软件，但是却有两套不同的底层。另外一个问题就是同一条产品线的不同代的产品之间都不互相兼容。因此为了解决这个问题，在1964年，IBM推出了OS/360系统希望来屏蔽这个问题。OS/360系统搭载在System/360系列计算机上，尽管每代计算机都会有新的指令退出，OS/360都始终保持着兼容。这就意味着针对不同的硬件，OS/360都会提供支持，并对诸如Fortran编译器、文字处理程序提供支持。因此，<strong>OS/360代表着操作系统雏形的诞生，即向下沟通硬件、屏蔽硬件之间的差异，向上为程序提供资源/服务</strong>。</p><p>虽然后来OS/360变的越来越庞大，包含了数千个程序员写的百万行汇编代码，以至于维护越来越苦难，最终被放弃，System/360可以作为人类工程史上一项里程碑式的大型复杂软件系统而被记录。</p><p>除了屏蔽指令集的不同以外，OS/360的另外一大贡献就是开创了<strong>多道程序设计（multiprogramming）</strong>。</p><p>在第二代计算机中，计算机在一段时间内被一个作业独占，此时任何其他人都无法使用计算机。因此一个显著地问题就是计算机从卡片/磁带上读取/输出的时候会消耗很多时间，而这个时间段内当前作业仍然在占用计算机，因此CPU就会空转以等待这些I/O操作。对于科学计算这类CPU密集型的程序，一个作业85%的时间CPU在进行计算，而对于字符处理这些作业来说，CPU只有大概10~15%的时间在进行运算，其余时间在进行数据读写。</p><p>因此为了提高CPU的利用率，多道程序设计的核心思想在于当一个程序在进行I/O时，让另外一个程序使用CPU进行计算。</p><p>为了实现这样的技术，需要做的事情如下：</p><ul><li><p>首先需要把所有的程序都读入计算机中，即存储到内存中（System/360中可以存放15个作业）</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211231170111022.png" alt="OS/360存储所有的作业"></p></li><li><p>其次需要对内存中的每个作业进行保护，避免某个作业被当前作业错误的改写。</p><p>System/360，包括现在的计算机的做法是使用了两个特殊的变量，第一个变量指明当前程序的下界，而第二个变量指明当前程序的范围，这两个变量作为程序的一部分，储存在CPU上的两个寄存器中，即为了实现对程序的保护，需要有特殊的硬件。</p></li></ul><p>通过这样的设计，OS/360的CPU利用率接近100%。</p><p>在OS/360之后，就是<strong>分时系统（Time-sharing System）</strong>。OS/360实现的多道程序设计极大地提升了CPU的利用率，但是却缺乏和用户的交互，因为所有的程序都是用户事先指定的，在运行的过程中用户无法和系统进行交互。为了解决这个问题，就出现了分时系统。</p><p>分时系统的核心思想在于让机器以固定的时间间隔在多个程序之间轮转，而不需要等待直到程序进行I/O的时候再把CPU让出。从CPU的家督来说，分时系统其实是多道程序设计的一个变体。通过分时系统，就可以实现让五六个用户同时通过终端连接到计算机，并且运行自己的程序，而CPU则在每个程序之间轮流进行执行。由于轮转的速度非常快，一秒可以有几十次，因此在用户的角度来说仿佛没有发生过轮转。因此极大的提升了用户的体验。</p><p>进一步，出现了兼容分时系统（Compatible Time-Sharing System，CTSS）。兼容分时系统的意义在于当有用户运行他们的程序的时候，系统会运行用户的程序，而让用户没有运行程序的时候，系统就会运行在后台的大型程序（计算密集型程序，这个时候以及不太说作业了）。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211231170210172.png" alt="MIT开发的CTSS系统"></p><p>从分时系统开始，逐渐出现了程序之间的调度，由此产生了操作系统的第一个任务：进程调度（进程可以理解为作业的现代术语）。此外，由于程序（进程）需要保存在内存里，因此就出现了操作系统的第二个任务：内存管理。</p><p>在CTSS系统成功之后，进一步，人们希望研发一个系统，可以支持上百个分时用户通过终端，因此通用电气（GE）公司和MIT、贝尔实验室联合在一起，开发一个名为Multics（Multiiplexed Information and Computing Service）系统。虽然同样，Multics失败了，但是其进一步推动了操作系统的发展，推出了诸多原创性的思想。</p><p>最后，虽然Multics失败了，但是其把火种传播下去了，曾今参与Multics计划的贝尔实验室中的计算机科学家Ken Thompson在贝尔实验室中找到了一台没有人使用的计算机。为了使用这台计算机，他自己动手写了一个Multics的简化版系统。他的系统期初只在贝尔实验室中使用，慢慢的人们觉得这个系统越来越好用，因此也提出了越来越多的建议。慢慢的，在众人的帮助下基于Ken Thompson工作的新的系统Unix诞生了。</p><p>在起初，Unix系统是每个人都可以下载的，而且由于Unix的简单性，很多人都可以对Unix系统的源代码进行修改。因此，出现了很多Unix系统的修改版本，从而极大地推动了操作系统的发展。这些由Unix系统修改来的版本，在一起构成了Unix家族</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101041059718.png" alt="Unix系列系统"></p><h3 id="D-第四代（1980-至今）：个人计算机"><a href="#D-第四代（1980-至今）：个人计算机" class="headerlink" title="D. 第四代（1980-至今）：个人计算机"></a>D. 第四代（1980-至今）：个人计算机</h3><p>随着大规模集成电路（Large Scale Integrated Circuit）的发展，每平方厘米的硅片芯片上能够集成的晶体管的数量越来越多，因此，计算机的体积越来越小，个人计算机的时代到来了。</p><p>从计算机的体系结构看来，个人计算机（早期称为微型计算机）的结构和大型机没有大的区别。只是操作系统不同</p><p>个人计算机的发展可以追溯到Intel推出第一代小型、通用的CPU。在Intel推出第一代通用八位CPU——Intel 8080时，此时市面上的操作系统都是为大型机编写的，因此尽管8080 CPU确实可用，但是却没有能够让用户使用这个CPU的操作系统。因此英特尔邀请了Gary Kildall为8080编写一套操作系统。为此，Gary Kildal编写了一套完全基于磁带的操作系统，称为<strong>CP/M（Control Program for Microcomputer）</strong>。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/96dda144ad345982b2b7f05339b826adcbef77092e94" alt="CP/M操作系统"></p><p>CP/M随着英特尔的8080而大获成功，甚至统治了个人计算机操作系统长达五年。</p><p>正式因为CP/M的巨大成功，IBM这个早期的专门做大型机的公司开始瞄准个人机市场后，咨询Kildal能否为IBM的个人机进行适配以支持IBM的个人电脑。Kildal拒绝了IBM。因此IBM别无办法，只能开发自己的操作系统。</p><p>当IBM正在寻找能够在IBM的PC上运行的操作系统的时候，Bill Gates出现了。Bill Gates了解到在西雅图有一家叫做Seattle Computer Products的公司制作出了一个DOS系统（Disk Operating System），于是出价75000美元买下了这个系统。在进行简单的修改之后，Gates把这个系统成套的卖给了IBM。随后在IBM的要求下，Gates对DOS进行了修改，修改版称为MS-DOS（MicroSoft Disk Operating System）。MS-DOS很快抢占了CP/M的市场，并且在个人电脑的操作系统中占据主导地位。</p><p>另外一段故事就是在1983年，Steve Jobs的Apple公司发布的具有GUI的Lisa计算机。其实在1960年代，斯坦福大学的Doug Engelbart加收就开发出了图形用户界面，包括窗口、图标、菜单以及鼠标。然而那个时候操作系统本身都还没有发展起来，因此这个超时代的创新并没有引起重视。后来图形用户界面的研究被Xerox PARC的研究员继续深入下去。Jobs在一次访问PARC的时候，看到了GUI的系统，意识到了GUI的巨大应用。于是在1983年的时候，Jobs的Apple公司发布了第一个带有GUI系统的计算机：Lisa。</p><p>不过由于过于昂贵，Lisa最终在商业上失败了，但是Lisa后来的改进版，Macintosh获得了巨大的成功。因为它使得社会大众可以不用专门的学习计算机技术而使用计算机。</p><p>随后，微软在看到Apple的Macintosh获得的巨大成功之后，开发了名为Windows的基于GUI的操作系统。在Windows的早期，Windows只是在MS-DOS的基础上多运行了一个GUI的环境。一直直到1995年，微软才制作了一个完全独立的Windows，MS-DOS虽然依旧在系统中，但是仅仅用于运行早期的MS-DOS系统上编写的程序。</p><h3 id="E-第五代（1990-至今）：移动计算机"><a href="#E-第五代（1990-至今）：移动计算机" class="headerlink" title="E. 第五代（1990-至今）：移动计算机"></a>E. 第五代（1990-至今）：移动计算机</h3><p>第一台手持电话出现在1970年左右，大概两公斤，即当时在港台影片上看到的大哥大</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/1ad5ad6eddc451dab4bd9a1eb6fd5266d11632ff" alt="老式大哥大"></p><p>后来随着大规模集成电路的发展，人们逐渐开始把计算机和电话结合起来，最终在90年代完成了这一摄设想。诺基亚发布的N9000真正做到了手机和电脑合二为一。进一步1997年爱立信公司的GS88手机发布的时候创造出了“智能手机”（SmartPhone）这一术语。</p><p>随着智能手机逐渐普及，智能手机上的各种操作系统间的竞争边的非常激烈。在最初的十年内，大多数手机都运行这Symbian OS。包括三星、索尼、爱立信、摩托罗达等等厂商在内，他们的手机在出场的时候就搭载了Symbian OS。除此以外，还有RIM公司的Blackberry OS。</p><p>然而，触屏技术的发展，新的支持触屏的系统迅速获得了市场，例如搭载iOS的iPhone的发布和Google的Android系统，成为移动计算机的巨头，统治了手机操作系统，直到今天。</p><h2 id="3-操作系统的种类"><a href="#3-操作系统的种类" class="headerlink" title="3. 操作系统的种类"></a>3. 操作系统的种类</h2><p>在前面，我们回顾了计算机的发展历史，并且伴随着计算机的发展穿插了各种操作系统。下面的内容将完全注重于操作系统，讲解各种类型的操作系统。</p><p>在讲解下面的系统前，我们首先需要明白，现代的操作系统主要有下面四大任务（下一篇文章会详细讲解）：</p><ul><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>设备管理</li></ul><h3 id="A-Simple-Batch-Processing-System，单道批处理操作系统"><a href="#A-Simple-Batch-Processing-System，单道批处理操作系统" class="headerlink" title="A. Simple Batch Processing System，单道批处理操作系统"></a>A. Simple Batch Processing System，单道批处理操作系统</h3><p>单道批处理在同一时间只能够运行一个程序（作业），并且在一个程序（作业）开始后，直到作业结束，系统都不会运行新的作业。而在一个作业从开始到结束的这段时间内，包括了作业的指令的读取事件、数据的读取事件、CPU的运算时间以及将结果输出的时间。因此正如前面所说，单道批处理操作系统会浪费大量的CPU时间。</p><p>但是相比于单道批处理操作系统之前的、由人工完成的一次把一个job的穿孔卡片放入、连接好电路而言，依旧节省了不少时间。</p><p>单道批处理系统的特点如下：</p><ul><li>减少相同任务的初始化时间</li><li>自动的Job队列——可以顺着队列依次执行Job</li><li>需要雇佣一个操作员（换卡片）</li><li>需要一个读卡器</li></ul><p>单道批处理系统的内存结构也非常简单，除了系统就是用户的程序</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101004315223.png" alt="单道批处理系统的内存结构"></p><p>一些单道批处理系统的例子如下：</p><ul><li>BM FMS（FORTRAN Monitor System），for IBM7094</li><li>IBM IBSYS，for IBM7090 and 7094</li><li>UM UMES，for IBM7094,1959</li><li>IBM JCL-related (job control language) systems.</li></ul><h3 id="B-Multiplied-Batch-Processing-System，多道批处理操作系统"><a href="#B-Multiplied-Batch-Processing-System，多道批处理操作系统" class="headerlink" title="B. Multiplied Batch Processing System，多道批处理操作系统"></a>B. Multiplied Batch Processing System，多道批处理操作系统</h3><p>多道批处理操作系统是对单道批处理操作系统的改进，主要目的是为了提高CPU的利用率。</p><p>多道批处理操作系统，重点在于<strong>多道（Multiprgramming）</strong>，而多道意味着：</p><ul><li>对于程序而言，CPU在各个程序之间轮转，执行指令；而对于CPU来说，程序以交错的的形式形成一条线被CPU依次执行</li><li>在程序进行I/O等操作（没有使用CPU）的时候，把CPU让给其他程序使用</li></ul><p>为此，支持多道程序的系统需要的特点如下：</p><ul><li><p>内存管理和保护，因为要把所有的程序首先读入然后储存，因此其内存存储结构如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101005524822.png" alt="支持多道程序系统的内存结构"></p></li><li><p>CPU调度，还包含上下文切换（寄存器内的值的改变）</p></li><li><p>资源共享：独占资源和同步资源，例如一个文件只能一个程序进行修改</p></li><li><p>设备分配</p></li></ul><p>知名的操作系统包括：IBM OS 360</p><h3 id="C-Time-Sharing-System，分时系统"><a href="#C-Time-Sharing-System，分时系统" class="headerlink" title="C. Time-Sharing System，分时系统"></a>C. Time-Sharing System，分时系统</h3><p>分时系统是多道批处理系统的变体，因此在很多地方和多道批处理系统是类似的：</p><ul><li>CPU在程序间轮转</li></ul><p>然而不同之处在于：</p><ul><li>分时系统要求系统与用户之间是可以进行交互的，因此当用户发出指令执行程序之后，用户执行的程序不能在被执行前等待过长的时间。因此，分是系统要求系统对用户响应必须要小于1秒</li></ul><p>此外，分时系统的一些特点如下：</p><ul><li>每个终端用户在内存中至少有一个程序（进程）</li><li>若多个程序都已经准备好运行（所有需要的资源都已经获得），系统具有调度CPU，决定那个程序可以获得CPU运行。</li><li>若进程太大，超过剩余的内存空间的话，操作系统就会通过将进程移入移出内存来最终运行程序（虚拟内存）</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101010616641.png" alt="典型的分时系统"></p><p>典型的分时系统如下：</p><ul><li>1961年MIT开发的CTSS，兼容分时系统</li><li>1964-1969年由MIT 、Bell Lab of AT&amp;T、DEC机构以PL/1语言开发的MULTICS</li><li>1970年由Bell Lab of AT&amp;T,  PDP 7等开发的UNIX</li></ul><h3 id="D-nix-Operating-Systems，-nix-系列操作系统"><a href="#D-nix-Operating-Systems，-nix-系列操作系统" class="headerlink" title="D. *nix Operating Systems，*nix 系列操作系统"></a>D. *nix Operating Systems，*nix 系列操作系统</h3><p>尽管<em>nix系列操作系统是分时系统的一种，但是由于、\</em>nix系列操作系统在操作系统历史上是不可逾越的，因此单独讲讲Unix系列操作系统。</p><p>Unix和Linux系列的操作系统是最具有影响力的操作系统，并且有除了Windows以外的最大的用户基数。由于源代码开源，因此有非常多的修改后的在发行版本，但是这些系统通常在后面会加上*nix表示是Unix/Linux的衍生版本，因此在一些语境下，说Unix/Linux系统的时候其实指代的是*nix系列系统。</p><p>起初，第一版可以使用的Unix是在贝尔实验室中开发的，开发语言包括C语言和汇编语言。C语言其实最初的目的是为了帮助Thompson开发Unix操作系统</p><p>而后，从Unix派生出来两大流派：</p><ul><li>由UC Berkely开发的BSD Unix系统，主要是为了科研使用。为了避免Unix的专利，BSD自己实现了Unix中的所有功能，并且没有参考AT&amp;T 的Unix的代码<ul><li>进一步，从BSD又发展出了Solaris系统，Solaris系统是BSD流派中安装最多的系统</li><li>此外，还有一个发行版是FreeBSD系统，也是一个安装比较多的系统</li><li>BSD系统对系统提出了一些标准，这些标准称为POSIX标准，而MacOS是从BSD系统中发展来的，因此也支持这套标准。</li></ul></li><li>又AT&amp;T开发的的System V（贝尔实验室后来被AT&amp;T收购了）</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101014233543.png" alt="Unix系统家谱"></p><h3 id="E-Real-time-System，实时操作系统"><a href="#E-Real-time-System，实时操作系统" class="headerlink" title="E. Real-time System，实时操作系统"></a>E. Real-time System，实时操作系统</h3><p>实时操作系统是一种特殊目的的操作系统，他属于分时操作系统，但是他强调任务的实时性，即程序需要及时的完成。</p><p>注意实时操作系统对时间的看重程度远超分时系统，因为他们通常用在金融记账、飞机控制、航天器控制中，因此1秒的差距都是不可忍受的。</p><p>为此实时操作系统为每个任务都设定了一个截止时间，任何任务（进程）都必须要在截止时间之前完成。其实严格的说，并不是所有实时操作系统都是这样的。</p><p>实时操作系统分为两类：</p><ul><li>硬实时操作系统，即一点超时都不能有的操作系统，任何的超时都意味着当前任务失败，需要重新进行</li><li>软实时操作系统，即偶尔的超时还是可以忍受的，但是尽量不要超时</li></ul><h3 id="F-Network-Operating-System，网络操作系统"><a href="#F-Network-Operating-System，网络操作系统" class="headerlink" title="F. Network Operating System，网络操作系统"></a>F. Network Operating System，网络操作系统</h3><p>网络操作系统即指具备网络能力的操作系统，关于网络主要在计算机网络中有所讲解，这里不会深入。</p><p>具体的网络能力指：</p><ul><li>网络通信</li><li>网络服务</li></ul><p>由于Unix允许用户写的程序可以和另外一台操作系统上的某个程序进行通信，因此Unix系列的操作系统就是网络操作系统，Windows和MacOS也是类似的</p><h3 id="G-Distributed-Systems，分布式系统"><a href="#G-Distributed-Systems，分布式系统" class="headerlink" title="G. Distributed Systems，分布式系统"></a>G. Distributed Systems，分布式系统</h3><p>分布式系统指操作系统是分布在网络中的计算机集群中。通过网络实现将多台物理上的计算机形成逻辑上的单台性能强大的计算机。</p><p>因此分布式系统内需要对共享的资源进行管理并且协调所有的组件（计算机）完成目标</p><p>知名的例子有：</p><ul><li>Client/server system</li><li>internet computing system（云服务器）</li></ul><p>分布式系统的优点如下：</p><ul><li>Resources sharing</li><li>Computation speed up – load sharing </li><li>Reliability</li><li>Communications</li></ul><h3 id="H-Parallel-Systems，平行系统"><a href="#H-Parallel-Systems，平行系统" class="headerlink" title="H. Parallel Systems，平行系统"></a>H. Parallel Systems，平行系统</h3><p>平行系统指具有多个CPU的操作系统，多个CPU之间是高度耦合的，他们会共享内存、时钟等等内容。</p><p>这类系统的好处如下：</p><ul><li>Increased throughput </li><li>Economical</li><li>Increased reliability</li><li>Graceful degradation</li><li>Fail-soft system</li></ul><p>此外，根据每个CPU执行的任务是否相同，有对称平行系统和非对称平行系统之分</p><ul><li>Symmetric multiprocessing (SMP) 对称平行系统指CPU之间运行的程序都是一样的</li><li>Asymmetric multiprocessing，非对称平行系统则指CPU之间不是一样的，有的CPU负责管理其他CPU，有的负责进行运算</li></ul><h3 id="I-Embedded-Operating-System，嵌入式系统"><a href="#I-Embedded-Operating-System，嵌入式系统" class="headerlink" title="I. Embedded Operating System，嵌入式系统"></a>I. Embedded Operating System，嵌入式系统</h3><p>所谓嵌入式系统，是指一些特化的用于处理固定任务的、与硬件高度结合的操作系统。例如微波炉中的操作系统</p><p>这类操作系统通常用于对设备进行控制，他们的特点如下：</p><ul><li>Special  purpose system</li><li>Should be customized</li><li>Size can be cut out</li><li>Low energy consumption</li><li>Real time</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20220101020047260.png" alt="嵌入式系统存在的地方"></p>]]></content>
      
      
      <categories>
          
          <category> Operating System Concepts Reading Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Operating System </tag>
            
            <tag> Reading Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora图床上传失败解决方案</title>
      <link href="/2021/12/29/typora-tu-chuang-shang-chuan-shi-bai-jie-jue-fang-an/"/>
      <url>/2021/12/29/typora-tu-chuang-shang-chuan-shi-bai-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍了Typora中使用图床上传图片失败的解决方案</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229233841511.png" alt="Typora 图床上传失败"></p><h1 id="Typora图床上传失败解决方案"><a href="#Typora图床上传失败解决方案" class="headerlink" title="Typora图床上传失败解决方案"></a>Typora图床上传失败解决方案</h1><p>我的博客的开发环境是Typora+Hexo+Matery主题，此外为了方便博客的部署，所有的图片使用的都是图床。然而在Typora中使用PicGO图床并不是一帆风顺的，因此本文主要介绍了Typora中PicGO图床出错的一些解决方法</p><h1 id="一、图片上传403错误"><a href="#一、图片上传403错误" class="headerlink" title="一、图片上传403错误"></a>一、图片上传403错误</h1><p>这个错误在我这里发生的现象是这样的，在之前的几个月的使用都是完全正常的，然而某次关机、切换成Windows之后再切换为Ubuntu，Typora的图床就无法使用了，上传图片会报错403。具体的如下图</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229233841511.png" alt="上传图片403错误"></p><p>这个问题其实是由于时差的问题，因为我是windows和ubuntu双系统，因此开完Ubuntu之后开Windows，时间就会差八个小时，然后在Windows中把时间改对了，在Ubuntu中又会差八个小时。因此这个问题就发生在Ubuntu的事件不对。解决办法很简单，把时间改回来就行了。</p><p>在设置中搜索<code>时间</code>，然后修改即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229154229847.png" alt="修改日期和时间"></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Typora </tag>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概念读书笔记-第一章：介绍-1 基础概念</title>
      <link href="/2021/12/29/cao-zuo-xi-tong-gai-nian-du-shu-bi-ji-di-yi-zhang-jie-shao-1/"/>
      <url>/2021/12/29/cao-zuo-xi-tong-gai-nian-du-shu-bi-ji-di-yi-zhang-jie-shao-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《操作系统概念（第九版）》的第一章的读书笔记第一部分，主要介绍了操作系统中的一些基础概念。</p><p>This blog is the first part of reading notes of  _Operating System Concepts (Ninth Edition)_ chapter 1: Introduction, which tells  the basic ideas of Operating System</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228175748055.png" alt="Chapter 1: Introduction"></p><h1 id="Operating-System-Concepts-Chapter-1-Introduction-1-Basic-Concepts"><a href="#Operating-System-Concepts-Chapter-1-Introduction-1-Basic-Concepts" class="headerlink" title="Operating System Concepts-Chapter 1: Introduction-1 Basic Concepts"></a>Operating System Concepts-Chapter 1: Introduction-1 Basic Concepts</h1><p>操作系统概念第一部分是Overview，包括第一章和第二章。</p><p>本章主要介绍了操作系统中一些基本概念和操作系统的发展历史/操作系统的种类，以及操作系统的任务。本章的第一部分主要讲解了操作系统的一些基础概念</p><h2 id="1-What-is-Operating-System"><a href="#1-What-is-Operating-System" class="headerlink" title="1. What is Operating System?"></a>1. What is Operating System?</h2><p>要说明什么是操作系统，还得从什么是计算机说起</p><blockquote><p><strong>What is computer</strong>：</p><p>从硬件上来说，计算机就是一堆硬件，包括鼠标、显示器、CPU、显卡等等；而对于我们用户来说，计算机就是一个黑箱子，我们坐在计算机前面，通过鼠标、键盘等等方式为计算机输入数据，计算机计算后会通过显示屏把输出（图像）输出出来。</p></blockquote><p>然而就像我们去买显卡的时候一样，我们知道显卡可以用来进行图形渲染，带来更好的游戏体验。然而我们在买显卡的时候买到的却是一个硬件，我们也没有办法直接使用</p><p>因此，在我们和计算机的一堆硬件之间存在一个管理员，这个管理员帮助我们管理计算机的硬件，把我们的需求转换为对计算机硬件的调用，<strong>这个管理员就是操作系统</strong>。</p><h3 id="A-操作系统的概念"><a href="#A-操作系统的概念" class="headerlink" title="A. 操作系统的概念"></a>A. 操作系统的概念</h3><p>我们首先需要对操作系统有一个大的认知，即<code>操作系统是一个在用户和硬件之间的程序</code></p><h3 id="B-操作系统的目标"><a href="#B-操作系统的目标" class="headerlink" title="B. 操作系统的目标"></a>B. 操作系统的目标</h3><p>操作系统的目标如下：</p><ul><li>执行用户的程序，并能够简化用户解决问题的过程</li><li>让计算机更加易于使用</li><li>以高效的方式使用计算机的硬件，从而提高性能</li></ul><p>因此说白了，操作系统的目的其实就是两个：向下，<code>高效的使用硬件</code>；向上，<code>让计算机对用户更加易用</code></p><p>因此未来介绍的包括存储管理、内存管理等等都是为了更加易用这个目标，而存储管理则视为了高效的使用硬件</p><h2 id="2-Computer-System-Structure"><a href="#2-Computer-System-Structure" class="headerlink" title="2. Computer System Structure"></a>2. Computer System Structure</h2><p>当我们提到操作系统的时候，通常指的是操作系统这个软件，只不过这个软件和硬件结合的非常紧密。</p><p>而当我们提到计算机系统的时候，计算机系统不仅仅指硬件的集合，实际上还指包括硬件在内的，操作系统等软件的集合。因此计算机系统的结构从下到上如下：</p><ul><li><strong>硬件</strong>：我们的文档需要保存在硬盘中，我们的程序需要被CPU运行，显示器上的图像需要被显卡渲染，网络数据的收发需要网卡……硬件提供了最基础的计算机的资源</li><li><strong>操作系统</strong>：操作系统可以控制、管理各种各样的硬件，并且为多个用户的多种程序调度硬件资源</li><li><strong>应用程序</strong>：应用程序负责调用硬件资源，解决用户的需求，例如文芳编辑器、编译器、汇编器、数据库软件等等</li><li><strong>用户</strong>：用户通过调用引用程序解决他们的问题，用户可以是具体的人，也可以是其他的电脑前的用户（本机是运算发生的地方，而用户在的电脑负责产生运算请求并发到本机）等等</li></ul><p>具体的图示如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229170838604.png" alt="计算机系统的结构图"></p><h2 id="3-Resource-in-Computer-System"><a href="#3-Resource-in-Computer-System" class="headerlink" title="3. Resource in Computer System"></a>3. Resource in Computer System</h2><p>根据上面的讲解，从应用程序的角度和用户的角度来看，计算机系统中的资源可以分为下面的两种：</p><ul><li>硬件资源（应用程序的角度向下看）<ul><li><strong>主机资源</strong>：包括CPU和内存</li><li><strong>外部设备资源</strong>：包括<ul><li>外部存储设备：U盘、固态/机械硬盘、光驱/光盘等等</li><li>外部输入输出设备：键盘（字符作为输入），显示器（图像作为输出），打印机（喷出的油墨作为输出），鼠标（位置作为输入）</li><li>其他设备：例如网线接头</li></ul></li></ul></li><li>软件资源（用户的角度向下看）<ul><li>系统程序：例如操作系统、编译器等等系统的软件</li><li>应用程序：MS Office套装、CAD软件以及用户自己开发的程序等等</li><li>工具软件</li></ul></li></ul><p>具体的结构图如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229173958594.png" alt="计算机系统具有的资源"></p><h2 id="4-Operating-System-Definition"><a href="#4-Operating-System-Definition" class="headerlink" title="4. Operating System Definition"></a>4. Operating System Definition</h2><p>操作系统的定义实际上非常多，从不同的角度能够给出操作系统不同的定义</p><h3 id="A-Resource-Allocator"><a href="#A-Resource-Allocator" class="headerlink" title="A. Resource Allocator"></a>A. Resource Allocator</h3><p>从资源管理的角度，操作系统就是一个资源分配器（包括软件、硬件）。而作为资源分配者，操作系统就需要满足以下的要求：</p><ul><li>管理所有的资源</li><li>兼顾公平与效率，即不同的用户、程序请求同一个资源的时候，系统要确保公平以及效率</li></ul><p>更加具体的，操作系统管理的硬件资源如下：</p><ul><li>CPU管理：CPU的分配和控制，即决定那个程序能用多久的CPU</li><li>内存管理：分配和回收内存空间，关于为什么要进行内存管理在后面会有更多的介绍</li><li>设备管理：分配和控制IO设备，例如把文档以怎么样的方式保存到磁盘上、键盘输入的字符该怎样的处理</li><li>文件管理：管理文件的权限，这个文件谁能看到、谁能修改……</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229200640120.png" alt="操作系统管理的硬件资源" style="zoom:50%;"></p><h3 id="B-Control-Program"><a href="#B-Control-Program" class="headerlink" title="B. Control Program"></a>B. Control Program</h3><p>另外一方面，从操作系统的功能来说，操作系统像一个管理程序，用于：</p><ul><li>防止错误的发生</li><li>阻止对计算机不正确的使用</li></ul><h3 id="C-More-Definition"><a href="#C-More-Definition" class="headerlink" title="C. More Definition"></a>C. More Definition</h3><p>其实操作系统目前并没有一个广泛通用的定义，维基百科上的定义如下</p><blockquote><p><strong>From Wikipedia</strong>：</p><p>操作系统（英语：Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p><p>操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统。许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用命令行界面，将图形用户界面视为一种非必要的应用程序。</p><p>操作系统理论在计算机科学中，为历史悠久而又活跃的分支；而操作系统的设计与实现则是软件工业的基础与内核。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229201749524.png" alt="维基百科上对操作系统的定义"></p></blockquote><p>从外观上来描述操作系统，它的特点如下：</p><ul><li>买电脑时厂商附带的一切：Windows、MacOS、VMS、Multics</li><li>开机后一直在运行的程序</li></ul><h2 id="5-Dual-mode-of-Operating-System"><a href="#5-Dual-mode-of-Operating-System" class="headerlink" title="5. Dual-mode of Operating System"></a>5. Dual-mode of Operating System</h2><p>实际上操作系统在运行过程中具有两种状态：<strong>用户态（User Mode）</strong>和<strong>内核态（Kernel Mode）</strong></p><ul><li><p><strong>User Mode</strong>：处于用户态的程序仅仅可以执行非特权指令，例如1+1</p></li><li><p><strong>Kernel Mode</strong>：处于内核态的程序可以执行所有的指令，包括特权指令。</p></li></ul><p>通常来说，特权指令指的是一些如果操作不当可能会导致系统崩溃的指令，例如清除内存、重置时钟、读取磁盘等等。因此如果不对这些特权指令加以保护（即所有用户都可以使用），那么垃圾程序员写出来的烂代码很可能就会搞崩系统。</p><p>为了区分用户态和内核态的程序，在硬件（CPU）上通常会用一个比特位来进行标识，称为<strong>模式位（mode bit）</strong>。例如处于用户态的程序user mode bit是1，而处于内核态的程序的user mode bit是0。</p><h2 id="6-System-Call"><a href="#6-System-Call" class="headerlink" title="6. System Call"></a>6. System Call</h2><p>为了保护系统不会因为垃圾程序员导致的崩溃，系统通过不同的模式来保护一些高危的指令。例如对磁盘进行读写的指令如果使用不当可能会造成磁盘损坏，但由于我们在程序中经常会有读写文件的操作，例如C语言的fread、Python的open等等。而文件就保存在磁盘上，因此读写文件在计算机底层就一定会包含对磁盘进行操作的指令。</p><p>只是由于读写磁盘这些特权指令使用的非常频繁，经常在用户态的程序中被调用，因此就需要为用户态的程序提供仅可以在内核态运行的指令的接口/入口/函数API。<strong>这些函数称为系统调用(System Call)</strong>。</p><p>在系统调用的时候，我们的程序会取调用这些系统提供的函数，因此在执行这些函数的时候，程序的控制流会短暂的移交到系统提供的函数中。此时我们程序的模式位会改变为内核态。在内核提供的函数完成调用后，程序控制流会返回我们的程序，此时程序的模式位会改回我们原先的特权态。</p><p>称进行系统调用时，程序控制流转移到系统中为<strong>陷入内核（trap in kernel）</strong>。</p><p>因此一次系统调用的过程中我们程序的控制流和对应的状态位变化如下，横轴为时间。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229211610111.png" alt="系统调用的时序图"></p><h2 id="7-Computer-Startup"><a href="#7-Computer-Startup" class="headerlink" title="7. Computer Startup"></a>7. Computer Startup</h2><p>正如前面所讲，操作系统本身也是一个软件，只不过这个软件和QQ、微信这类软件不同：QQ和微信是运行在操作系统上的软件，他们通过各种各样的系统调用来调用硬件资源，结合自己的逻辑控制与判断完成任务；而操作系统是直接运行在硬件上的，负责管理硬件以及提供各种各样的系统调用。因此尽管两者都是软件，两者所处的层级并不同，正如前面的计算机系统的结构图中展示的一样。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229170838604.png" alt="计算机系统的结构图"></p><p>正是因为这份特殊性，系统这个软件的启动和QQ这类普通的软件启动的方式不同。QQ这类普通软件（Windows上的exe、Linux上的o）我们双击即可运行，这是因为操作系统在背后帮我们干了非常多的事情，例如：申请一块内存空间用来存放QQ这个程序的指令、把QQ这个程序的指令从磁盘中读取出来并放到申请到的内存的位置中去（加载）、调用CPU去解析、执行QQ程序中的指令……</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229214549149.png" alt="操作系统也是一个软件"></p><p>但是系统的启动是完全基于一个裸的硬件的，因此在启动系统的时候并不会像启动QQ一样有操作系统为其准备好各种各样的环境。取而代之的是有一个叫做引导程序（Bootloader）为操作系统准备各种环境，引导程序会首先进行设备自检、初始化周边设备，然后加载操作系统，即从磁盘中读取操作系统内核可执行文件的指令序列，然后复制到内存中。</p><p>因此计算机启动的过程首先运行引导程序，然后由引导程序进行设备的自检，而后引导、初始化操作系统</p><h2 id="8-Computer-System-Organization"><a href="#8-Computer-System-Organization" class="headerlink" title="8. Computer System Organization"></a>8. Computer System Organization</h2><p>前面我们从层次上介绍了计算机系统的结构（Structure），下面从硬件的角度介绍计算机系统的组成（Organization）。</p><p>计算机系统的组成包含多种多样的设备，通常会有：</p><ul><li>一个或多个CPU</li><li>一个或多个磁盘</li><li>一个或多个USB设备</li><li>一个或多个显示器</li></ul><p>然而一个经典的CPU的执行流程是：用户通过键盘鼠标、磁盘等输入输出设备把数据输入（鼠标点击、键盘敲击、读取磁盘中的文件）到计算机，接下来数据被CPU计算得到结果，最后结果通过显示器或者磁盘输出（显示或者保存）。</p><p>而由于多种不同的设备读取到的数据的形式可能不同，而CPU只能够处理一种格式的数据，因此就需要在硬件上有控制器（Device Controller）或者适配器（Device Adapter），他们负责把从磁盘、鼠标、键盘读取到的原始数据处理转化为CPU可以直接处理的数据，然后让CPU进行处理，或者是把CPU处理之后的数据转换为显示器可以显示的数据。</p><p>此外，数据在电路中的传输是以分时的电信号的形式传输的，传播速度为光速，因此需要设备保存下数据，因此就有了存储器（Memory）。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229221140892.png" alt="计算机系统的组成" style="zoom:150%;"></p><h2 id="9-Bus"><a href="#9-Bus" class="headerlink" title="9. Bus"></a>9. Bus</h2><p>上面说到，数据在不同的设备间传递，而每个设备都会有自己的Controller或者Adapter以实现和CPU的交互。数据的传输需要有实体，这个实体在计算机中实际上就是总线（Bus）。</p><p>通过总线我们就可以实现让不同的设备（买来的机器自带的设备还是我们自己外加的附加设备/周边设备/第三方设备）之间进行数据的交互。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229221706606.png" alt="总线让内存和CPU之间进行交互" style="zoom:150%;"></p><h2 id="10-I-O-Operation"><a href="#10-I-O-Operation" class="headerlink" title="10. I/O Operation"></a>10. I/O Operation</h2><p>还是在上面说到，不同的设备每个设备都会有一个控制器/适配器，设备可以通过控制器/适配器和CPU进行数据间的交互。然而通常来说，每个控制器/适配器都会有一个自己的缓存（buffer），用来存储暂时的输入。</p><p>使用buffer的原因也很简单，就是因为设备读取输入的速度的问题。例如我们现在希望从磁盘中读取一个文本文件（例如，三国演义），然后让CPU把这个文本文件里的每个句子在句子末尾添加一个回车，接下来再把处理后的文本文件保存到磁盘中去。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229223014684.png" alt="三国演绎的文本文件"></p><p>然而在读取三国演义的时候有一个问题就是磁盘的读取速度是有上限的，假设一毫秒只能读取文本文件的一半，而作为用户我们当然是希望文本文件一次性被读完，然后被CPU一次性处理完之后保存到磁盘中。</p><p>因此这个时候就是缓存的作用了，buffer可以暂时存储已经读取到的一半的文件，接下来等待后一半读取完了之后统一交给CPU处理。</p><p>其实同样的例子还发生在键盘上，假设我们现在写一个程序，读取用户输入的句子，并将输入的句子打印在屏幕上。那么由于键盘是一次一个字符的传输，因此我们如果希望能够完整的把一句话打印在屏幕上，就需要一个缓冲区来保存先前所有输入的字符，然后等待用户按下回车结束输入，再把缓冲区中的句子发送给CPU，让CPU处理完后交给屏幕显示。</p><p>因此对于CPU而言，CPU的操作就是把数据从内存中移入到某个设备的缓冲区，或者把数据从某个设备的缓冲区中移动到内存中。至于具体的数据在缓冲区的保存和从缓冲器移动到内存都是由设备控制器/适配器完成的。</p><p>称数据从内存到控制器缓冲区/从控制器缓冲区到内存中的一次操作为一次<strong>I/O操作（I/O Operation）</strong>。</p><p>由于I/O操作发生在内存和设备控制器/适配器之间，而每个设备都会有自己的控制器/适配器，因此实际上操作系统可以并发的(Concurrent)和多个设备之间进行I/O操作。</p><blockquote><p><strong>为什么需要内存/主存（内存又称为主存）</strong>：</p><p>我们上面的讲解中说道，各种控制器读取到的数据需要移入内存中才能够被CPU处理，而CPU处理完的数据也需要保存到内存中才能够被设备保存（输出到磁盘或者屏幕上）。</p><p>那么为什么数据需要经过内存/主存？原因就在于<strong>各种设备运行的速度/访问的时间不同</strong></p><p>借用_现代操作系统_中的图片，CPU从寄存器中获取需要处理的数据只需要1纳秒，从内存中获取需要处理的数据需要10纳秒，而从磁盘中获取数据则需要10毫秒，基本上$10^3$的数量级的差距。</p><p>因此如果CPU直接从设备中获取需要处理的数据，那么CPU就不得不等待这些设备，因此就会浪费大量的时间。所以提高CPU的利用率，降低等待时间/加快速度，所有的数据都需要被放到内存中去。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229224334928.png" alt="各种设备的访问时间"></p></blockquote><h2 id="11-Interrupt"><a href="#11-Interrupt" class="headerlink" title="11. Interrupt"></a>11. Interrupt</h2><p>上面说道，I/O操作是内存和设备控制器的缓冲区之间的数据交换，这个过程的目的在于加快稍后CPU数据的获取（CPU可以直接从内存中获取数据而非等待设备控制器）。一个典型的CPU的I/O操作的流程其实如下（假设还是上面的读取文件后给每个句子后面添加回车）：</p><ul><li>CPU首先发出通知给控制器，要求控制器把数据放到内存中的某个位置上去</li><li>接下来CPU发出这样的指令给控制器后就继续去执行其他的程序的指令去了，而在CPU执行其他指令的这段时间，控制器就会去设备上获取数据（读取文件或者等待用户输入）</li><li>当控制器完成读取后，会发送消息给CPU，通知CPU读取已经完成。</li><li>CPU在收到控制器发来的消息后，会中止当前正在执行的指令，继续去每个句子后添加回车。</li></ul><p>具体的时序图如下：</p><pre class="line-numbers language-lang-mermaid"><code class="language-lang-mermaid">    sequenceDiagram    CPU->>USB Port 1: Fetch the data from file zzzzzz for me    USB Port 1 -->> Main Memory: Put data1： xxxxxxx on yyyyyyy    USB Port 1 -->> Main Memory: Put data2： xxxxxxx on yyyyyyy    USB Port 1 -->> Main Memory: .....    USB Port 1 -->> Main Memory: Put dataN： xxxxxxx on yyyyyyy    USB Port 1 -->> CPU: All data you need is put on yyyyyyy    CPU -->> Main Memory: I need data on yyyyyy    Main Memory -->> CPU: Here is your data: xxxxxxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230191239374.png" alt="CPU与控制器的交互"></p><p>因此，称在某些情况下计算机中止当前程序的运行，并转而去运行其他的程序的现象为<strong>中断(Interruput)</strong>。上面的例子就是典型的I/O中断，即由于输入输出导致的中断。而导致中断发生的事件称为<strong>中断事件(Interrupt Event)</strong>。</p><p>除了I/O中断以外，还有很多类型的中断，例如上面的执行系统调用（System Call），以及CPU执行用户程序时发生的运算错误，例如除0错误。</p><p>实际上中断是计算机系统中非常常用的机制，因为中断可以让原有的程序放弃CPU并且让CPU执行新的程序。</p><p>此外，中断分为两类，一类是<strong>可屏蔽的中断（Maskable Interrupt）</strong>，一类是<strong>不可屏蔽的中断（Non-Maskable Interruptable）</strong>。可屏蔽的中断表示中断事件导致的中断并不会立即中止当前程序的运行。CPU可能在稍后来响应这个中断事件，例如上面的把文件从磁盘读入到内存完成后，控制器向CPU发送的中断可能并不会立即让CPU中止运行当前的程序，来处理内存中的程序。因为CPU当前运行的程序可能是具有更高优先级的。例如在后面我们会讲到的同步。当前程序会特地的禁止CPU响应中断。</p><p>此外，CPU对可屏蔽的中断的另外一种响应就是忽略中断。</p><p>对于不可屏蔽的中断，CPU会立即中断当前运行的程序，然后处理中断。例如如果上面读取完成的事件发出的是不可屏蔽的中断的话，CPU就会立即处理这个中断，而处理中断的方式就是继续运行我们的文本处理程序。</p><p>根据中断发生的原因，中断可以分为三类：</p><ul><li><strong>程序产生的中断</strong>：程序产生的中断是用户的程序在运行的过程中，某些意外事件（中断事件）发生，导致向CPU发出了中断。常见的程序产生的中断有：除0中断、溢出中断、系统调用（虽然系统的函数被视为程序的一部分，但是系统的函数本身也可以视为一段程序，因此调用系统的函数就会”中止”我们的程序，而运行系统的程序（新的程序），因此在这个含义上，系统调用也可以视为中断）</li><li><strong>I/O中断</strong>：I/O中断即指由I/O设备产生的中断，常见的如上面的读取完成中断，此外还有文件不存在这类中断</li><li><strong>计时器中断</strong>：由计算机系统上的一个叫做计时器的硬件产生的中断（关于计时器稍后会讲）。</li></ul><h2 id="12-Timer"><a href="#12-Timer" class="headerlink" title="12. Timer"></a>12. Timer</h2><p>计时器本身是在计算机硬件系统上的一个硬件，类似于手表中的石英可以以固定的频率震动，计时器可以以固定的时间间隔（Unix中是1/60秒）发出一个中断。这个中断通常称为<strong>计时器中断（Timer Interrupt）</strong>。这个固定的时间间隔称为<strong>时间片（Time Share）</strong>。</p><p>不同于磁盘读取完成中断，计时器中断的意义不在于运行某个特定的中断处理程序，而在于通知操作系统（当前程序），他（你）已经占用CPU够久了，该把CPU让给别的程序来运行了。</p><p>因此计时器的目的其实就在于通过分时的CPU占用实现类似于并行的效果，提升多用户使用的体验（多道程序）。而之所以需要不断的中断的原因在于CPU（假设只有一个核心，虽然现在的CPU经常都是8核、16核）一次只能运行一个程序，因为一个程序被编译出来之后可能只有几百KB，但是在汇编层次的机器码而言，会有成千上万的指令。这些指令运行和解释起来就需要一个CPU（的核心）。</p><p>因此，操作系统中的计时器机制的特点如下：</p><ul><li>通过简单的计时 —&gt; 中断，避免了无穷循环和硬件资源的永久霸占</li><li>在一定的时间间隔后会发出一个中断</li><li>当中断发生后，当前进程可能会被kill掉，而其占用的资源会被释放，例如加锁的文件（文件加锁在后面会讲，但是目前只需要明白为了避免文件被两个程序同时修改导致的不同步，程序在修改文件的时候通常会给文件加锁，避免其他人同时修改文件）</li></ul><p>此外，计时器有的时候也被称为<strong>看门狗（Watch Dog Timer）</strong></p><p>虽然我们上面说计时器中断并不会类似文件读取完成中断一样，会调用我们指定的中断处理程序（我们的加回车程序）来处理中断。但是其实计时器中断也会去调用一个特殊的中断处理程序。这个中断处理程序是系统里已经写好的程序。这个程序的目的就是把当前程序的一些变量从寄存器中保存到内存中去，然后决定下一个需要运行的程序，接下来把下一个需要运行的程序的变量等内容从内存中加载到寄存器中去。</p><h2 id="13-Interrupt-Handling"><a href="#13-Interrupt-Handling" class="headerlink" title="13. Interrupt Handling"></a>13. Interrupt Handling</h2><p>当中断发生的时候（例如计时器中断），操作系统具体是如何完成整个中断的过程的？</p><p>首先我们需要明白，中断的定义就是中止运行当前程序，然后去运行新的程序。因此对中断的处理其实就包含两步，第一步就是中止当前程序的运行，第二步就是运行新的程序。</p><p>对于中止当前程序的运行，需要做的首先就是保存当前程序运算到中间得到的一些中间变量。例如我们让一个程序循环从1加到1000，例如：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">sum = 0for i in range(1, 1001):    sum += iprint(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么在加到50的时候程序可能由于时间片用完了，导致程序需要被中断，CPU转而去运行别的程序。此时需要保存循环变量i。以及保存在寄存器的中间变量sum。</p><p>接下来第二步就是运行新的程序，即<strong>中断处理程序(Interruput Handler或者Interrupt Service Routine，ISR)</strong>。在计算机内部，中断的表示是利用一个整数来表示的。而接下来去运行中断处理程序处理中断处理程序。由于中断可能会有很多种，因此中断处理程序也会有很多。为此需要指定一个中断 — &gt;中断处理程序的映射表，这个映射表称为<strong>中断表(Interrupt Table)</strong>。一个典型的中断表如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230152940124.png" alt="中断表" style="zoom:50%;"></p><p>如果是上面假设的计时器中断（中断的目的就在于把CPU让给下一个程序）的话，那么就会去运行计时器中断处理程序，计时器中断处理程序会从CPU的就绪队列中挑去下一个需要执行CPU的进程，然后把这个进程的变量和程序计数器加载到寄存器中，从而开始运行下一个程序。</p><p>以上就是一个典型的中断处理的过程。</p><p>除了正常的中断处理意外，还有可能发生的一个情况就是中断冲突。</p><p>在一个操作系统中，中断发生的次数非常多，每秒可能就会有一百多次。由于中断发生的原因可能会非常多，例如上面的IO中断，那么就可能会出现一个现象就是系统正在处理一个中断的时候另外一个中断发生了。例如上面的磁盘读取完成中断发生后，正在运行我们后续的程序的时候（中断处理程序），另外一个中断事件发生了，例如时间片用完。此时就会发生中断的冲突。</p><p>因此为了处理多个中断冲突的情况，系统为不同的中断设定不同的优先级。高优先级的中断会中断掉低优先级的中断处理程序，而低优先级的中断会等待高优先级的中断完成。注意，中断冲突发生的情况一定是CPU当前正在运行一个中断的处理函数。</p><p>因此处理中断的时候就会有两种处理方式，第一种就是A图中的低优先级的Y中断的中断处理函数等待高优先级的X中断的中断处理程序完成，第二种就是B图中的高优先级的Y中断的中断处理程序中断了低优先级的X中断的中断处理程序。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230144720338.png" alt="两种中断冲突处理方式"></p><h2 id="14-I-O-Processing"><a href="#14-I-O-Processing" class="headerlink" title="14. I/O Processing"></a>14. I/O Processing</h2><p>正如前面所说的，I/O指的是由CPU发起的，内存和I/O设备之间数据的交互。前面我们只是泛泛的说了一下系统是如何处理输入输出请求的。其实在真实的情境下，I/O的处理分为两种：</p><ul><li><strong>同步I/O（Synchronous）</strong>：同步I/O指的是当CPU向控制器发出I/O请求后，CPU会空转以等待控制器完成I/O。在此期间CPU不会运行其他的任何程序。</li><li><strong>异步I/O（Asynchronous）</strong>：异步I/O指的是当CPU先控制发出I/O请求后，CPU会立马中断发出I/O请求的程序（例如添加回车的程序），然后运行别的程序，一直直到控制读取完成后向CPU发出中断。当CPU收到中断之后就会中断其他的程序，转而继续运行添加回车的程序（当然这个取决于当前运行的程序和中断的优先级）。</li></ul><p>这两种I/O处理的方式如下图，A图中同步的I/O随着事件流逝，user占用的CPU会等待读取完成的中断。而B图中异步的I/O则是发出I/O请求后立即返回，同时user占用的CPU立刻去运行其他的程序。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230154003231.png" alt="两种I/O处理方式"></p><p>此外，由于每个I/O设备都会有自己的控制器，因此每个I/O设备可能都会处于不同的状态（是否在响应I/O请求）。因此在系统中有一张表来维护每个设备的状态，这个表称为<strong>设备状态表(Device-Status Table)</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230160557297.png" alt="设备状态表"></p><h2 id="15-Storage-Structure"><a href="#15-Storage-Structure" class="headerlink" title="15. Storage Structure"></a>15. Storage Structure</h2><p>在计算机系统中，有不少硬件都可以进行数据的存储，例如寄存器、磁盘、内存(主存)，甚至包括控制器的缓冲区。但是计算机的存储结构通常指磁盘、内存这类专门用于存储的硬件在内的存储系统。</p><p>通常，计算机的存储结构中包含以下硬件：</p><ul><li><strong>内存/主存（Main Memory）</strong>：主存是唯一的CPU可以直接获取数据的设备。内存中的数据是<strong>易失性的（volatile）</strong>，即断电后数据会全部遗失。</li><li><strong>二级存储（Secondary Memory）</strong>：二级存储是对主存的扩展，其内部的数据是<strong>非易失性的（nonvolatile）</strong>。</li><li><strong>磁盘（Magnetic Disks）</strong>：磁盘是由可以保存磁场的材料制成的。数据在其内部以磁的形式保存<ul><li>通常而言，数据在磁盘上按照<strong>磁道（Track）</strong>、<strong>扇区（Sector）</strong>的形式记录在磁盘上。</li><li>磁盘上的<strong>设备控制器(Disk Controller)</strong>帮助完成计算机和磁盘之间的沟通，包括磁信号到电信号的转换。</li></ul></li></ul><p>通常在考虑存储器的选择的时候，会权衡速度、价格和容量三个方面的因素。一般而言速度越快、容量越大，价格就会越高。因此系统中存储器的分层结构（Storage-Device Hierarchy）如下图</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230163108041.png" alt="存储器的分层结构" style="zoom:150%;"></p><p>从上到下单位价格容量越来越低，而速度越来越慢。</p><p>在前面放过一张图，图中描述了CPU访问每个设备、获取到数据需要的时间。一般来说访问内存需要10纳秒左右的时间，虽然寄存器的访问速度非常快，但是CPU内板载的寄存器首先非常有限，其次价格非常高昂，因此退而求其次，就有了<strong>高速缓存(Cache)</strong>。</p><p>计算机中的二八定律指出80%的访问都是针对20%的数据的，因此可以把内存中一些经常被访问的数据加载到高速缓存中去，CPU每次要从内存中获取数据前先从高速缓存中去看看，如果高速缓存中有的话就直接获取数据即可，如果没有再去内存中获取数据。</p><p>因此如果绝大多数CPU需要的数据都在缓存中的话，系统的运行速度实际上可以有极大地提升。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229224334928.png" alt="各种设备的访问时间"></p><h2 id="16-Multiprocessors"><a href="#16-Multiprocessors" class="headerlink" title="16. Multiprocessors"></a>16. Multiprocessors</h2><p>前面我们所有的讲解都是基于一个CPU，并且CPU中只有一个核心这个前提展开的，然而在现代的计算机中，有些系统可能不止有一个CPU，换而言之我们现在的计算机系统有些是多处理器的（Multiprocessors）的系统。</p><p>多处理器的系统有如下的好处：</p><ul><li><strong>大吞吐量（Increased Throughput）</strong></li><li><strong>便宜（Economy of scale）</strong></li><li><strong>更加可靠/容错更好（Graceful Degradation/fault tolerance）</strong></li></ul><p>通常来说，多处理器系统有两种架构：</p><ul><li><p><strong>非对称多处理器架构（Asymmetric Multiprocessing）</strong>：对称处理多处理架构指处理器之间是对称的，即在操作系统看来，没有多个处理器，只有一个处理器，所有的线程不加以区分，具体由那个处理器执行是随机的，所有处理器之间共享内存。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230165903630.png" alt="对称多处理器架构"></p></li><li><p><strong>对称对处理器架构（Symmetric Multiprocessing）</strong>：非对称多处理架构指处理器与处理器之间是非对称的，有些处理器专注于处理用户的程序（线程），而有些处理器则专注于处理系统线程</p></li></ul><p>两者的对比图如下：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230170031905.png" alt="Asymmetric v.s. Symmetric"></p><h2 id="17-Multicore"><a href="#17-Multicore" class="headerlink" title="17. Multicore"></a>17. Multicore</h2><p>前面我们说了可能存在不止一个处理器的系统，其实现在的计算机中一个处理器有多个核心，类似于多处理器的系统架构，多核心的CPU的好处和多处理器的系统的好处是类似的。</p><p>多核心的CPU主要有三种设计：</p><ul><li><p><strong>共享缓存（Shared Cache）</strong>：共享缓存的CPU中的多个核心之间会共享cache，而运算则是独立的。知名的一些产品有：IBM POWER4/5 family、Sun UltraSPARC-IV、Fujitsu SPARC64-VI、Sun Niagara、Intel Yonah/Merom family</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230170816531.png" alt="共享缓存的CPU设计"></p></li><li><p><strong>共享IO接口（Shared I/O Interface）</strong>：CPU可以通过总线和其他各个设备之间进行数据的交互，例如和内存。而共享I/O接口的多核处理器的设计则是两个处理器有单独的运算单元和缓存，只有I/O接口是共享的。一些知名的产品包括：Intel Itanium2、AMD dual-core Opteron </p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230171118342.png" alt="共享I/O接口的CPU"></p></li><li><p><strong>共享外壳(?)（Shared data packet）</strong>：这种多核心CPU的设计两个核心基本上就是独立的CPU，我实在不知道怎么翻译data packet……</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211230171323203.png" alt="共享外壳的CPU"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Operating System Concepts Reading Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Operating System </tag>
            
            <tag> Reading Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概念读书笔记-第零章：概览.md</title>
      <link href="/2021/12/28/cao-zuo-xi-tong-gai-nian-du-shu-bi-ji-di-ling-zhang-gai-lan-md/"/>
      <url>/2021/12/28/cao-zuo-xi-tong-gai-nian-du-shu-bi-ji-di-ling-zhang-gai-lan-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《操作系统概念（第九版）》读书笔记系列的第一篇文章，主要讲述我为什会编写这一系列的文章以及本系列文章的规划。</p><p>This article is the overview of series article: <code>reading notes of  _Operating System Concepts (Ninth Edition)_</code>.</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229231836302.png" alt="操作系统概念"></p><h1 id="操作系统概念读书笔记-第零章：概览"><a href="#操作系统概念读书笔记-第零章：概览" class="headerlink" title="操作系统概念读书笔记-第零章：概览"></a>操作系统概念读书笔记-第零章：概览</h1><h2 id="1-Why-Learning-Operating-System"><a href="#1-Why-Learning-Operating-System" class="headerlink" title="1. Why Learning Operating System?"></a>1. Why Learning Operating System?</h2><h3 id="A-From-the-aspect-of-own-capability"><a href="#A-From-the-aspect-of-own-capability" class="headerlink" title="A. From the aspect of own capability."></a>A. From the aspect of own capability.</h3><p>操作系统是一种特殊的软件，它下可以沟通硬件，上可以为用户的程序提供服务，连接了人与硬件。操作系统。各种算法、优化、设计思想的集大成者，巨型工程的难得成功案例</p><p>学习操作系统本身就能够提升我们的代码水平，因为其实写代码的时候遇到的很多问题是与底层机制相关的，如果不学底层这些知识，就会在遇到问题的时候束手无策。因此为我们想要写出来更好的程序、更好的操作计算机就需要学习操作系统。</p><h3 id="B-From-the-aspect-of-school-courses"><a href="#B-From-the-aspect-of-school-courses" class="headerlink" title="B. From the aspect of school courses."></a>B. From the aspect of school courses.</h3><p>另外一方面，操作系统是计算机科学相关专业学生的必修课，我也不例外。因此学习操作系统的另外一方面就是要分数。虽然我不太喜欢内卷，但是基础的分数还是必要的。</p><h2 id="2-Why-this-series-of-blogs"><a href="#2-Why-this-series-of-blogs" class="headerlink" title="2. Why this series of blogs"></a>2. Why this series of blogs</h2><p>写这系列博客的原因其实有很多，首先是作为学习的笔记，在未来需要的时候可以快速的回忆起来。</p><p>其次是作为我学习过操作系统的证据，毕竟需要记录可以证明我曾经学习过这些东西，</p><h2 id="3-Why-Operating-System-Concepts"><a href="#3-Why-Operating-System-Concepts" class="headerlink" title="3. Why _Operating System Concepts_?"></a>3. Why _Operating System Concepts_?</h2><p>学习是需要媒介的，无论是通过视频（网课）、看书（PPT）还是上课。对于我来说，效率最高的方式就是看书，此外由于学校里的课程使用的教材是《操作系统概念》，因此就选择阅读这本书来进行学习。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229231836302.png" alt="《操作系统概念》"></p><p>此外关于操作系统的书有两种，一种是面向新手的、零基础的介绍操作系统的概念的书，例如这本操作系统概念；另外一种是面向以及有经验的、面向开发的操作系统的书，例如Linux内核完全剖析。</p><p>第一次学习操作系统当然是要学基础的、介绍概念的书，未来提升自己、动手实现一个内核的时候再参考Linux内核完全剖析这类书。</p><h2 id="4-Overview-of-Operating-System-Concepts"><a href="#4-Overview-of-Operating-System-Concepts" class="headerlink" title="4. Overview of _Operating System Concepts_"></a>4. Overview of _Operating System Concepts_</h2><p>操作系统概念这本书主要分为以下几个大部分：</p><ul><li>概述：Overview，1-2章</li><li>进程管理：Process Management，3-7章</li><li>内存管理：Memory Management，8-9章</li><li>存储管理：Storage Management，10-13章</li><li>保护和安全：Protection and Security，14-15章</li><li>高级话题：Advanced Topics，主要讲解了虚拟化技术和分布式系统，16-17章</li><li>案例分析：Case Study，讨论了MacOS、Linux、Windows 7、Free BSD这些操作系统，18-19章</li></ul><p>本系列文章也将根据这些内容进行展开。</p>]]></content>
      
      
      <categories>
          
          <category> Operating System Concepts Reading Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Operating System </tag>
            
            <tag> Reading Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下QQ和微信解决方法</title>
      <link href="/2021/12/28/ubuntu-xia-qq-he-wei-xin-jie-jue-fang-fa/"/>
      <url>/2021/12/28/ubuntu-xia-qq-he-wei-xin-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>QQ和微信作为国民级的应用，无论是聊天还是传输文件都非常的方便。本文介绍了如何在类似Ubuntu这类的Linux平台上使用微信和QQ。</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229230820817.png" alt="最终效果图"></p><h1 id="Ubuntu-Linux下QQ和微信解决方法"><a href="#Ubuntu-Linux下QQ和微信解决方法" class="headerlink" title="Ubuntu/Linux下QQ和微信解决方法"></a>Ubuntu/Linux下QQ和微信解决方法</h1><p>作为一个开发者，通常在进行开发的时候往往会选择使用Ubuntu、CentOS等Linux发行版作为开发的平台。然而中国的开发者难以避开的就是QQ、微信等等应用。除了聊天以外，QQ、微信的一个重要的功能就是在多端设备之间传输文件（电脑—&gt;手机、平板—&gt;电脑）。然而QQ和微信都仅仅支持MacOS和Windows这两大平台，因此本文就介绍了在Ubuntu/Linux平台上使用QQ和微信的方法。</p><h2 id="方案一：虚拟机"><a href="#方案一：虚拟机" class="headerlink" title="方案一：虚拟机"></a>方案一：虚拟机</h2><p>微信和QQ都支持windows平台，因此使用虚拟机的话就是我们在ubuntu上安装一个windwos的虚拟机，然后在虚拟机中安装qq和微信。</p><p>使用虚拟机的原因在于使用docker和wine等方式使用QQ和微信都只是权宜之计，只能够解决某一个版本的QQ和微信的使用。此外一个API还会可能有问题，因此如果想到比较完美的使用体验就还是需要虚拟机。</p><h3 id="1-检查内存大小"><a href="#1-检查内存大小" class="headerlink" title="1. 检查内存大小"></a>1. 检查内存大小</h3><p>使用虚拟机的一个大问题就是需要电脑有足够大的内存，这样在运行windows虚拟机的时候就不会很卡。</p><p>由于我的机器的性能还是不错的，内存有32个G，因此对我来说最合适的解决方案就是安装一个Windows的虚拟机。</p><p>在后续的步骤前首先需要查看自己的机器的内存和交换空间的大小，使用下面的命令，就可以看到。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">watch free -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228173025146.png" alt="我的机器的内存信息"></p><h3 id="2-安装Virtualbox虚拟机"><a href="#2-安装Virtualbox虚拟机" class="headerlink" title="2. 安装Virtualbox虚拟机"></a>2. 安装Virtualbox虚拟机</h3><p>目前运行比较流畅的虚拟机就是Oracle的VirtualBox和VMware公司的VMware两个软件。由于Virtualbox免费并且多平台适用的的特点（VMware收费），本文使用VirtualBox来作为虚拟机的软件。</p><p>安装VirtualBox虚拟机使用下面的命令就行，由于我已经安装过了，因此不会有任何反应</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">sudo apt-get install virtualbox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228173626767.png" alt="安装VirtualBox"></p><p>安装完了之后我们就可以在命令行中通过virtualbox命令或者在应用程序图标里点击运行VirtualBox，这里继续使用命令行</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">virtualbox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后我们就能够看到VirtualBox开始运行。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228173825872.png" alt="image-20211228173825872"></p><h3 id="3-下载windows镜像"><a href="#3-下载windows镜像" class="headerlink" title="3. 下载windows镜像"></a>3. 下载windows镜像</h3><p>windows的镜像文件我们可以直接取<a href="https://www.microsoft.com/zh-cn/software-download/windows10ISO">windows的官网</a>上下载：<a href="https://www.microsoft.com/zh-cn/software-download/windows10ISO。考虑到浏览器本身就会占用很多的资源，影响下载速度，因此使用wget从命令行加速下载。">https://www.microsoft.com/zh-cn/software-download/windows10ISO。考虑到浏览器本身就会占用很多的资源，影响下载速度，因此使用wget从命令行加速下载。</a></p><p>我们选择完windows版本之后会看到官网给出的两个下载链接，选择自己需要的版本然后复制链接即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228174324033.png" alt="复制下载链接"></p><p>接下来在命令行中wget下载即可，注意复制来的网页链接中有<code>(</code>之类的shell的语法字符，因此需要用<code>""</code>把网址包围起来禁止转义</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">wget -c "你的下载地址"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228174604765.png" alt="下载Windows的镜像文件"></p><p>然后耐心等待即可。下载完大小5.5G左右</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228190833912.png" alt="下载完成的镜像文件"></p><p>最后我们给这个文件改个名字，把后缀改成iso，因为稍后VirtualBox是根据后缀名来识别文件的</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228192040466.png" alt="修改后的文件"></p><h3 id="4-创建虚拟机"><a href="#4-创建虚拟机" class="headerlink" title="4. 创建虚拟机"></a>4. 创建虚拟机</h3><p>点击右上角的<code>新建</code>，然后选择虚拟机文件的存储位置和对应的系统，完成后点下一步。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228190934329.png" alt="虚拟机的基本设置"></p><p>接下来给虚拟机分配内存，这个就看个人了，我的内存比较大，所以就给虚拟机分配12G内存</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228191153552.png" alt="内存分配"></p><p>接下来给虚拟机的文件分配大小，默认即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228191420175.png" alt="为虚拟机分配磁盘1"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228191450549.png" alt="为虚拟机分配磁盘2"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228191511960.png" alt="为虚拟机分配磁盘2"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228191536355.png" alt="为虚拟机分配磁盘3"></p><h3 id="5-安装windows虚拟机"><a href="#5-安装windows虚拟机" class="headerlink" title="5. 安装windows虚拟机"></a>5. 安装windows虚拟机</h3><p>上面我们只是用VirtualBox创建好了所有需要的环境，接下来我们就是要把windows安装进去</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228191700557.png" alt="点击设置"></p><p>然后在存储中点击盘片，选择windows的映像文件</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228191834378.png" alt="选择windows的映像文件"></p><p>然后点击启动即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228192121402.png" alt="点击启动"></p><p>然后按照指引进行安装即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228192211784.png" alt="安装windows"></p><p>安装完之后的分辨率有点问题，因此我们还需要设置一下分辨率</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228200126547.png" alt="有问题的分辨率"></p><p>点击<code>设备</code>—&gt;<code>安装增强功能</code>，然后按照提示安装即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228200320807.png" alt="安装增强功能"></p><p>安装完成之后在C盘外有一个程序，点击运行即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228201049520.png" alt="image-20211228201049520"></p><p>安装完之后重启，就可以在视图中进行设置，选择自动调整窗口大小即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228202752076.png" alt="全屏显示"></p><p>最后在设置里设置双向剪贴板</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211228203017531.png" alt="设置共享剪切板"></p><h3 id="6-安装微信和QQ"><a href="#6-安装微信和QQ" class="headerlink" title="6. 安装微信和QQ"></a>6. 安装微信和QQ</h3><p>最后安装微信和QQ即可，最终效果图如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211229230820817.png" alt=""></p><p>此外，我们安装完的Windows实际上是未激活的的Windows，只能够使用一些有限的功能。为此，要么去微软官方买一个激活码，或者去淘宝买一个激活码即可。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> QQ </tag>
            
            <tag> 微信 </tag>
            
            <tag> Wechat </tag>
            
            <tag> Linux </tag>
            
            <tag> Virtualbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A*算法-Python实现</title>
      <link href="/2021/12/22/a-suan-fa-python-shi-xian/"/>
      <url>/2021/12/22/a-suan-fa-python-shi-xian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要提供了Python版本的A*路径规划算法实现，并在此基础上提供了命令行和基于Matplotlib的GUI用户界面（User Interface）</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/a_star.gif" alt="完整效果"></p><h1 id="A-算法-Python实现"><a href="#A-算法-Python实现" class="headerlink" title="A*算法-Python实现"></a>A*算法-Python实现</h1><p>路径规划算法是计算机届中非常重要的算法，在不少领域都能够看到路径规划算法的应用，最直接的应用例如打车软件为你规划出路径、迷宫问题的求解等等；而复杂一些的、不直接的应用如六自由度机械臂在空间中运动轨迹的规划可以看做是在六维空间的路径规划、火星车在火星表面的探索等等都可以视为路径规划问题，从而使用路径规划算法进行求解。</p><p>路径规划算法大体上可以分为两类：<strong>静态路径规划</strong>以及<strong>动态路径规划</strong>。所谓静态静态路径规划指的是提前已知全局地图的前提下进行路径规划；而动态路径规划则指的是预先并不知道全局地图或者仅知道全局地图的一部分，在此基础上对全局地图进行探索的同时动态的利用获取到的信息指导路径规划，最终达到终点。在我们的认知上，一般当然是动态路径规划算法会好很多，因为我们往往并不知道全局地图，而且对于我们人类来说，在一个陌生环境下进行路径规划、到达终点更是我们所希望的。然而在现实中在一些场景中确实全局地图是可以提前获得的，因此针对这些场景，开发出来资源占用更少、速度更快、路径更优的算法就还是有必要的。</p><p>其实动态路径规划更进一步，在探索的构建出来全局地图，那就成了SLAM问题了，即同时定位与建图（Simultaneous Localization And Mapping，SLAM）。关于SLAM本文就不再深入了。</p><p>本文将要介绍的A<em>算法就是属于静态路径规划算法的其中一种。在诸多的静态路径规划算法里，A\</em>算法可以和暴力搜索（广度优先、深度优先）一样，获得最优的路径，并且资源消耗远远小于广度优先和深度优先。因此有广泛的应用。</p><p>本文将在介绍A*算法的基础上提供一种A*算法的Python实现，并在此基础上讲解实现的代码</p><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>其实我现在是一个大二的计算机系学生，最近数据结构课程的配套实验要求学生从十四个题中选择四个来做。本篇博客就是对应的迷宫问题的求解代码。求解问题比较简单，但是这样就太没有意思了，所以在实现文本字符的迷宫求解基础上，我想为自己带来一些挑战，增加一些趣味性与难度。</p><p>因此在基础的求解迷宫问题的要求上，我利用Matplotlib中的Interactive Plotting Method将路径规划的过程以GUI的形式表达出来，并在此基础上提供地图绘制、地图保存等一系列功能，最后完成一个不错的程序。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211221220005902.png" alt="数据结构算法实验"></p><h2 id="1-A-算法"><a href="#1-A-算法" class="headerlink" title="1. A*算法"></a>1. A*算法</h2><p>其实关于A<em>算法并没有什么好说的，网上不少博客对A\</em>算法都有了非常深入的介绍，因此我这里就不在赘述了，避免班门弄斧。</p><p>而对于A*算法，需要理解的关键之处就是在启发值的运用。启发值描述了当前点到终点的估计距离，因此相比于深度有限和广度优先，A*算法每次都会去寻找离终点距离比较近的点作为下一个点，从而避免了漫无目的、低效率的遍历。</p><p>此外，算法中的OpenList和CloseList其实指的就是已探索区域的边缘和已经探索区域的内部，因此每次进行下一次探索的时候从OpenList里面找出来点作为下一个探索的点即可。而一旦这个点被探索完毕，将其加入到CloseList中即可，即表示当前点已经被考虑过。</p><p>最后算法的结束条件就是当终点已经在CloseList中了，表示已经找到了一条路径，此时对CloseList中的点进行回溯即可找到路径，因为CloseList中的探索区域已经蕴含了路径的信息；此外还要注意找不到路径时候的结束条件，避免找不到路径而陷入死循环。</p><p>上面是我对于A*算法的理解，如果需要学习A*算法的话，其实B站上、知乎上有很多不错的讲解。这里就贴出来百度百科和维基百科的介绍</p><blockquote><p><strong>From Wikipedia</strong>：</p><p>A<em> (pronounced “A-star”) is a graph traversal and path search algorithm, which is often used in many fields of computer science due to its completeness, optimality, and optimal efficiency. One major practical drawback is its  $O(b^{d}$) space complexity, as it stores all generated nodes in memory. Thus, in practical travel-routing systems, it is generally outperformed by algorithms which can pre-process the graph to attain better performance, as well as memory-bounded approaches; however, A</em> is still the best solution in many cases.</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211222143802336.png" alt="维基百科上对A*算法的介绍"></p><p><strong>From BaiduBaike</strong>：</p><p>A*算法，A*（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法。算法中的距离估算值与实际值越接近，最终搜索速度越快。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211222143914743.png" alt="百度百科上对A*算法的介绍"></p></blockquote><h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h2><p>针对不同的功能，整个程序的实现，主要分为三个层次（软件分层的思想）：</p><ol><li><strong>核心层</strong>：负责GUI的显示（地图的绘制与更新）、地图的加载与保存、键盘鼠标等事件对应的回调函数（信号处理函数）的绑定</li><li><strong>算法实现层</strong>：负责A*算法的实现</li><li><strong>用户界面层</strong>：负责提供命令行用户界面，从而实现<del>高级感</del>（逼格）</li></ol><h3 id="1-核心层"><a href="#1-核心层" class="headerlink" title="1. 核心层"></a>1. 核心层</h3><p>核心层的具体任务为维护全局地图以及进行地图的保存，因此代码也是围绕这两大内容进行编写的。</p><h4 id="1-地图的维护"><a href="#1-地图的维护" class="headerlink" title="1. 地图的维护"></a>1. 地图的维护</h4><p>对于路径规划问题，其核心维护对象就是全局地图地图，因为地图的保存、与加载；GUI的显示以及路径规划的实现都需要地图上区域的状态，因此在核心层首先需要实现的的就是地图。</p><ul><li>首先是关于地图的表示。对于地图本身而言，由于目前进行的是二维的路径规划，因此可以利用一个二维数组来表示。</li><li>其次是地图在磁盘上的表示。为了方便保存之后方便读取、加载以及人类的理解，可以将二维数组保存为csv文件从而序列化到磁盘上，而在加载地图的时候再从磁盘上反序列化csv文件到内存，从而读取出来地图。</li><li>最后是地图中障碍物的表示。由于地图中的区域会有多种状态，例如是否为障碍物（是否可行），其次在进行A*路径规划的时候也会为地图中的区域标记其状态（是否已经考虑过）。因此针对地图中不同的状态的区域，使用不同的数值表示当前区域的状态，例如inf表示障碍物，3表示最终规划得到的路径。</li></ul><h4 id="2-地图的显示"><a href="#2-地图的显示" class="headerlink" title="2. 地图的显示"></a>2. 地图的显示</h4><p>由于地图的显示涉及到图形的显示，因此需要了解一下图形在计算机中的显示。</p><blockquote><p>图形的显示有两种方式，分别是矢量图以及光栅图。</p><ul><li>对于矢量图，其内部的图形是由基本的几何图形构成的，因此在矢量图文件（例如.dot）文件中，只需要按照指定的格式描述图形的属性即可。例如Windows的.dot文件，我们按照其要求的语法对图形进行描述，然后对应的解析该语法，利用图形学的算法即可渲染出来图形，我们常见的PDF、SVG等等文件都是矢量图。例如下面的例子</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211224005217273.png" alt="矢量图的一种：dot文件"></p><ul><li>而对于光栅图，其基本构成单位是像素，每个像素大小只有零点几个毫米，而每平方厘米都会有几百几千个像素。而每个像素都会有自己的数值，表现出来自己的颜色。因此我们通过几万个极小的、在人眼看来是点的像素组合起来就成了我们所看到的图像。因此这种图像又称为位图、点阵图、像素图。我们常见的JPG、PNG、BMP等等都是光栅图，例如下面的例子</li></ul><p><img src="https://bkimg.cdn.bcebos.com/pic/54fbb2fb43166d22356091ba4b2309f79052d28d?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="经典的光栅图"></p><p>矢量图最大的好处就在于由于其图形是完全利用数学公式描述的（例如圆相对于屏幕左上角的相对距离、圆相对于屏幕宽度的半径等等），因此针对不同的屏幕、不同的放大背书，矢量图片完全可以通过运算进行放大、适配。因此在我们用户看来就是矢量图是无论怎样放大边缘都不会模糊。例如下面的pdf</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211224010247748.png" alt="放大2.5倍的PDF文件"></p><p>aas</p><p>而光栅图的基本单位是像素，因此再怎么放大，像素都是不会变的，因此在放大一定的倍数就会模糊，这个时候即便有一些算法会做自适应，例如双线性插值、三线性插值等等增加像素的数量，但是他们会造成边缘的模糊</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211224010524045.png" alt="光栅图放大后可见的像素"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211224010559551.png" alt="经过插值处理之后的图片会变的模糊"></p><p>因此在不同场景下有不同的取舍。一般而言，当图形比较好描述（都是规则的几何图形）的时候，就会选择用矢量图，而当图形不好描述的时候（例如自然景观），这个时候就会选择光栅图</p></blockquote><p>尽管地图都是规整的矩形和色块，使用矢量图非常容易描述，但是考虑到如果需要使用矢量图像的话还需要不少的学习成本来学习矢量图的描述语言，花费的时间比较多。而有考虑到Python中其实已经想Matplotlib、Seaborn、Plotly这类非常好的光栅图绘图库（当然他们可以绘制矢量图），因此最终决定使用光栅图来显示、绘制地图。</p><p>当然，其实Matplotlib、Plotly这些库最终调用的都是类似于cairo、gtk这些由C/C++开发出来的图形库</p><h4 id="3-地图动态显示"><a href="#3-地图动态显示" class="headerlink" title="3. 地图动态显示"></a>3. 地图动态显示</h4><p>地图的绘制与显示实际上是一个非常消耗资源的操作。上面的GIF和后面放出来的B站的演示视频里A*算法花了不少的时间最后才找到最终的路径，但是真正的纯A<em>算法的规划路径的速度才只有0.2秒左右，这还是我在100\</em>100的地图上测试的。然而为了显示出A*的动态效果图，因此算法的每次试探都会进行地图的绘制。而每次绘图就需要占去0.2秒左右的时间（我读取系统时间做了benchmark）。因此只敢显示30*30的地图。</p><p>因此为了尽可能的的加快绘图的速度，在图形中对所有的Patch（即一个小方格）进行记录，每次只会重新绘制发生了变化的Patch而不会重新绘制整张地图，因此极大地加快了显示的速度。至少在我测试的50*50的场景下效果还是非常不错的。</p><h3 id="2-算法实现层"><a href="#2-算法实现层" class="headerlink" title="2. 算法实现层"></a>2. 算法实现层</h3><p>算法实现层负责实现A*算法。A*算法中使用使用OpenList以及CloseList维护已探索区域和边缘区域。此外为实现算法实现层与核心层解耦合，而二维地图的状 态的维护由核心层提供，因此在算法实现层只需要调用核心层提供的接口进行地图状态修改即可 </p><h3 id="3-用户界面层"><a href="#3-用户界面层" class="headerlink" title="3. 用户界面层"></a>3. 用户界面层</h3><p>用户界面层负责GUI的显示以及命令行用户界面。GUI部分通过Matplotlib内嵌的信号与槽机制实现用户鼠标、键盘事件的监听以及回调函数的绑定，进而响应用户事件，完成功能，例如：保存地图 。命令行用户界面负责根绝接收到不同的用户参数，运行不同的功能，例如绘制地图、开始路径规划……</p><h2 id="3-具体代码"><a href="#3-具体代码" class="headerlink" title="3. 具体代码"></a>3. 具体代码</h2><h3 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1. 导入库"></a>1. 导入库</h3><p>导入Python中队列维护的库queue、路径处理库pathlib、二维数组维护库Numpy、csv序列化与反序列化Pandas库、绘图库Matplotlib以及命令行彩色字体库colorama</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import timeimport queueimport pprintimport argparsefrom typing import *from pathlib import Pathfrom collections import namedtupleimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport matplotlib.backend_bases as bbasefrom colorama import Fore, Style<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-核心对象"><a href="#2-核心对象" class="headerlink" title="2. 核心对象"></a>2. 核心对象</h3><p>_MapBase中维护的核心对象为map，程序所处的状态由一个有限状态机维护，不同的事件由不同的回调函数负责处理。</p><p>首先，__del__、new、update、add_patch实现了GUI图形的绘制以及更新</p><p>pandasfy与depandasfy负责将二维地图以csv文件格式保存至磁盘上</p><p>_btn_press_cb、_btn_release_cb、_move_cb、_keyboard_cb分别响应鼠标按下、松开、移动以及键盘按下事件</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class _MapBase(object):    """    Notes:        MapBase 用于可视化的地图创建    Args:        mapsize (tuple[int, int]): size of map        figsize (tuple[int, int]): size of figure    """    def __init__(self, mapsize: Tuple[int, int], figsize: Tuple[int, int] = (12, 12)):        super(_MapBase, self).__init__()        # meta information        self._mapsize: Tuple[int, int] = mapsize        self._figsize: Tuple[int, int] = figsize        # map, inf obstacle, 0 accessible, 1 in path        self.map: np.ndarray = np.zeros(shape=mapsize)        self.map_temp: np.ndarray = None        # visualize core object        self._figure, self._axes = plt.subplots(figsize=figsize)        self._canvas = self._figure.canvas        self._title: plt.Text = None        self._go_on: bool = False        # gui interaction, finite state machine to control plot        self._on_press: bool = False        self._current_state = "add_obstacle"        self.btn_pressed_cid = self._canvas.mpl_connect("button_press_event", self._btn_press_cb)        self.btn_released_cid = self._canvas.mpl_connect("button_release_event", self._btn_release_cb)        self.mouse_move_cid = self._canvas.mpl_connect("motion_notify_event", self._move_cb)        self.keyboard_cid = self._canvas.mpl_connect("key_press_event", self._keyboard_cb)        self.new()    def __del__(self):        plt.close(self._figure)    def start(self):        assert False, f"This method should be overwritten by subclass"    def update(self):        self._canvas.draw_idle()    def new(self) -> bool:        """        Notes:            new is used to clear the map. In practice, generate a new axes        Returns:            if_clear (bool): true if successfully clear the map        """        try:            self.map = np.zeros(shape=self._mapsize)            self._axes.cla()            self._axes.grid(True)            self._axes.set_xticks(range(0, self._mapsize[0] + 1))            self._axes.set_yticks(range(0, self._mapsize[1] + 1))            self._axes.set_xlim(0, self._mapsize[0])            self._axes.set_ylim(0, self._mapsize[1])            self._title = self._axes.set_title(f"Current State: {self._current_state}")            self._axes.scatter([], [], marker="s", c="red", label="goal")            self._axes.scatter([], [], marker="s", c="black", label="obstacle")            self._axes.scatter([], [], marker="s", c="green", label="start")            self._axes.scatter([], [], marker="s", c="blue", label="final path")            self._axes.scatter([], [], marker="s", c="gray", label="explored")            self._axes.scatter([], [], marker="s", c="cyan", label="frontier")            self._axes.legend(loc=(1.01, 0.85))            self.update()            return True        except KeyboardInterrupt as e:            print("Keyboard interrupted")            return False    def add_patch(self, x: Union[int, np.ndarray, list], y: Union[int, np.ndarray, list],                  patches: Union[str, None] = None) -> bool:        prompt = (x, y) if isinstance(x, int) else list(zip(x, y))        if self._current_state == "add_obstacle":            try:                self.map[x, y] = np.inf            except IndexError:                pass            self._axes.scatter(x + 0.5, y + 0.5, s=200, marker="s", c="black")            print(f"Add obstacle: {prompt}")        elif self._current_state == "add_goal":            if (self.map == -1).any():                print(f"{Fore.YELLOW}Already have one goal!{Style.RESET_ALL}")                return False            self.map[x, y] = -1            self._axes.scatter(x + 0.5, y + 0.5, s=200, marker="s", c="red")            print(f"Add goal: {prompt}")        elif self._current_state == "add_start":            if (self.map == -2).any():                print(f"{Fore.YELLOW}Already have one start!{Style.RESET_ALL}")                return False            self.map[x, y] = -2            self._axes.scatter(x + 0.5, y + 0.5, s=200, marker="s", c="green")            print(f"Add start: {prompt}")        elif self._current_state == "going_back":            self.map[x, y] = -3            self._axes.scatter(x + 0.5, y + 0.5, s=200, marker="s", c="blue")        elif self._current_state == "clear_patch":            if self.map[x, y] == 0:                print(f"{Fore.YELLOW}Not in use!{Style.RESET_ALL}")                return False            self.map[x, y] = 0            self._axes.scatter(x + 0.5, y + 0.5, s=250, marker="s", c="white")            print(f"Cleared: {prompt}")        elif self._current_state == "searching":            if patches == "explored":                # assert (0 <= self.map[x, y] <= 2).all(), f"{Fore.RED}Illegal Operation on map{Fore.RESET}"                # self.map[x, y] = 1                self._axes.scatter(x + 0.5, y + 0.5, s=200, marker="s", c="gray", alpha=1)            elif patches == "frontier":                # assert (0 <= self.map[x, y] <= 2).all(), f"{Fore.RED}Illegal Operation on map{Fore.RESET}"                # self.map[x, y] = 2                self._axes.scatter(x + 0.5, y + 0.5, s=200, marker="s", c="cyan", alpha=1)        else:            assert False, F"{Fore.RED}Invalid State: {self._current_state}"        self.update()        return True    def pandasfy(self) -> pd.DataFrame:        """        Notes:            pandasfy will serialize current map from matplotlib to cvs file        Returns:            serialized_map (pd.Dataframe)        """        pp: pd.DataFrame = pd.DataFrame(self.map.copy().T[::-1, :], dtype=str)        pp.replace("-1.0", "GOAL", inplace=True)        pp.replace("-2.0", "START", inplace=True)        return pp    def depandasfy(self, csv_path: Path):        """        Notes:            depandasfy will deserialized csv file map to matplotlib        Args:            csv_path (Path): path of csv file        Returns:            None        """        df: pd.DataFrame = pd.read_csv(filepath_or_buffer=csv_path, index_col=0, header=0)        df.replace("START", "-2.0", inplace=True)        df.replace("GOAL", "-1.0", inplace=True)        self.new()        t = df.to_numpy(dtype=np.float64)[::-1, :].T        # self.map = df.to_numpy()        xs, ys = np.where(t == np.inf)        self._current_state = "add_obstacle"        self.add_patch(xs, ys)        xs, ys = np.where(t == -1)        self._current_state = "add_goal"        self.add_patch(xs, ys)        xs, ys = np.where(t == -2)        self._current_state = "add_start"        self.add_patch(xs, ys)    def _update_title(self, s: str = None):        if s is None:            self._title.set_text(f"Current State: {self._current_state}")        else:            self._title.set_text(s)        self.update()    def _btn_press_cb(self, event: bbase.MouseEvent) -> None:        self._on_press = True        if event.inaxes:            point = (int(event.xdata), int(event.ydata))            self.add_patch(*point)    def _btn_release_cb(self, event: bbase.MouseEvent) -> None:        self._on_press = False    def _move_cb(self, event: bbase.MouseEvent) -> None:        if self._on_press:            if event.inaxes:                point = (int(event.xdata), int(event.ydata))                self.add_patch(*point)    def _keyboard_cb(self, event: bbase.KeyEvent):        if event.key == "c":            self._current_state = "add_obstacle"            print(f"{Fore.YELLOW}Clear all!{Style.RESET_ALL}")            self.new()        elif event.key == "1":            self._current_state = "add_obstacle"            print(f"{Fore.GREEN}Switch to {self._current_state}{Style.RESET_ALL}")        elif event.key == "2":            self._current_state = "add_goal"            print(f"{Fore.GREEN}Switch to {self._current_state}{Style.RESET_ALL}")        elif event.key == "3":            self._current_state = "add_start"            print(f"{Fore.GREEN}Switch to {self._current_state}{Style.RESET_ALL}")        elif event.key == "0" or event.key == "d":            self._current_state = "clear_patch"            print(f"{Fore.GREEN}Switch to {self._current_state}{Style.RESET_ALL}")        elif event.key == "r":            p = self._current_state            self._current_state = "add_obstacle"            xs = np.random.randint(0, self._mapsize[0], size=(n := self._mapsize[0] * self._mapsize[1] // 5))            ys = np.random.randint(0, self._mapsize[1], size=n)            self.add_patch(xs, ys)            self._current_state = p        elif event.key == "w":            files = [i.stem for i in Path(__file__).resolve().absolute().parent.glob("map_*.csv")]            if len(files) > 0:                name = f"map_{int(max([f.split('_')[1] for f in files])) + 1}"            else:                name = "map_0"            self.pandasfy().to_csv(p := Path(__file__).resolve().parent.joinpath(f"{name}.csv"))            print(f"{Fore.GREEN}Save current Map to {p}{Style.RESET_ALL}")        elif event.key == "v":            print(f"{Fore.GREEN}Start finding goal{self._current_state}{Style.RESET_ALL}")            self._go_on = True            self.start()        self._update_title()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h3><p>算法实现由Astar类负责完成，其中由于在计算启发值时可以有多种算法，因此将启发值的计算以静态方法形式嵌入到类中</p><p>start方法为完整的A*算法实现，而plot4searching用于在路径规划时动态更新地图</p><p>此外OpenList和CloseList分别作为字典的键和值蕴含在came_from和cost_so_far两个字典中，因此不用单独开辟新的数组进行保存</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Astar(_MapBase):    def __init__(self, load_path: Union[Path, None], mapsize: Tuple[int, int] = (30, 30)):        super(Astar, self).__init__(mapsize=mapsize)        if load_path is not None:            print(f"{Fore.GREEN}Load from {load_path}{Style.RESET_ALL}")            self.depandasfy(load_path)            self.update()            t = np.where(self.map == -2), np.where(self.map == -1)            self.start_point: str = f"{t[0][0][0]},{t[0][1][0]}"            self.goal_point: str = f"{t[1][0][0]},{t[1][1][0]}"            # open list, but I think frontier is a better name            # no need for close list for which has been represented as items of came_from or keys of cost_so_far            self.frontier = queue.PriorityQueue()            self.frontier.put((0, self.start_point))            self.came_from: Dict[str, Union[str, None]] = {self.start_point: None}            self.cost_so_far: Dict[str, float] = {self.start_point: 0}            self._last: np.ndarray = None            plt.show()        else:            print(f"{Fore.GREEN}Start drawing map{Style.RESET_ALL}")            plt.show()    def start(self):        """        Notes:            A* algorithm implementation        Returns:            None        """        if_can_find_goal: bool = False        # get the closest point        self._current_state = "searching"        self._update_title()        while not self.frontier.empty():            current_p: str = self.frontier.get()[1]            # find the goal            if current_p == self.goal_point:                if_can_find_goal = True                break            next_p: str            for next_p in (n := self._get_neighbor(current_p)):                new_cost = self.cost_so_far[current_p] + self._get_cost(next_p, current_p)                # if next point has not been considered / next point in in undiscovered area                # or there exists a nearer way to get to next point by passing current point                # this also can help preventing going back                if next_p not in self.cost_so_far.keys() or new_cost < self.cost_so_far[next_p]:                    self.cost_so_far[next_p] = new_cost                    priority = new_cost + self._get_cost(next_p, self.goal_point)                    self.frontier.put((priority, next_p))                    current_pp = [int(i) for i in current_p.split(",")]                    self.came_from[next_p] = f"{current_pp[0]},{current_pp[1]}"                    self._plot4searching()                    plt.pause(0.0001)                    self.update()        if not if_can_find_goal:            print(f"{Fore.RED}Cannot find the goal in current map{Style.RESET_ALL}")            self._update_title("STOP: cannot find the path!")            return        else:            # go back to find the path            self._current_state = "add_goal"            goal = (int(i) for i in self.goal_point.split(","))            self.add_patch(*goal)            self._current_state = "going_back"            self._update_title()            path = []            current_p = self.goal_point            while current_p != self.start_point:                current_p = self.came_from[current_p]                p = tuple(int(i) for i in current_p.split(","))                path.append(p)                self.add_patch(*p)            self._current_state = "add_start"            start = (int(i) for i in self.start_point.split(","))            self.add_patch(*start)        print(f"{Fore.BLUE}{Style.BRIGHT}Success!{Style.RESET_ALL}")        print("Path:")        pprint.pprint(path)        return path    def _get_neighbor(self, point: str):        from itertools import product        x, y = [int(i) for i in point.split(",")]        neighbor = []        for i, j in product([-1, 0, 1], [-1, 0, 1]):            if abs(i) + abs(j) == 0:                continue            if 0 <= (dx := x + i) <= self._mapsize[0] and 0 <= (dy := y + j) <= self._mapsize[1] and \                    self.map[dx, dy] != np.inf:                neighbor.append(f"{dx},{dy}")        return neighbor    def _get_cost(self, point1: str, point2: str):        # x, y = [int(i) for i in point.split(",")]        # return self.manhattan_distance(*[int(i) for i in point1.split(",")],        #                                *[int(i) for i in point2.split(",")])        return self.euler_distance(*[int(i) for i in point1.split(",")],                                   *[int(i) for i in point2.split(",")])    def _plot4searching(self):        """Codes for plotting"""        # update current map        # explore area        explored_ps = ([], [])        for p, parent in self.came_from.items():            pp = [int(i) for i in p.split(",")]            if parent is not None:                explored_ps[0].append(pp[0])                explored_ps[1].append(pp[1])        self.map[np.array(explored_ps[0]), np.array((explored_ps[1]))] = 1        # frontier        frontier_ps = ([], [])        t = []        while not self.frontier.empty():            t.append(self.frontier.get())        for i in t:            self.frontier.put(i)        for tt in t:            # frontier_ps.append(t.get()[1])            p = [int(i) for i in tt[1].split(",")]            frontier_ps[0].append(p[0])            frontier_ps[1].append(p[1])        # simply deepcopy locked object will raise an error        # t = copy.deepcopy(self.frontier)        self.map[np.array(frontier_ps[0]), np.array(frontier_ps[1])] = 2        # find difference        if self._last is None:            update_explored = list(zip(*np.where(self.map == 1)))            update_frontier = list(zip(*np.where(self.map == 2)))            # update_frontier = [(i,j) for i, j in zip(*update_frontier)]        else:            last_explored = list(zip(*np.where(self._last == 1)))            last_frontier = list(zip(*np.where(self._last == 2)))            current_explored = list(zip(*np.where(self.map == 1)))            current_frontier = list(zip(*np.where(self.map == 2)))            update_explored = list(set(current_explored) - set(last_explored))            update_frontier = list(set(current_frontier) - set(last_frontier))        self._last = self.map.copy()        # draw explored area        if len(update_explored) > 0:            self.add_patch(np.array([i[0] for i in update_explored]), np.array([i[1] for i in update_explored]),                           patches="explored")        # draw frontier        if len(update_frontier) > 0:            self.add_patch(np.array([i[0] for i in update_frontier]), np.array([i[1] for i in update_frontier]),                           patches="frontier")    @staticmethod    def manhattan_distance(x1, y1, x2, y2):        return abs(x2 - x1) + abs(y2 - y1)    @staticmethod    def euler_distance(x1, y1, x2, y2):        if (d := abs(x2 - x1) + abs(y2 - y1)) == 1:            return 1        elif d == 2:            return 1.4        else:            return round(np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2), ndigits=2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-命令行参数解析"><a href="#4-命令行参数解析" class="headerlink" title="4. 命令行参数解析"></a>4. 命令行参数解析</h3><p>命令行参数解析由parse_arg函数负责完成，并返回Namespace对象</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def parse_arg():    parer = argparse.ArgumentParser(        description=f"{Fore.GREEN}{Style.BRIGHT}A* Algorithm, animated with matplotlib{Style.RESET_ALL}. "                    f"Author: {Fore.YELLOW}Jack Wang{Fore.RESET}. "                    f"Date: {Fore.YELLOW}2021-12-15{Style.RESET_ALL}."                    "This script provides A* algorithm illustration with the help of matplotlib\n"                    f"You can use this script either by {Fore.GREEN}command-line interface{Fore.RESET} "                    f"or {Fore.GREEN}python code interface{Fore.RESET}."                    "To use this script with command-line interface, call this script with -h option. "                    "To use this script in python code, "                    "simply calling Astar class to create an Astar object, then everything will be done. "                    "If load_path argument of Astar class are not specified (i.e. load_path=None), "                    "this program will create a blank"                    "map for you, else loading an existing map."                    "\n\n"                    "In the matplotlib GUI, press 1 to add obstacle, 2 to add goal, 3 to add start, w to save map, "                    "r to random generate obstacles, d to delete an grid and v to start path planning. "                    f"{Fore.YELLOW}Note: when call with -c, you can not press v to start path planning, -c is only "                    f"for drawing map. {Style.RESET_ALL}")    parer.add_argument("-o", dest="ok", action="store_true", help="must be added when calling the scripts to let me "                                                                  "know you understand how to use this program")    parer.add_argument("-c", dest="gen_map", action="store_true", help="create a new map")    parer.add_argument("-l", dest="load_num", type=int, default=-1, help="load a existing map")    return parer.parse_args()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-主程序"><a href="#5-主程序" class="headerlink" title="5. 主程序"></a>5. 主程序</h3><p>主程序中若不提供加载的地图路径则默认打开新的地图用于地图绘制</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def main():    args = parse_arg()    if not args.ok:        print(f"{Fore.RED}Please read the help info with -h option the rerun the scripts with -o option{Fore.RESET}")        return    if args.gen_map:        Astar(load_path=None)        return    if args.load_num != -1:        Astar(load_path=Path(__file__).resolve().parent.joinpath(f"map_{args.load_num}.csv"))if __name__ == "__main__":    # a = Astar(load_path=Path("./map_4.csv"))    # a = Astar(load_path=Path(__file__).resolve().parent.joinpath("./map_1.csv"))    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> A* </tag>
            
            <tag> PathPlanning </tag>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼（Huffman Encoding）压缩算法-Python实现</title>
      <link href="/2021/12/21/ha-fu-man-ya-suo-suan-fa-python-shi-xian/"/>
      <url>/2021/12/21/ha-fu-man-ya-suo-suan-fa-python-shi-xian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要提供了Python版本的哈夫曼压缩算法实现，并在此基础上提供了命令行和基于Qt的GUI用户界面（User Interface）</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/all.gif" alt="完整效果"></p><h1 id="哈夫曼（Huffman-Encoding）压缩算法-Python实现"><a href="#哈夫曼（Huffman-Encoding）压缩算法-Python实现" class="headerlink" title="哈夫曼（Huffman Encoding）压缩算法-Python实现"></a>哈夫曼（Huffman Encoding）压缩算法-Python实现</h1><p>哈夫曼编码作为计算机届非常底层的算法，不少领域都会出现该算法的身影，例如在MPEG图片压缩算法中等等。因此掌握哈夫曼算法以及相关的哈弗曼编码、哈弗曼树实现还是比较必要的。</p><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>我目前是一个大二的计算机系学生，最近数据结构课程的配套实验要求学生从十四个题中选择四个来做。刚好最近学习了PyQt的相关内容，于是本着学习的目的把我完成的成果记录下来，希望我的这篇博客能够帮助大家学习与理解。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211221220005902.png" alt="数据结构算法实验"></p><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>所有的文件，包括MP3音频、MP4视频、PDF文档、乃至于可执行文件（Windows上的.EXE、Linux中的.O等ELF格式文件），对于计算机来说都是二进制数据流，即由0101的比特构成的流（Stream）。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211221222101136.png" alt="计算机底层以二进制形式存储文件"></p><p>然而二进制流对于计算机而言是有意义的，对人而言却没有多大的意义了，因为人看不懂二进制的字节流。于是为了解决这个问题，就出现了编码。所谓<strong>编码即指将信息从一种格式转换为另外一种格式而不改变其内容</strong>，更详细的介绍，参考下面百度百科和维基百科的介绍。</p><blockquote><p><strong>From Wikipedia</strong></p><p>编码是信息从一种形式或格式转换为另一种形式的过程；解码则是编码的逆过程。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211221221212302.png" alt="维基百科上对编码的介绍"></p><p><strong>From BaiduBaike</strong>:</p><p>编码是信息从一种形式或格式转换为另一种形式的过程，也称为计算机编程语言的代码简称编码。用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。编码在电子计算机、电视、遥控和通讯等方面广泛使用。编码是信息从一种形式或格式转换为另一种形式的过程。解码，是编码的逆过程。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211221221358810.png" alt="百度百科上对编码的介绍"></p></blockquote><p>因此，编码其实指的就是转变信息的形式而不改变信息的内容。之所以要进行编码与解码，就是因为对于不同的主体而言，不同编码方式的信息的阅读难度和理解难度不同。例如上面的三国演义，对于我们人而言，文字形式的三国演义易于理解而二进制形式的三国演义更利于计算机理解。</p><p>换个角度，其实语种之间的转换也是一种编码的转换。例如英语对于中文母语的人就不好理解。而翻译也是把信息从一种语言转换为另一种语言，其形式在变，但本质内涵的信息却没有变。<strong>所以究其根本，编码的目的在于方便信息的理解。</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211221230110176.png" alt="英文版的三国演义"></p><p>话说回来，要进行编码，就需要一张编码表。例如学C语言时候的ASCII表。我们通过编码表构建了两种不同编码之间的映射关系，因此单纯的ASCII字符的转换，就是数值的映射关系，从而通过数值-字符的转换，实现了编码与解码。其实从语言的角度来看，语言的编码不仅仅是单词的映射，还涉及语法的转换等等更加复杂的关系。</p><p>然而单纯的使用ASCII编码或者UTF8这种编码方式其实虽然很不错，计算机能够理解，但是他们的问题就是太浪费空间了。例如针对ASCII编码，每一个字符需要8个比特位（0-255）。因此哈夫曼编码除了方便计算机理解以外，更大的好处是能够节约空间。</p><p>说了这么久，总算是说到了哈夫曼编码，哈夫曼编码其实就是一种编码，和ASCII编码在本质上没有区别的。</p><h2 id="2-哈夫曼算法-Huffman-Coding"><a href="#2-哈夫曼算法-Huffman-Coding" class="headerlink" title="2. 哈夫曼算法 / Huffman Coding"></a>2. 哈夫曼算法 / Huffman Coding</h2><p>关于哈夫曼编码和对应的哈夫曼算法就不赘述了，在数据结构的课本上其实讲得非常好也非常的透彻。下面就放一下百度百科和维基百科的介绍</p><blockquote><p><strong>From Wikipedia</strong>：</p><p>霍夫曼编码（英语：Huffman Coding），又译为哈夫曼编码、赫夫曼编码，是一种用于无损数据压缩的熵编码（权编码）算法。由美国计算机科学家大卫·霍夫曼（David Albert Huffman）在1952年发明。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211221231837051.png" alt="维基百科上哈夫曼编码的介绍"></p><p><strong>From BaiduBaike</strong>：</p><p>哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211221231927090.png" alt="百度百科上哈夫曼编码的介绍"></p></blockquote><h2 id="3-实现思路"><a href="#3-实现思路" class="headerlink" title="3. 实现思路"></a>3. 实现思路</h2><p>针对不同的功能，整个程序的实现，主要分为三个层面：</p><ol><li><strong>核心层</strong>：负责哈夫曼算法的实现</li><li><strong>数据存取层</strong>：负责任意形式数据的读取、保存</li><li><strong>用户界面层</strong>：负责提供命令行用户界面以及图形用户接口，从而实现<del>高级感</del>（逼格）</li></ol><h3 id="A-核心层"><a href="#A-核心层" class="headerlink" title="A. 核心层"></a>A. 核心层</h3><p>核心层的任务其实就是构建哈弗曼树、得到哈夫曼编码即可，主要算法其实在数据结构课本、B站视频、知乎上都有不少介绍。 </p><p>然而一个重要的问题就是课本上和B站中的不少介绍视频都是针对字符（字母）进行哈夫曼编码的。我们由于要对任意格式的文件进行编码，因此就要从数据的本源：字节，进行哈夫曼编码。因此我们哈弗曼树的叶子节点实际上是字节。我们以8位二进制作为一个单元（Symbol）。然后针对这个Symbol进行编码。因此我们编码的对象就从26个字母变成了256种八位二进制数字。换而言之我们是对0~255这256个数字进行编码。</p><p>然后根据得到的哈夫曼编码将原字节数据一个字节（八位比特）进行编码、转换为哈夫曼编码即可。</p><h3 id="B-数据存取层"><a href="#B-数据存取层" class="headerlink" title="B. 数据存取层"></a>B. 数据存取层</h3><p>在数据存取层，我们假设现在已经对原数据（raw data）构建出了哈弗曼树并且得到了原数据的哈弗曼编码，而且根据这些哈夫曼编码得到了原数据的哈夫曼编码字节流。我们在数据存取层需要做的就是</p><ol><li>保存转换后的新的哈夫曼编码的字节流</li><li>读取原始数据的二进制字节流</li><li>保存哈夫曼编码表</li></ol><p>读取原始数据的二进制字节流其实问题不大，Python中以rb（read byte）模式打开文件即可。而哈夫曼编码表的保存则可以利用Python的Pickle模块将Python中的对象保存到磁盘/从磁盘中加载（我们以字典/映射的形式保存编码表）</p><p>因此数据存取层的关键就在于如何保存编码后的哈夫曼编码字节流？这个问题看似简单，其实有一个问题，就是（二进制）数据在计算机外存（固态、硬盘）中的保存都是整字节整字节的保存的，读取也是整字节整字节读取的。而我们对原文件的二进制流进行哈夫曼编码后实际上其长度是不定的，不一定是整字节的。</p><p>因此保存的时候虽然我们可以强行以整字节整字节的保存编码后的二进制流，但是在最后一位由于不一定是一个整字节，因此实际上存在问题。为了处理这个问题，我们设定一个特殊的字符EOF，由于8位二进制能表示256个数字（Symbol），而这些数字都有可能出现在原字节流中，因此我们是不能直接选取一个数字来表示文件结尾的。为此，在Python中，通过一个特定的类来实现文件结尾的表示，即我们自定义的EOF。在大文件（几MB的文件）中，一共有1024*1024个字节，因此从0~255这256个数字出现的次数一定是远远大于1的，而EOF的出现次数永远为1，因此必然会拥有最长的编码。</p><p>在我们转换完所有的原数据之后，我们把EOF添加到末尾去，并且如果最后不满足8位的话在最后补0。而在读取的时候，我们只需要获取最长长度的编码的长度，然后对最后一个字节做截取即可得到正确的完整的带有EOF的编码的编码后的原数据的哈夫曼编码字节流。</p><h3 id="C-用户界面层"><a href="#C-用户界面层" class="headerlink" title="C. 用户界面层"></a>C. 用户界面层</h3><p>在用户界面层，不关心具体的哈夫曼编码的实现、数据的保存方式等这些具体的细节。相比，用户界面层仅关注如何提供一个用户友好的用户界面。例如在终端（Terminal）提供选项，让用户制定压缩、解压的文件。还会检查用户指定的文件是否存在、查找用户需要解码的文件对应的的哈弗曼编码表的文件位置。</p><p>当然，GUI使用会让程序显得非常高级，因此GUI部分是必须的。而完成GUI程序，则借助Qt来完成，即使用Qt的Python Binding。</p><p>当然，为了便于写代码管理与开发，需要注意GUI的代码要与完成功能的代码在逻辑和形式上分离，因此采取前面所说的分层的思想。</p><p>因此将GUI作为用户界面层的一个组件（另一个组件为终端命令行接口），调用由数据存取层提供的接口函数完成功能。</p><p>在GUI内部，进行在GUI窗口上发生的事件的监听，以及轮转调度、回调函数调用等等功能。</p><h2 id="4-具体代码"><a href="#4-具体代码" class="headerlink" title="4. 具体代码"></a>4. 具体代码</h2><p>本部分根据上面的讲解，对照代码进行详细的介绍。</p><p>项目结构如下</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(base) jack@Alienware:~/projects/data_structure/11_huffman$ tree -L 2.├── ErrorHuffman.py├── huff.py├── resources│   ├── 三国演绎.txt│   ├── D_Star_illustration.pptx│   ├── ICRA2022.pdf│   ├── romance_of_three_kingdoms.rar│   ├── Song.mp3│   ├── str.txt│   └── test.mp4├── ui│   └── main.ui└── Ui_main.py2 directories, 11 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li>resource为项目资源文件夹，主要存放稍后用于验证压缩的资源，包括MP4、txt、MP3、rar、PDF等多种格式文件</li><li>ui为程序图形界面配置文件，负责设定界面大小、按钮位置等配置参数。而UI_main为具体的按钮等控件的实现代码</li><li>huff.py为最终的程序，内含所有完整代码；errHuff.py为先前写错的代码，问题出在了哈夫曼建树的时候得到的不是范式哈弗曼树，因此该程序遍历哈弗树得到哈夫曼编码的时候有问题，最后压缩出来的文件比源文件大了好几倍（反向压缩。。。应了刘某的反向抽烟XXX<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</li></ul><h3 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1. 导入库"></a>1. 导入库</h3><p>主要导入的库为命令行参数获取库argparse、Python对象序列化库Pickle、路径处理库pathlib、堆管理库heapq、GUI库PyQt以及为了更好的显示得到的哈夫曼编码表的pandas库与命令行彩色输出的colorama库。</p><p>最后定义了文件的私有变量设定作者和日期，以及将可能存在源代码的文件加入文件搜索路径（类似于Linux环境变量LD_LIBRARY_PATH）</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import sysimport pickleimport argparseimport itertoolsimport collectionsfrom pathlib import Pathfrom heapq import heapify, heappush, heappopfrom typing import Union, Any, Dict, List, Tuplefrom PyQt5.QtCore import QDirimport pandasimport pandas as pdfrom colorama import Fore, Stylefrom PyQt5.QtWidgets import *__author__ = "Jack Wang"__date__ = "2021/12/19"sys.path.append(Path(__file__).resolve().parent.joinpath("./ui").__str__())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-定义EOF符号"><a href="#2-定义EOF符号" class="headerlink" title="2. 定义EOF符号"></a>2. 定义EOF符号</h3><p>EOF符号由于和0-255个数字一样将在构建树的进行比较，因此需要重载如等于（__eq__）、大于(__gt__)、小于(__lt__)等运算符。在Python中重载运算符以魔术方法（double underline）实现。最后由于在序列化以及字典中保存符号-哈夫曼编码键值对的时候，符号作为字典的键需要时可哈希的对象（Hashable），因此重写__hash__方法，以实现作为字典的键。</p><p>注意，上面说过了EOF需要保证编码是最长的，因此当合别人比大的时候总是False，比小的时候总是True，并且只会等于同样是EOF的对象</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class _EOFSymbol:    """    Notes:        _EOFSymbol 是内置的文件结尾的类，用于在编码的时候标志文件的结尾。        由于在进行哈夫曼树的构建的时候需要选出来权最小的节点，因此需要重写比较的魔术方法。        默认文档结尾是频率最少的字符，因此和任何数字比较    """    def __repr__(self):        return "_EOF"    def __lt__(self, other):        return True    def __gt__(self, other):        return False    def __eq__(self, other):        return self.__class__ == other.__class__    def __hash__(self):        return hash(self.__class__)_EOF = _EOFSymbol()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-哈夫曼编码"><a href="#3-哈夫曼编码" class="headerlink" title="3. 哈夫曼编码"></a>3. 哈夫曼编码</h3><p>采用工厂模式，实现哈夫曼编码与解码的核心对象为_HuffmanCoder，与用于构建_HuffmanCoder的HuffmanFactory类。</p><p>_HuffmanCoder类负责：</p><ul><li>输出/打印哈夫曼编码表：get_code_table方法、print_code_table方法</li><li>编码、解码字节流序列：_encode_streaming方法、_decode_streaming方法</li><li>为用户界面层提供统一接口：encode方法、decode方法</li><li>保存、加载哈夫曼编码表：save方法、load方法</li></ul><p>其初始化参数负责接受已经获得的编码表和符号的拼接方式以及eof符号定义</p><p>此外save方法通过Python内建的字典将类的元数据保存到字典中，并利用Python的Pickle模块序列化到磁盘上。而load方法则通过类方法，在通过Pickle加载通过save方法保存到磁盘上的数据后显示调用类的初始化方法以实现_HuffmanCoder类的重构。</p><p>此外，在保存的时候需要确保保存的文件的路径存在，因此编写ensure_dir函数，而_guess_concat_function则是为支持多种类型的Symbol（字符串、二进制流（串））在编码、解码时候拼接所写的函数，即根据输入的类型来获得拼接方法的函数。</p><p>HuffmanCoderFactory类负责：</p><ul><li>获得哈夫曼编码表：from_frequencies方法</li><li>创建_HuffmanCoder类：from_sequence方法、from_frequencies方法。</li></ul><p>其中from_frequencies接受符号-频数键值对并构建哈弗曼树、获得哈夫曼编码表；from_sequence负责统计序列中的符号的频数，由于需要对任意的数据进行压缩，因此符号即指一个字节。</p><p>在进行构建的时候，利用优先队列，以出现频率作为优先级进行排列，每次pop都会获得优先队列顶的元素，即出现频率最小的元素。</p><p>而队列中的每个元素，则是一个元组，元祖的第一个元素为权值（频率），<strong>第二个元素为以该节点为祖宗的叶子节点的二进制编码（以数字形式表现）和对应的比特位数（所处的哈弗曼树的层数/深度）对</strong>。使用数字是由于位移操作方便构建哈弗曼编码而记录比特位数则是为了记录开头为0的哈夫曼编码的总位数。</p><p>具体流程为只要队列（森林）中的节点多于1个，则首先弹出权值较小的子树a与权值较大的子树b，将子树a与b的频率相加作为新的子树的频率，而后将子树a的所有的叶子节点的深度+1（比特位数），然后在原二进制编码前加上0（维持不变）。而对子树b，将其所有的叶子节点的二进制编码前加上1（将1左移原有比特位数（原有深度），然后加上当前二进制编码），最后将其深度（比特位数）加1。即使用递归的方式完成哈弗曼树的构建与哈夫曼编码的同步获取。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def _guess_concat_function(data):    """    Notes:        To support multiple types of input, e.g., str, bytes, list, there must be a        function that return the needed concat function    Returns:        pass    """    return {type(u""): u"".join, type(b""): bytes}.get(type(data), list)def ensure_dir(path: Union[str, Path]) -> Path:    path: Path = path if isinstance(path, Path) else Path(path)    if not path.exists():        path.mkdir(parents=True)    assert path.is_dir()    return pathclass _HuffmanCoder:    """    Notes:        _HuffmanCoder, which provide encode, decode, serialize, deserialize, save_code, load_code functionalities.    Args:    """    def __init__(self, code_table: Dict[Any, Tuple[int, int]], concat=list, check=True, eof=_EOF):        """        Notes:            initialize method of _HuffmanCoder with given code table        Args:            code_table (Dict[Any, Tuple[int, int]]): code table of all symbols in the encoding sequence, create automatically by                HuffmanCoderFactory, items are Tuple[Symbol, [depth, bit]]            concat: concat method of symbols, will be automatically determined in HuffmanCoderFactory            check: valid code table's format            eof: eof symbol, leave it alone        """        self._table = code_table        self._concat = concat        self._eof = eof        if check:            assert isinstance(self._table, dict), f"{Fore.RED}Code table need to be a dict!{Style.RESET_ALL}"            assert all(                isinstance(b, int) and b >= 1 and isinstance(v, int) and v >= 0 for (b, v) in self._table.values()            ), f"{Fore.RED}Code table internal format Error!{Style.RESET_ALL}"    def get_code_table(self) -> Dict[Any, Tuple[int, int]]:        """        Notes:            get_code_table returns code table of input sequence        Returns:            self._table        """        return self._table    def print_code_table(self, verbose=False) -> pandas.DataFrame:        """        Notes:            print_code_table is used to print code table        Args:            verbose (bool): if True, then print the table in a pretty format        Returns:            pd.DataFrame        """        pd.options.display.max_rows = None        columns = list(zip(*list(zip(*itertools.chain(            [("Symbol", "Huff Code", "BitSize")], (                (repr(symbol), bin(val)[2:].rjust(bits, "0"), str(bits))                for symbol, (bits, val) in self._table.items()            )        )))))        df = pd.DataFrame(columns[1:], columns=columns[0])        if verbose:            print(df)        return df    def _encode_streaming(self, raw_sequence):        size = 0        buffer = 0        for s in raw_sequence:            bits, values = self._table[s]            buffer = (buffer << bits) + values            size += bits            while size >= 8:                byte = buffer >> (size - 8)                yield byte                buffer = buffer - (byte << (size - 8))                size -= 8        if size > 0:            bit, value = self._table[self._eof]            buffer = (buffer << bit) + value            size += bit            if size > 8:                byte = buffer >> (size - 8)            else:                byte = buffer << (8 - size)            yield byte    def _decode_streaming(self, encoded_sequence):        # Reverse lookup table: map (bitsize, value) to symbols        lookup = {(b, v): s for s, (b, v) in self._table.items()}        buffer = 0        size = 0        for byte in encoded_sequence:            for m in [128, 64, 32, 16, 8, 4, 2, 1]:                buffer = (buffer << 1) + bool(byte & m)                size += 1                if (size, buffer) in lookup:                    symbol = lookup[size, buffer]                    if symbol == self._eof:                        return                    yield symbol                    buffer = 0                    size = 0    def encode(self, raw_seq):        """        Notes:            encode is used to encode the sequence that build the huffman tree        Args:            raw_seq: sequence that build the huffman tree        Returns:            bytes        """        return bytes(self._encode_streaming(raw_seq))    def decode(self, encoded_seq, concat=None):        return (concat or self._concat)(self._decode_streaming(encoded_seq))    def save(self, path: Union[str, Path], metadata: Any = None):        code_table = self.get_code_table()        data = {            "code_table": code_table,            "type": type(self),            "concat": self._concat,        }        if metadata:            data['metadata'] = metadata        path = Path(path)        ensure_dir(path.parent)        with path.open(mode='wb') as f:            pickle.dump(data, file=f)    @staticmethod    def load(path: Union[str, Path]) -> '_HuffmanCoder':        path = Path(path)        with path.open(mode='rb') as f:            data = pickle.load(f)        cls = data['type']        assert issubclass(cls, _HuffmanCoder)        code_table = data['code_table']        return cls(code_table, concat=data['concat'])class HuffmanCoderFactory(_HuffmanCoder):    """    Notes:        HuffmanCodecFactory is the class that create HuffmanCoder from different type of inputs    Methods:        from_frequencies: create HuffmanCoder from frequency table    """    @classmethod    def from_frequencies(cls, frequencies: Dict[Any, int], concat=None, eof=_EOF):        """        Notes:            from_frequencies creates huffman codec by symbol-frequency table/mapping.        Args:            frequencies (Dict[Any, int]): Symbols and its frequency, symbols can be str, bytes or int, etc.            concat (Union[None]): concat method of symbols, will be determined by the function if argument is not                specified            eof (_EOFSymbol): leave it alone.        Returns:            __HuffmanCoder        Examples:            >>> huf_coder = HuffmanCoderFactory.from_frequencies({"a":29, "b":10, "c": 5})            >>> type(huf_coder)        """        concat_function = concat if concat is not None else _guess_concat_function(next(iter(frequencies)))        # build huffman tree node heap        # each item: (frequency, [(symbol, (bitsize, value))], value equals which layer of the tree        heap: List[Tuple[int, List[Tuple[Any, Tuple[int, int]]]]] = [(freq, [(symbol, (0, 0))]) for symbol, freq in                                                                     frequencies.items()]        # add eof        if eof not in frequencies:            heap.append((1, [(eof, (0, 0))]))        heapify(heap)        while len(heap) > 1:            # get first 2 min as left and right child tree            a: Tuple[int, List[Tuple[Any, Tuple[int, int]]]] = heappop(heap)            b: Tuple[int, List[Tuple[Any, Tuple[int, int]]]] = heappop(heap)            # merge child to form parent            # parent frequencies adds together, left child add 0 ahead (do nothing) of previous bits            # right add 1 ahead of previous bits            merged = (                a[0] + b[0],                [(s, (n + 1, v)) for (s, (n, v)) in a[1]] + [(s, (n + 1, (1 << n) + v)) for (s, (n, v)) in b[1]]            )            heappush(heap, merged)        # code table is root        table = dict(heappop(heap)[1])        return cls(table, concat=concat, check=False, eof=eof)    @classmethod    def from_sequence(cls, sequence: Union[List[Any], Tuple[Any], str, bytes]):        """        Notes:            from_sequence will build a huffman tree from a sequence of symbol        Args:            sequence (Union[List, Tuple][Any]):        Returns:            __HuffmanCoder        Examples:            >>> seq = "a"*100 + "b"*29 + "c"*32            >>> coder = HuffmanCoderFactory.from_sequence(seq)        """        frequencies = collections.Counter(sequence)        return cls.from_frequencies(frequencies, concat=_guess_concat_function(sequence))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-哈夫曼编码层接口"><a href="#4-哈夫曼编码层接口" class="headerlink" title="4. 哈夫曼编码层接口"></a>4. 哈夫曼编码层接口</h3><p>为实现GUI与哈弗曼编码解耦，在前面哈夫曼编码的核心类的基础上，编写哈弗曼编码接口函数，完成编码、解码一步到位</p><p>其中：</p><ul><li>encode负责读取文件的二进制流、压缩、输出压缩时的摘要信息</li><li>decode负责读取文件的二进制流、解压、输出解压时的摘要信息</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def encode(path: Union[str, Path], verbose: bool=True):    assert (path := Path(path)).exists(), f"{Fore.RED}{path} not exists!{Style.RESET_ALL}"    with path.open(mode="rb") as f:        content = f.read()    coder = HuffmanCoderFactory.from_sequence(content)    byte = coder.encode(content)    if not (out_fd := path.resolve().parent / (path.stem + "_huf")).exists():        out_fd.mkdir(parents=True)    with (main_path := out_fd.joinpath(path.stem + "_" + path.suffix[1:] + ".huf")).open("wb") as f:        f.write(byte)    coder.save(coder_path := out_fd.joinpath(path.stem + "_coder.huf"))    b1 = path.stat().st_size    b2 = main_path.stat().st_size    b3 = coder_path.stat().st_size    summary1, summary2, summary3, summary4 = [""]*4    if verbose:        summary1 = f"Origin file: {path.stem}{path.suffix}, byte size: {b1}"        summary2 = f"Compressed file: {main_path.stem}{main_path.suffix}, byte size: {b2}"        summary3 = f"HuffCoder file: {coder_path.stem}{coder_path.suffix}, byte size: {b3}"        summary4 = f"{Fore.GREEN}Compression rate {b2}/{b1}={Style.BRIGHT}{round(b2/b1, 4)*100}%{Style.NORMAL}" +\                f", saved {Style.BRIGHT}{b1-b2}{Style.RESET_ALL} bytes"        print(s := "Summary".center(max([len(summary1), len(summary2), len(summary3), len(summary4)]), "="))        print("\n".join((summary1, summary2, summary3, summary4)))        print("="*len(s))    return b1, b2, b3, coderdef decode(huf_path: Union[Path, str], coder_path: Union[Path, str], verbose: bool=True):    huf_path, coder_path = Path(huf_path), Path(coder_path)    coder = _HuffmanCoder.load(coder_path)    with huf_path.open(mode="rb") as f:        content = f.read()    decoded = coder.decode(content)    with (dec_path := huf_path.parent.joinpath((s := huf_path.stem.split("_"))[0] + f"_decode.{s[1]}")).open(mode="wb") as f:        f.write(decoded)    b1 = huf_path.stat().st_size    b2 = coder_path.stat().st_size    b3 = dec_path.stat().st_size    if verbose:        summary1 = f"Origin file: {huf_path.stem}{huf_path.suffix}, byte size: {b1}"        summary2 = f"Coder file: {coder_path.stem}{coder_path.suffix}, byte size: {b2}"        summary3 = f"Decompressed file: {dec_path.stem}{dec_path.suffix}, byte size: {b3}"        summary4 = f"{Fore.GREEN}Decompression rate {b3}/{b1}={Style.BRIGHT}{round(b3/b1, 4)*100}%{Style.NORMAL}" +\                f", lost {Style.BRIGHT}{b3-b1}{Style.RESET_ALL} bytes"        print(s := "Summary".center(max([len(summary1), len(summary2), len(summary3), len(summary4)]), "="))        print("\n".join((summary1, summary2, summary3, summary4)))        print("="*len(s))    return b1, b2, b3, coder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-用户接口层"><a href="#5-用户接口层" class="headerlink" title="5. 用户接口层"></a>5. 用户接口层</h3><p>用户接口层负责提供命令行用户界面以及GUI用户界面</p><h4 id="A-GUI用户界面"><a href="#A-GUI用户界面" class="headerlink" title="A. GUI用户界面"></a>A. GUI用户界面</h4><p>GUI用户界面由于会接管程序流的控制，因此以类的形式进行封装。</p><p>其中：</p><ul><li>initUI方法负责窗口的UI设计、按钮等控件的信号对应的槽函数（信号处理函数）的绑定</li><li>fileDialog方法负责暂时接管程序流，以GUI的形式帮助用户进行文件的选择，以Dialog的形式暂时接管程序运行</li><li>compress方法作为压缩按钮的槽函数，负责文件的压缩，在进行文件路径检查（文件存在）之后，调用哈夫曼编码层提供的接口函数进行压缩，并将摘要信息输出到程序显示框内</li><li>decompress方法作为解压按钮的槽函数，负责文件的解压，在进行文件路径检查（压缩文件以及哈夫曼编码表文件均存在）之后，调用哈夫曼编码层提供的接口函数进行解压，并将摘要信息输出到程序显示框内</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class QtGUIHuff(QMainWindow):    def __init__(self) -> None:        super().__init__()        self.initUI()    def initUI(self):        from Ui_main import Ui_Form        self.ui = Ui_Form()        self.ui.setupUi(self)        self.setWindowTitle("哈夫曼压缩/解压缩程序")        self.ui.compress.clicked.connect(self.compress)        self.ui.decompress.clicked.connect(self.decompress)    def fileDialog(self):        dialog = QFileDialog()        dialog.setFileMode(QFileDialog.AnyFile)        dialog.setFilter(QDir.Files)        if dialog.exec():            filename = dialog.selectedFiles()            return Path(filename[0])        else:            return False    def compress(self):        f_path = self.fileDialog()        self.ui.textEdit.setReadOnly(True)        s = ["开始压缩"]        self.ui.textEdit.setText("\n".join(s))        result = encode(f_path)        summary1 = f"Origin file: {f_path.stem}{f_path.suffix}, byte size: {result[0]}"        summary2 = f"Compressed file:  byte size: {result[1]}"        summary3 = f"HuffCoder file: , byte size: {result[2]}"        summary4 = f"Compression rate {result[1]}/{result[0]}={round(result[1]/result[0], 4)*100}%" + \                f", saved {result[0] - result[1]} bytes"        self.ui.textEdit.setText("\n".join([*s, summary1, summary2, summary3, summary4, "压缩结束"]))        self.ui.textEdit_2.setText(result[-1].print_code_table(verbose=False).__str__())    def decompress(self):        f_path = self.fileDialog()        if f_path.suffix != ".huf":            QMessageBox.warning(self, "警告", "请选择正确的压缩文件路径", QMessageBox.Yes, QMessageBox.Yes)            return False        if len(ps := list(Path(f_path).parent.glob("*.huf"))) == 2:            print(ps)            for p_idx in range(len(ps)):                if "coder" in ps[p_idx].stem:                    cp_idx = p_idx        else:            QMessageBox.warning(self, "警告", "缺少必要的解压缩文件", QMessageBox.Yes, QMessageBox.Yes)            return False        s = ["开始解压"]        import time        time.sleep(1)        self.ui.textEdit.setText("\n".join(s))        result = decode(huf_path:=ps[1-cp_idx], coder_path:=ps[cp_idx])        summary1 = f"Origin file: {huf_path.stem}{huf_path.suffix}, byte size: {result[0]}"        summary2 = f"Coder file: {coder_path.stem}{coder_path.suffix}, byte size: {result[1]}"        summary3 = f"Decompressed file: byte size: {result[2]}"        summary4 = f"Decompression rate {result[2]}/{result[0]}={round(result[2]/result[0], 4)*100}%" +\                f", lost {result[2] - result[0]} bytes"        self.ui.textEdit.setText("\n".join([*s, summary1, summary2, summary3, summary4, "解压结束"]))        self.ui.textEdit_2.setText(result[-1].print_code_table(verbose=False).__str__())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="B-Terminal用户界面"><a href="#B-Terminal用户界面" class="headerlink" title="B. Terminal用户界面"></a>B. Terminal用户界面</h4><p>Terminal用户界面则是以argparse库中的ArgumentParser对象完成命令行参数的接受，稍后在主程序中配合完成用户界面。设定了-h参数输出帮助信息、-s对指定路径的文件进行压缩、-t对指定路径的文件进行解压、-g以GUI用户界面运行程序，-v将压缩/解压摘要输出到命令行窗口</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def parse_args() -> argparse.Namespace:    parser = argparse.ArgumentParser(        description="哈夫曼压缩算法Python实现，可以对任意文件进行压缩，提供命令行以及GUI用户界面。作者：Jack Wang"    )    parser.add_argument("-s", "--src", dest="src_path", type=str, default=None, help="需要压缩的文件路径")    parser.add_argument("-t", "--target", dest="target_path", type=str, default=None, help="需要解压文件所在的文件夹的路径")    parser.add_argument("-v", "--verbose", dest="v", action="store_true", help="是否显示压缩的摘要信息")    parser.add_argument("-g", "--gui", dest="gui", action="store_true", help="是否以GUI方式显示")    return parser.parse_args()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-主程序"><a href="#6-主程序" class="headerlink" title="6. 主程序"></a>6. 主程序</h3><p>主程序很简单，根据接受的命令行参数调用不同的接口即可</p><p>在非图形界面的运行的时候，程序的主控制流以程序为主，而以GUI方式运行的时候，程序的控制流则在Qt框架下，用户级线程调度、事件监听、信号分发、槽函数（信号处理函数）唤醒等均由框架负责。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def main(args: argparse.Namespace):    if not args.gui:        assert 0 < int(args.src_path is not None) + int(args.target_path is not None), f"{Fore.RED}请选择压缩或者解压，使用-h查询用法{Style.RESET_ALL}"    if not args.gui:        print(f"{Fore.GREEN}命令行工作模式{Style.RESET_ALL}")        if args.src_path is not None:            print(f"开始压缩 {args.src_path}")            if args.v:                print(encode(Path(args.src_path))[-1].print_code_table(verbose=False))            else:                encode(Path(args.src_path), verbose=False)            print("压缩完成")        elif args.target_path is not None:            if len(ps := list(Path(args.target_path).glob("*.huf"))) == 2:                print(ps)                for p_idx in range(len(ps)):                    if "coder" in ps[p_idx].stem:                        cp_idx = p_idx            else:                assert False, f"{Fore.RED}无效的路径，没有找到压缩文件{Style.RESET_ALL}"            print(f"开始解压 {args.target_path}")            if args.v:                print(decode(huf_path=ps[1-cp_idx], coder_path=ps[cp_idx])[-1].print_code_table(verbose=False))            else:                decode(huf_path=ps[1-cp_idx], coder_path=ps[cp_idx], verbose=False)            print("解压完成")    else:        app = QApplication(sys.argv)        m = QtGUIHuff()        m.show()        sys.exit(app.exec_())if __name__ == "__main__":    main(parse_args())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-运行实例"><a href="#5-运行实例" class="headerlink" title="5. 运行实例"></a>5. 运行实例</h2><h3 id="A-GIF版演示"><a href="#A-GIF版演示" class="headerlink" title="A. GIF版演示"></a>A. GIF版演示</h3><p> 这里先放一个gif图片（比较大，44兆，不知道能不能加载出来），高清版本去下面的B站视频里看看</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/哈夫曼算法压缩任意文件演示.gif" alt=""></p><h3 id="B-B站高清版"><a href="#B-B站高清版" class="headerlink" title="B. B站高清版"></a>B. B站高清版</h3><p><a href="https://www.bilibili.com/video/BV1cL41177zL/">视频链接</a>：<a href="https://www.bilibili.com/video/BV1cL41177zL/">https://www.bilibili.com/video/BV1cL41177zL/</a></p><iframe src="//player.bilibili.com/player.html?aid=465019836&amp;bvid=BV1cL41177zL&amp;cid=465905780&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="6-完整代码"><a href="#6-完整代码" class="headerlink" title="6. 完整代码"></a>6. 完整代码</h2><p>完整代码如下</p><h3 id="A-huff-py"><a href="#A-huff-py" class="headerlink" title="A. huff.py"></a>A. huff.py</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import sysimport pickleimport argparseimport itertoolsimport collectionsfrom pathlib import Pathfrom heapq import heapify, heappush, heappopfrom typing import Union, Any, Dict, List, Tuplefrom PyQt5.QtCore import QDirimport pandasimport pandas as pdfrom colorama import Fore, Stylefrom PyQt5.QtWidgets import *__author__ = "Jack Wang"__date__ = "2021/12/19"sys.path.append(Path(__file__).resolve().parent.joinpath("./ui").__str__())class _EOFSymbol:    """    Notes:        _EOFSymbol 是内置的文件结尾的类，用于在编码的时候标志文件的结尾。        由于在进行哈夫曼树的构建的时候需要选出来权最小的节点，因此需要重写比较的魔术方法。        默认文档结尾是频率最少的字符，因此和任何数字比较    """    def __repr__(self):        return "_EOF"    def __lt__(self, other):        return True    def __gt__(self, other):        return False    def __eq__(self, other):        return self.__class__ == other.__class__    def __hash__(self):        return hash(self.__class__)_EOF = _EOFSymbol()def _guess_concat_function(data):    """    Notes:        To support multiple types of input, e.g., str, bytes, list, there must be a        function that return the needed concat function    Returns:        pass    """    return {type(u""): u"".join, type(b""): bytes}.get(type(data), list)def ensure_dir(path: Union[str, Path]) -> Path:    path: Path = path if isinstance(path, Path) else Path(path)    if not path.exists():        path.mkdir(parents=True)    assert path.is_dir()    return pathclass _HuffmanCoder:    """    Notes:        _HuffmanCoder, which provide encode, decode, serialize, deserialize, save_code, load_code functionalities.    Args:    """    def __init__(self, code_table: Dict[Any, Tuple[int, int]], concat=list, check=True, eof=_EOF):        """        Notes:            initialize method of _HuffmanCoder with given code table        Args:            code_table (Dict[Any, Tuple[int, int]]): code table of all symbols in the encoding sequence, create automatically by                HuffmanCoderFactory, items are Tuple[Symbol, [depth, bit]]            concat: concat method of symbols, will be automatically determined in HuffmanCoderFactory            check: valid code table's format            eof: eof symbol, leave it alone        """        self._table = code_table        self._concat = concat        self._eof = eof        if check:            assert isinstance(self._table, dict), f"{Fore.RED}Code table need to be a dict!{Style.RESET_ALL}"            assert all(                isinstance(b, int) and b >= 1 and isinstance(v, int) and v >= 0 for (b, v) in self._table.values()            ), f"{Fore.RED}Code table internal format Error!{Style.RESET_ALL}"    def get_code_table(self) -> Dict[Any, Tuple[int, int]]:        """        Notes:            get_code_table returns code table of input sequence        Returns:            self._table        """        return self._table    def print_code_table(self, verbose=False) -> pandas.DataFrame:        """        Notes:            print_code_table is used to print code table        Args:            verbose (bool): if True, then print the table in a pretty format        Returns:            pd.DataFrame        """        pd.options.display.max_rows = None        columns = list(zip(*list(zip(*itertools.chain(            [("Symbol", "Huff Code", "BitSize")], (                (repr(symbol), bin(val)[2:].rjust(bits, "0"), str(bits))                for symbol, (bits, val) in self._table.items()            )        )))))        df = pd.DataFrame(columns[1:], columns=columns[0])        if verbose:            print(df)        return df    def _encode_streaming(self, raw_sequence):        size = 0        buffer = 0        for s in raw_sequence:            bits, values = self._table[s]            buffer = (buffer << bits) + values            size += bits            while size >= 8:                byte = buffer >> (size - 8)                yield byte                buffer = buffer - (byte << (size - 8))                size -= 8        if size > 0:            bit, value = self._table[self._eof]            buffer = (buffer << bit) + value            size += bit            if size > 8:                byte = buffer >> (size - 8)            else:                byte = buffer << (8 - size)            yield byte    def _decode_streaming(self, encoded_sequence):        # Reverse lookup table: map (bitsize, value) to symbols        lookup = {(b, v): s for s, (b, v) in self._table.items()}        buffer = 0        size = 0        for byte in encoded_sequence:            for m in [128, 64, 32, 16, 8, 4, 2, 1]:                buffer = (buffer << 1) + bool(byte & m)                size += 1                if (size, buffer) in lookup:                    symbol = lookup[size, buffer]                    if symbol == self._eof:                        return                    yield symbol                    buffer = 0                    size = 0    def encode(self, raw_seq):        """        Notes:            encode is used to encode the sequence that build the huffman tree        Args:            raw_seq: sequence that build the huffman tree        Returns:            bytes        """        return bytes(self._encode_streaming(raw_seq))    def decode(self, encoded_seq, concat=None):        return (concat or self._concat)(self._decode_streaming(encoded_seq))    def save(self, path: Union[str, Path], metadata: Any = None):        code_table = self.get_code_table()        data = {            "code_table": code_table,            "type": type(self),            "concat": self._concat,        }        if metadata:            data['metadata'] = metadata        path = Path(path)        ensure_dir(path.parent)        with path.open(mode='wb') as f:            pickle.dump(data, file=f)    @staticmethod    def load(path: Union[str, Path]) -> '_HuffmanCoder':        path = Path(path)        with path.open(mode='rb') as f:            data = pickle.load(f)        cls = data['type']        assert issubclass(cls, _HuffmanCoder)        code_table = data['code_table']        return cls(code_table, concat=data['concat'])class HuffmanCoderFactory(_HuffmanCoder):    """    Notes:        HuffmanCodecFactory is the class that create HuffmanCoder from different type of inputs    Methods:        from_frequencies: create HuffmanCoder from frequency table    """    @classmethod    def from_frequencies(cls, frequencies: Dict[Any, int], concat=None, eof=_EOF):        """        Notes:            from_frequencies creates huffman codec by symbol-frequency table/mapping.        Args:            frequencies (Dict[Any, int]): Symbols and its frequency, symbols can be str, bytes or int, etc.            concat (Union[None]): concat method of symbols, will be determined by the function if argument is not                specified            eof (_EOFSymbol): leave it alone.        Returns:            __HuffmanCoder        Examples:            >>> huf_coder = HuffmanCoderFactory.from_frequencies({"a":29, "b":10, "c": 5})            >>> type(huf_coder)        """        concat_function = concat if concat is not None else _guess_concat_function(next(iter(frequencies)))        # build huffman tree node heap        # each item: (frequency, [(symbol, (bitsize, value))], value equals which layer of the tree        heap: List[Tuple[int, List[Tuple[Any, Tuple[int, int]]]]] = [(freq, [(symbol, (0, 0))]) for symbol, freq in                                                                     frequencies.items()]        # add eof        if eof not in frequencies:            heap.append((1, [(eof, (0, 0))]))        heapify(heap)        while len(heap) > 1:            # get first 2 min as left and right child tree            a: Tuple[int, List[Tuple[Any, Tuple[int, int]]]] = heappop(heap)            b: Tuple[int, List[Tuple[Any, Tuple[int, int]]]] = heappop(heap)            # merge child to form parent            # parent frequencies adds together, left child add 0 ahead (do nothing) of previous bits            # right add 1 ahead of previous bits            merged = (                a[0] + b[0],                [(s, (n + 1, v)) for (s, (n, v)) in a[1]] + [(s, (n + 1, (1 << n) + v)) for (s, (n, v)) in b[1]]            )            heappush(heap, merged)        # code table is root        table = dict(heappop(heap)[1])        return cls(table, concat=concat, check=False, eof=eof)    @classmethod    def from_sequence(cls, sequence: Union[List[Any], Tuple[Any], str, bytes]):        """        Notes:            from_sequence will build a huffman tree from a sequence of symbol        Args:            sequence (Union[List, Tuple][Any]):        Returns:            __HuffmanCoder        Examples:            >>> seq = "a"*100 + "b"*29 + "c"*32            >>> coder = HuffmanCoderFactory.from_sequence(seq)        """        frequencies = collections.Counter(sequence)        return cls.from_frequencies(frequencies, concat=_guess_concat_function(sequence))def encode(path: Union[str, Path], verbose: bool=True):    assert (path := Path(path)).exists(), f"{Fore.RED}{path} not exists!{Style.RESET_ALL}"    with path.open(mode="rb") as f:        content = f.read()    coder = HuffmanCoderFactory.from_sequence(content)    byte = coder.encode(content)    if not (out_fd := path.resolve().parent / (path.stem + "_huf")).exists():        out_fd.mkdir(parents=True)    with (main_path := out_fd.joinpath(path.stem + "_" + path.suffix[1:] + ".huf")).open("wb") as f:        f.write(byte)    coder.save(coder_path := out_fd.joinpath(path.stem + "_coder.huf"))    b1 = path.stat().st_size    b2 = main_path.stat().st_size    b3 = coder_path.stat().st_size    summary1, summary2, summary3, summary4 = [""]*4    if verbose:        summary1 = f"Origin file: {path.stem}{path.suffix}, byte size: {b1}"        summary2 = f"Compressed file: {main_path.stem}{main_path.suffix}, byte size: {b2}"        summary3 = f"HuffCoder file: {coder_path.stem}{coder_path.suffix}, byte size: {b3}"        summary4 = f"{Fore.GREEN}Compression rate {b2}/{b1}={Style.BRIGHT}{round(b2/b1, 4)*100}%{Style.NORMAL}" +\                f", saved {Style.BRIGHT}{b1-b2}{Style.RESET_ALL} bytes"        print(s := "Summary".center(max([len(summary1), len(summary2), len(summary3), len(summary4)]), "="))        print("\n".join((summary1, summary2, summary3, summary4)))        print("="*len(s))    return b1, b2, b3, coderdef decode(huf_path: Union[Path, str], coder_path: Union[Path, str], verbose: bool=True):    huf_path, coder_path = Path(huf_path), Path(coder_path)    coder = _HuffmanCoder.load(coder_path)    with huf_path.open(mode="rb") as f:        content = f.read()    decoded = coder.decode(content)    with (dec_path := huf_path.parent.joinpath((s := huf_path.stem.split("_"))[0] + f"_decode.{s[1]}")).open(mode="wb") as f:        f.write(decoded)    b1 = huf_path.stat().st_size    b2 = coder_path.stat().st_size    b3 = dec_path.stat().st_size    if verbose:        summary1 = f"Origin file: {huf_path.stem}{huf_path.suffix}, byte size: {b1}"        summary2 = f"Coder file: {coder_path.stem}{coder_path.suffix}, byte size: {b2}"        summary3 = f"Decompressed file: {dec_path.stem}{dec_path.suffix}, byte size: {b3}"        summary4 = f"{Fore.GREEN}Decompression rate {b3}/{b1}={Style.BRIGHT}{round(b3/b1, 4)*100}%{Style.NORMAL}" +\                f", lost {Style.BRIGHT}{b3-b1}{Style.RESET_ALL} bytes"        print(s := "Summary".center(max([len(summary1), len(summary2), len(summary3), len(summary4)]), "="))        print("\n".join((summary1, summary2, summary3, summary4)))        print("="*len(s))    return b1, b2, b3, coderdef parse_args() -> argparse.Namespace:    parser = argparse.ArgumentParser(        description="哈夫曼压缩算法Python实现，可以对任意文件进行压缩，提供命令行以及GUI用户界面。作者：Jack Wang"    )    parser.add_argument("-s", "--src", dest="src_path", type=str, default=None, help="需要压缩的文件路径")    parser.add_argument("-t", "--target", dest="target_path", type=str, default=None, help="需要解压文件所在的文件夹的路径")    parser.add_argument("-v", "--verbose", dest="v", action="store_true", help="是否显示压缩的摘要信息")    parser.add_argument("-g", "--gui", dest="gui", action="store_true", help="是否以GUI方式显示")    return parser.parse_args()class QtGUIHuff(QMainWindow):    def __init__(self) -> None:        super().__init__()        self.initUI()    def initUI(self):        from Ui_main import Ui_Form        self.ui = Ui_Form()        self.ui.setupUi(self)        self.setWindowTitle("哈夫曼压缩/解压缩程序")        self.ui.compress.clicked.connect(self.compress)        self.ui.decompress.clicked.connect(self.decompress)    def fileDialog(self):        dialog = QFileDialog()        dialog.setFileMode(QFileDialog.AnyFile)        dialog.setFilter(QDir.Files)        if dialog.exec():            filename = dialog.selectedFiles()            return Path(filename[0])        else:            return False    def compress(self):        f_path = self.fileDialog()        self.ui.textEdit.setReadOnly(True)        s = ["开始压缩"]        self.ui.textEdit.setText("\n".join(s))        result = encode(f_path)        summary1 = f"Origin file: {f_path.stem}{f_path.suffix}, byte size: {result[0]}"        summary2 = f"Compressed file:  byte size: {result[1]}"        summary3 = f"HuffCoder file: , byte size: {result[2]}"        summary4 = f"Compression rate {result[1]}/{result[0]}={round(result[1]/result[0], 4)*100}%" + \                f", saved {result[0] - result[1]} bytes"        self.ui.textEdit.setText("\n".join([*s, summary1, summary2, summary3, summary4, "压缩结束"]))        self.ui.textEdit_2.setText(result[-1].print_code_table(verbose=False).__str__())    def decompress(self):        f_path = self.fileDialog()        if f_path.suffix != ".huf":            QMessageBox.warning(self, "警告", "请选择正确的压缩文件路径", QMessageBox.Yes, QMessageBox.Yes)            return False        if len(ps := list(Path(f_path).parent.glob("*.huf"))) == 2:            print(ps)            for p_idx in range(len(ps)):                if "coder" in ps[p_idx].stem:                    cp_idx = p_idx        else:            QMessageBox.warning(self, "警告", "缺少必要的解压缩文件", QMessageBox.Yes, QMessageBox.Yes)            return False        s = ["开始解压"]        import time        time.sleep(1)        self.ui.textEdit.setText("\n".join(s))        result = decode(huf_path:=ps[1-cp_idx], coder_path:=ps[cp_idx])        summary1 = f"Origin file: {huf_path.stem}{huf_path.suffix}, byte size: {result[0]}"        summary2 = f"Coder file: {coder_path.stem}{coder_path.suffix}, byte size: {result[1]}"        summary3 = f"Decompressed file: byte size: {result[2]}"        summary4 = f"Decompression rate {result[2]}/{result[0]}={round(result[2]/result[0], 4)*100}%" +\                f", lost {result[2] - result[0]} bytes"        self.ui.textEdit.setText("\n".join([*s, summary1, summary2, summary3, summary4, "解压结束"]))        self.ui.textEdit_2.setText(result[-1].print_code_table(verbose=False).__str__())def main(args: argparse.Namespace):    if not args.gui:        assert 0 < int(args.src_path is not None) + int(args.target_path is not None), f"{Fore.RED}请选择压缩或者解压，使用-h查询用法{Style.RESET_ALL}"    if not args.gui:        print(f"{Fore.GREEN}命令行工作模式{Style.RESET_ALL}")        if args.src_path is not None:            print(f"开始压缩 {args.src_path}")            if args.v:                print(encode(Path(args.src_path))[-1].print_code_table(verbose=False))            else:                encode(Path(args.src_path), verbose=False)            print("压缩完成")        elif args.target_path is not None:            if len(ps := list(Path(args.target_path).glob("*.huf"))) == 2:                print(ps)                for p_idx in range(len(ps)):                    if "coder" in ps[p_idx].stem:                        cp_idx = p_idx            else:                assert False, f"{Fore.RED}无效的路径，没有找到压缩文件{Style.RESET_ALL}"            print(f"开始解压 {args.target_path}")            if args.v:                print(decode(huf_path=ps[1-cp_idx], coder_path=ps[cp_idx])[-1].print_code_table(verbose=False))            else:                decode(huf_path=ps[1-cp_idx], coder_path=ps[cp_idx], verbose=False)            print("解压完成")    else:        app = QApplication(sys.argv)        m = QtGUIHuff()        m.show()        sys.exit(app.exec_())if __name__ == "__main__":    main(parse_args())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-Ui-main-py"><a href="#2-Ui-main-py" class="headerlink" title="2. Ui_main.py"></a>2. Ui_main.py</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python"># -*- coding: utf-8 -*-# Form implementation generated from reading ui file '/media/jack/JackCode/project/data_structure/11_huffman/ui/main.ui'## Created by: PyQt5 UI code generator 5.9.2## WARNING! All changes made in this file will be lost!from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_Form(object):    def setupUi(self, Form):        Form.setObjectName("Form")        Form.resize(751, 374)        self.layoutWidget = QtWidgets.QWidget(Form)        self.layoutWidget.setGeometry(QtCore.QRect(50, 20, 641, 321))        self.layoutWidget.setObjectName("layoutWidget")        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.layoutWidget)        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)        self.horizontalLayout_2.setObjectName("horizontalLayout_2")        self.verticalLayout = QtWidgets.QVBoxLayout()        self.verticalLayout.setObjectName("verticalLayout")        self.horizontalLayout = QtWidgets.QHBoxLayout()        self.horizontalLayout.setObjectName("horizontalLayout")        self.compress = QtWidgets.QPushButton(self.layoutWidget)        self.compress.setObjectName("compress")        self.horizontalLayout.addWidget(self.compress)        self.decompress = QtWidgets.QPushButton(self.layoutWidget)        self.decompress.setObjectName("decompress")        self.horizontalLayout.addWidget(self.decompress)        self.verticalLayout.addLayout(self.horizontalLayout)        self.label = QtWidgets.QLabel(self.layoutWidget)        self.label.setAlignment(QtCore.Qt.AlignCenter)        self.label.setObjectName("label")        self.verticalLayout.addWidget(self.label)        self.textEdit = QtWidgets.QTextEdit(self.layoutWidget)        self.textEdit.setObjectName("textEdit")        self.verticalLayout.addWidget(self.textEdit)        self.horizontalLayout_2.addLayout(self.verticalLayout)        self.verticalLayout_2 = QtWidgets.QVBoxLayout()        self.verticalLayout_2.setObjectName("verticalLayout_2")        self.label_2 = QtWidgets.QLabel(self.layoutWidget)        self.label_2.setAlignment(QtCore.Qt.AlignCenter)        self.label_2.setObjectName("label_2")        self.verticalLayout_2.addWidget(self.label_2)        self.textEdit_2 = QtWidgets.QTextEdit(self.layoutWidget)        self.textEdit_2.setObjectName("textEdit_2")        self.verticalLayout_2.addWidget(self.textEdit_2)        self.horizontalLayout_2.addLayout(self.verticalLayout_2)        self.retranslateUi(Form)        QtCore.QMetaObject.connectSlotsByName(Form)    def retranslateUi(self, Form):        _translate = QtCore.QCoreApplication.translate        Form.setWindowTitle(_translate("Form", "Form"))        self.compress.setText(_translate("Form", "压缩"))        self.decompress.setText(_translate("Form", "解压"))        self.label.setText(_translate("Form", "Compress/Decompress Log"))        self.label_2.setText(_translate("Form", "Huffman Tree"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
            <tag> GUI </tag>
            
            <tag> PyQt </tag>
            
            <tag> HuffmanEncode </tag>
            
            <tag> HuffmanAlgorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5学习笔记 Chapter 0-Introduction： Part 3.第一个Qt程序</title>
      <link href="/2021/12/20/pyqt5-xue-xi-bi-ji-3-di-yi-ge-qt-cheng-xu/"/>
      <url>/2021/12/20/pyqt5-xue-xi-bi-ji-3-di-yi-ge-qt-cheng-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本讲作为Introduction的最后一讲，实现了一个简单的Qt的GUI程序</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211220145356314.png" alt="第一个Qt Gui程序"></p><h1 id="PyQt5学习笔记-Chapter-0-Introduction：-Part-3-第一个Qt程序"><a href="#PyQt5学习笔记-Chapter-0-Introduction：-Part-3-第一个Qt程序" class="headerlink" title="PyQt5学习笔记 Chapter 0-Introduction： Part 3.第一个Qt程序"></a>PyQt5学习笔记 Chapter 0-Introduction： Part 3.第一个Qt程序</h1><p>在Introduction章节中，我们介绍了什么是Qt、PyQt以及Qt中的一些基本概念。本文作为Introduction的终节，展示一个Qt程序。</p><h2 id="1-Qt程序"><a href="#1-Qt程序" class="headerlink" title="1. Qt程序"></a>1. Qt程序</h2><p>上面的Qt GUI程序的代码如下</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import sysfrom PyQt5.QtWidgets import QApplication, QMainWindowif __name__ == "__main__":    app = QApplication(sys.argv)    w = QMainWindow()    w.resize(300, 150)    w.move(300, 300)    w.setWindowTitle("第一个Qt应用")    w.show()    # 运行主循环，循环扫描窗口上的事件，并分发给对应的回调函数    sys.exit(app.exec_())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们运行之后就会弹出来一个窗口。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211220145739135.png" alt="弹出来的窗口"></p><h2 id="2-程序解释"><a href="#2-程序解释" class="headerlink" title="2. 程序解释"></a>2. 程序解释</h2><p>在上面，我们写了一个极简的Qt GUI程序，下面我们对他进行讲解。</p><ol><li>Qt5本身有非常多的功能，例如网络引擎、蓝牙设备管理等等。因此在Qt5中，一个功能就是一个模块。我们这里的QtWidgets模块中包含了所有的Qt常见的功能。例如按钮、窗口、程序等等。</li><li>首先正如前面所讲，我们实例化一个QApplication类</li><li>接下来我们实例化了一个窗口。并将这个窗口大小设置为300像素宽、150像素高；将窗口锚点（左上角点）移动到距离屏幕左上角宽300像素、高300像素的位置；设置窗口名称为第一个Qt应用；最后显示窗口。</li><li>最后我们运行这个程序，并将程序运行的结果（返回值）作为参数传给sys.exit</li></ol><p>其实从上面我们能够看到，一个窗口本身并不是整个程序，而是程序的一部分。这也是Qt的设计思想之一，即功能和显示分离。我们目前只是利用一些对象进行了显示，而功能的实现需要稍后面介绍的信号与槽机制。</p>]]></content>
      
      
      <categories>
          
          <category> PyQt5 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> GUI开发 </tag>
            
            <tag> PyQt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5学习笔记 Chapter 0-Introduction： Part 2.QApplication与QObject</title>
      <link href="/2021/12/17/pyqt5-xue-xi-bi-ji-2-qt-ji-chu-qapplication-yu-qobject/"/>
      <url>/2021/12/17/pyqt5-xue-xi-bi-ji-2-qt-ji-chu-qapplication-yu-qobject/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲解了Qt中的核心对象：QApplication与QObject</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211222112408341.png" alt="Qt可以制作出的高端界面"></p><h1 id="PyQt5学习笔记-Chapter-0-Introduction：-Part-2-QApplication与QObject"><a href="#PyQt5学习笔记-Chapter-0-Introduction：-Part-2-QApplication与QObject" class="headerlink" title="PyQt5学习笔记 Chapter 0-Introduction： Part 2.QApplication与QObject"></a>PyQt5学习笔记 Chapter 0-Introduction： Part 2.QApplication与QObject</h1><p>想要学好Qt，我们就需要掌握Qt的设计与架构，单纯的为掌握API是徒劳的，没有理解终究会忘记。本文作为基础，首先介绍了Qt中的QApplication与QObject。</p><h2 id="1-QObject"><a href="#1-QObject" class="headerlink" title="1. QObject"></a>1. QObject</h2><p>前面我们介绍过，Qt是一个面向对象的应用程序框架。因此在Qt中的一起都是对象，例如我们看到的窗口、按钮等等都是对象，甚至连整个应用程序都是对象。不同的对象有不同的属性和方法，例如对于窗口，窗口大小和锚点（左上角点）的位置就是其属性，窗口移动到某个位置就是其方法。而针对按钮，按钮也可以将按钮的大小作为其属性，而将点击作为其方法。</p><p>因此针对所有的对象，Qt提供了QObject作为所有类的基类，所有的类都是QObject的基类。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211222112125225.png" alt="Qt官方对QObject的介绍"></p><p>在未来，随着我们逐步的深入，我们会了解到诸如信号与槽、定时器等机制。而这些机制其实都是由QObject所提供的。</p><p>现在我们只需要记住，Qt所写的GUI程序中的一切都是对象即可</p><h2 id="2-QApplication"><a href="#2-QApplication" class="headerlink" title="2. QApplication"></a>2. QApplication</h2><p>前面我们说了，Qt中一切都是对象，Qt甚至将程序本身也抽象成了一个类。这个类就是QApplication。</p><p><strong>QApplication接管GUI程序的主控制流</strong>，具体包括：线程的管理，事件的分发（例如鼠标点击按钮后由谁来处理），回调函数的唤醒等等。因此我们使用Qt开发程序的时候必须要有一个QApplication对象。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211222112030842.png" alt="Qt官方的文档"></p><p>程序可以开启也可以关闭，因此QApplication对象就有运行和关闭等功能。而由于运行程序和结束程序是QApplication对象最常见的功能，因此因此我们在未来不断地一段时间内都只会用到QApplication的运行和结束方法。在未来我们会介绍线程等内容。</p><p>现在我们只需要知道，使用Qt写程序的时候必须要有一个QApplication，而程序开始运行则需要调用QApplication对象的运行方法</p>]]></content>
      
      
      <categories>
          
          <category> PyQt5 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> GUI开发 </tag>
            
            <tag> PyQt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo的个人技术博客搭建-Part-5-Hexo本地编写技巧</title>
      <link href="/2021/12/17/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-5-hexo-ben-di-bian-xie-ji-qiao/"/>
      <url>/2021/12/17/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-5-hexo-ben-di-bian-xie-ji-qiao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面我们成功的在本地搭建出了Hexo博客网站的环境以及完成了Typora编辑器的设置。本文将讲解如何使用Hexo在本地创建文章以及设置为草稿、密码阅读等技巧</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217131946247.png" alt="Hexo 博客编写技巧"></p><h1 id="基于Hexo的个人技术博客搭建-——-Hexo本地编写技巧"><a href="#基于Hexo的个人技术博客搭建-——-Hexo本地编写技巧" class="headerlink" title="基于Hexo的个人技术博客搭建 ——  Hexo本地编写技巧"></a>基于Hexo的个人技术博客搭建 ——  Hexo本地编写技巧</h1><p>前面我们已经设置好了本地的Hexo博客环境，以及本地的编辑器环境。本文将讲解如何通过Hexo来创建新的博客文章，并且设置文章为草稿（不可见）以及加密（密码阅读等功能）。</p><p>前面我们讲过Hexo中博客其实是Markdown文件。针对Markdown，Hexo可以根据我们预先设置好的模板来渲染、生成对应的HTML文件。那么我们要开始编写博客，其实就是开始编写Markdown文档。</p><p>然而在我们使用Typora开始编写前，自然就需要创建出来这个Markdown文件。然后在创建的Markdown文件的基础上，我们为这个Markdown文件设置文章的标题、日期等等元信息（mate-information，类比于HTML中的header）。</p><p>进一步，有了文章我们有的时候不希望一些文章被人看到，比如写了一半的草稿；也有一些文章，我们希望有访问权限得人（有密码的人）才能阅读，例如你的简历。</p><p>因此针对这些功能，Hexo都进行了设置。</p><h2 id="1-Hexo的博客原理"><a href="#1-Hexo的博客原理" class="headerlink" title="1. Hexo的博客原理"></a>1. Hexo的博客原理</h2><h3 id="1-Markdown的Front-Formatter"><a href="#1-Markdown的Front-Formatter" class="headerlink" title="1. Markdown的Front-Formatter"></a>1. Markdown的Front-Formatter</h3><p>首先针对文章的标题、日期、是否加密等信息都是在Markdown开头的Header区设定，由于设定之后会影响到文章的外观（在稍后会看到），因此这个区域成为Front-Formatter。以我之前写好的一篇文章为例，我们能够看到文章的标题、创建日期、封面图像、所属目录、分类等等信息都在Header区设定。</p><p>其实包括后面的密码验证文章也在这里设置。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217130309720.png" alt="Markdown的Header"></p><h3 id="2-Hexo中的草稿与正式发布文章"><a href="#2-Hexo中的草稿与正式发布文章" class="headerlink" title="2. Hexo中的草稿与正式发布文章"></a>2. Hexo中的草稿与正式发布文章</h3><p>由于Hexo是通过Markdown文件来生成文章，因此我们写的草稿和正式要发布的文章其实对于Hexo来说是完全等价的。要区分两者。Hexo实际上是通过文件所处的文件夹来进行的。我们所有的要发布的文章都在<code>source/_post</code>文件夹中，而所有的草稿都在<code>source/_draft</code>中</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ tree -d -L 2 source/(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ ls source/_posts/(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ ls source/_drafts/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>原谅我因为博客要在不同的机器上编写，所以放在了硬盘上，导致文件权限很呆滞<span class="github-emoji"><span>🤔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217130820741.png" alt="Hexo中的草稿与发布文章的文件夹"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217131004765.png" alt="具体的草稿与发布的文章"></p><p>因此用的来说，我们写博客时候需要掌握的技巧就是文章在草稿（文件夹）与正式发布（文件夹）之间的左右横跳与单篇文章内的信息设置。</p><h2 id="2-Hexo文章草稿与正式发布的博客"><a href="#2-Hexo文章草稿与正式发布的博客" class="headerlink" title="2. Hexo文章草稿与正式发布的博客"></a>2. Hexo文章草稿与正式发布的博客</h2><h3 id="1-草稿"><a href="#1-草稿" class="headerlink" title="1. 草稿"></a>1. 草稿</h3><h4 id="1-创建草稿"><a href="#1-创建草稿" class="headerlink" title="1. 创建草稿"></a>1. 创建草稿</h4><p>我们通过hexo new的时候指定使用的模板是draft即可，此时创建的文章会被自动放到_draft文件夹下面</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">hexo new draft <title><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ hexo new draft draft_test(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ ls source/_drafts/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217134454739.png" alt="Hexo创建草稿"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217134547721.png" alt="所有草稿文章"></p><p>然后我们hexo gen生成文章，再使用hexo server来查看本地文章的时候，并不会看到这些草稿文章</p><h4 id="2-发布草稿"><a href="#2-发布草稿" class="headerlink" title="2. 发布草稿"></a>2. 发布草稿</h4><p>当我们完成了草稿文章之后想要发布的时候，使用下面的命令来进行发布</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">hexo publish <title><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，Hexo是一个轻量级的博客，因此不存在像记录草稿、已发布的文章这样的数据库。所有的操作都是基于文件的，因此上面的命令就是把文章从_draft中移动到_post中。我们直接手动mv也是可以的</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ hexo publish draft-test(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ ls source/_posts/ | grep dra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217135305343.png" alt="发布文章"></p><h3 id="2-正式发布文章"><a href="#2-正式发布文章" class="headerlink" title="2. 正式发布文章"></a>2. 正式发布文章</h3><h4 id="1-创建正式发布的文章"><a href="#1-创建正式发布的文章" class="headerlink" title="1. 创建正式发布的文章"></a>1. 创建正式发布的文章</h4><p>直接hexo new就完事，或者自己在_post下面创建，略</p><h4 id="2-改发布文章为草稿"><a href="#2-改发布文章为草稿" class="headerlink" title="2. 改发布文章为草稿"></a>2. 改发布文章为草稿</h4><p>没啥好说的，mv就完事了</p><h2 id="3-Hexo文章Front-Formatter设置"><a href="#3-Hexo文章Front-Formatter设置" class="headerlink" title="3. Hexo文章Front-Formatter设置"></a>3. Hexo文章Front-Formatter设置</h2><p>事实上对于Hexo文章的Front-Formatter而言，Hexo本身支持的Front-Formatter是有限的，需要通过第三方的主题进行扩展。幸运的是，我们前面使用的Matery主题以及有所考虑，支持非常多的Front-Formatter。</p><p>由于Matery主题的Front-Formatter在<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-19">闪烁之狐对Matery主题介绍的博客</a>中已经有了非常详尽的介绍，本文只对一些需要配置的功能进行介绍，一些只需要在Front-Formatter中添加对应的项即可显示的设置就不在介绍，请参考Matery主题闪烁之狐的介绍</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217131946247.png" alt="Front-Formatter闪烁之狐的介绍"></p><h3 id="1-密码设置"><a href="#1-密码设置" class="headerlink" title="1. 密码设置"></a>1. 密码设置</h3><p>对文章进行密码设置功能并不是Hexo的功能，而是Matery主题中的功能，因此我们需要在Matery主题的配置中进行设置</p><p>具体路径为<code>themes/hexo-theme-matery</code>下的<code>_config.yml</code>，然后找到<code>verifyPassword</code>这一项，将其设置为True，然后修改提示语即可</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ vim themes/hexo-theme-matery/_config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217132432259.png" alt="设置主题，开启文章加密功能"></p><p>需要注意的是，Matery主题中的验证密码方式是通过内置的SHA256算法对访问者输入的密码加密之后和我们在文章的Front-Formatter中设置的经过SHA256 加密的 password 的值进行对比得到的。因此我们首先可以通过一下网站来获得密码对应的值。</p><ul><li><a href="https://tool.oschina.net/encrypt?type=2">开源中国</a></li><li><a href="http://encode.chahuo.com/">chahuo</a></li><li><a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a></li></ul><p>例如我们使用开源中国来进行值的获取，注意选择SHA256算法。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217133017741.png" alt="生成加密后的密码的值"></p><p>然后我们新建一篇文章来进行测试。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ hexo new passwd-test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后我们在里面设置password这一项，随便写一点内容</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217133315175.png" alt="设置文章密码"></p><p>然后我们使用hexo gen来生成文章看看效果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ hexo gen(base) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/hexo-blogs$ hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来我们就能够在首页看到这个加密的文章了</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217133600366.png" alt="加密的文章"></p><p>我们一旦点进去访问，就需要我们输入密码</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217133650320.png" alt="输入密码"></p><p>我们输入正确之后进去就能够看到了</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217133745568.png" alt="输入正确之后可以看到文章"></p><p>而一旦输入错误就会返回主页</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217133827160.png" alt="输入错误之后返回主页"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5学习笔记 Chapter 0-Introduction： Part 1.Qt、PyQt与PySide</title>
      <link href="/2021/12/16/pyqt5-xue-xi-bi-ji-1-qt-pyqt-yu-pyside/"/>
      <url>/2021/12/16/pyqt5-xue-xi-bi-ji-1-qt-pyqt-yu-pyside/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Before learn something, you’d better know what it is. </p><p>本文介绍了Qt、PyQt与PySide间的关系。</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/pyqt_vs_pyside.png" alt="PyQt vs PySide"></p><h1 id="PyQt5学习笔记-Chapter-0-Introduction：-Part-1-Qt、PyQt与PySide"><a href="#PyQt5学习笔记-Chapter-0-Introduction：-Part-1-Qt、PyQt与PySide" class="headerlink" title="PyQt5学习笔记 Chapter 0-Introduction： Part 1.Qt、PyQt与PySide"></a>PyQt5学习笔记 Chapter 0-Introduction： Part 1.Qt、PyQt与PySide</h1><p>在学习一个东西之前，我们需要首先明白这个东西是什么。</p><h2 id="0-库与框架"><a href="#0-库与框架" class="headerlink" title="0. 库与框架"></a>0. 库与框架</h2><p>在介绍Qt前，我们需要明白什么是库，什么是框架。</p><p>以下内容参考知乎问题<a href="https://www.zhihu.com/question/29643471">库，框架，架构，平台，有什么明确的区别？</a>博主<a href="https://www.zhihu.com/people/aton">苏莉安的回答</a>与<a href="https://www.zhihu.com/people/ze.ran">ze ran的回答</a>以及<a href="https://www.zhihu.com/people/morgancheng">程墨Morgan的回答</a></p><h3 id="1-库-Library"><a href="#1-库-Library" class="headerlink" title="1. 库 Library"></a>1. 库 Library</h3><p>库可以理解成一个工具箱，工具箱里提供了很多的工具来帮助我们进行工作。</p><p>例如我们在淘宝上买了一个书架，快递发过来的是书架的零件，我们需要自己去进行组装。而在组装架子的时候，我们会用螺丝刀。而自己手动拧螺丝刀则会拧到手痛。所以这个时候我们就会去买一个电动螺丝刀。利用这个电动螺丝刀，我们的效率马上会有极大地提升。我们的生产力也会有极大地进步。</p><p>而无论螺丝刀还是电动螺丝刀，都是不同的工具。</p><p>对应的，库里提供了很多的函数来帮助我们进行工作。利用这些函数，我们的效率马上会翻几倍。</p><p>螺丝刀和电动螺丝刀则是完成同一个工作的不同的库，库与库之间也会存在差异。</p><p><strong>然而库之于程序就像工具之于人，是人决定怎么用工具，工具在哪里用；库也是程序（我们程序员）决定在哪里使用、怎样使用；库只是提供了便利，不需要我们自己手动实现，而且在一些情况下高效率的库（e.g., numpy）能够避免我们自己手动低效率的实现（e.g., for 循环）</strong></p><p>所以说，<strong>库</strong>（Library）是一系列预先编写好的代码集合，供开发者在编程中调用，大大减少重复工作量。我们自己写一个字符串处理函数，包装好之后调用，也是库。</p><p>库的概念很宽泛。程序员第一次输出hello world用的printf就来自C语言标准库；各种SDK都是库；从npm、Maven、Nuget下载的包都是库；pip中绝大部分也是库</p><p><strong>对于库而言，最重要的一点就是程序的主控制流在我们的程序中；或者说是我们的程序在调用库</strong></p><h3 id="2-框架-FrameWork"><a href="#2-框架-FrameWork" class="headerlink" title="2. 框架 FrameWork"></a>2. 框架 FrameWork</h3><p><strong>框架</strong>（Framework）可以理解成是库的进阶版。很多人会把框架和普通库的区别仅仅理解为规模和复杂度，其实不然。</p><p><strong>框架最大的特点就是会接管程序的主控制流；或者说框架在调用我们的代码</strong></p><p>我们只需要编写业务的逻辑代码，具体的工作执行（例如后面要说的GUI框架Qt中的图形显示、信号处理/槽函数调用；未来会出的网页程序框架Flask的服务器运行等等）都是由框架执行的。</p><p>框架是一个半成品的应用，和库的最大区别是框架直接左右了应用怎么来写。</p><hr><h2 id="1-What-is-Qt"><a href="#1-What-is-Qt" class="headerlink" title="1. What is Qt"></a>1. What is Qt</h2><p>在前面介绍完库与框架的区别之后，我们就可以正式的开始介绍Qt了。</p><p>简单的来说，<strong>Qt是一个C++的应用程序开发框架</strong>；更具体的介绍，则看看下面维基百科和百度百科的介绍</p><blockquote><p><strong>From Wikipedia</strong>：</p><p>Qt（/ˈkjuːt/，发音同“cute”）是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱。也可用于开发非GUI程序，例如控制台工具和服务器。Qt被用于OPIE、Skype、VLC media player、Adobe Photoshop Elements、VirtualBox与Mathematica以及被Autodesk 、欧洲空间局、梦工厂、Google、HP、KDE、卢卡斯影业、西门子公司、沃尔沃集团, 华特迪士尼动画制作公司、三星集团、飞利浦、Panasonic所使用。</p><p>它是Digia公司的产品。Qt使用标准的C++和特殊的代码生成扩展（称为元对象编译器（Meta Object Compiler, moc））以及一些宏。通过语言绑定，其他的编程语言也可以使用Qt。</p><p>Qt是自由且开放源代码的软件，在GNU宽通用公共许可证（LGPL）条款下发布。所有版本都支持广泛的编译器，包括GCC的C++编译器和Visual Studio。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217102149620.png" alt="Qt的维基百科介绍"></p><p><strong>From Baidubaike</strong>：</p><p>Qt 是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏，Qt很容易扩展，并且允许真正地组件编程。<br>2008年，Qt Company科技被诺基亚公司收购，Qt也因此成为诺基亚旗下的编程语言工具。2012年，Qt被Digia收购。<br>2014年4月，跨平台集成开发环境Qt Creator 3.1.0正式发布，实现了对于iOS的完全支持，新增WinRT、Beautifier等插件，废弃了无Python接口的GDB调试支持，集成了基于Clang的C/C++代码模块，并对Android支持做出了调整，至此实现了全面支持iOS、Android、WP,它提供给应用程序开发者建立艺术级的图形用户界面所需的所有功能。基本上，Qt 同 X Window 上的 Motif，Openwin，GTK 等图形界面库和 Windows 平台上的 MFC，OWL，VCL，ATL 是同类型的东西。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217102306283.png" alt="Qt的百度百科介绍"></p></blockquote><p>关于Qt，我们需要知道的重要的点如下：</p><ol><li><strong>Qt是一个C++的框架</strong>。因此使用C++进行Qt开发是很舒服的，而Python解释器中Python基金会官方提供的解释器本身是由C语言写的，因此直接动态加载C++的库（挖个坑，后面会将Python调用C++的库）。因此，我们能够早Python中调用Qt</li><li><strong>Qt是一个应用程序框架，而非仅仅是一个带图形界面的应用程序框架（GUI应用程序框架）</strong>。因此在Qt看来，GUI只是Qt的一个部分，而不是全部。对于一个成熟的应用来说，涉及到的内容用：进程/线程/协程管理、网络编程、蓝牙/影响等设备管理、GUI图形显示等等功能。因此Qt作为一个应用程序框架，对于这些内容都是可以胜任的。因此Qt不仅仅是GUI的库，而是一个应用程序框架。更加具体的来说，Qt是因为他的GUI出名，但不仅仅只有GUI。</li></ol><p>针对第一个点，我们稍后就会讲解什么是PyQt，什么是PySide。而针对第二个点，我们明白了未来要怎么样学习Qt，即分模块学习。因此在未来的有的文章会关注PyQt的GUI部分，有的部分会关注PyQt的多线程管理，而有的部分会关注PyQt的网络编程。</p><h2 id="2-What-is-Python-Language-Binding"><a href="#2-What-is-Python-Language-Binding" class="headerlink" title="2. What is Python/Language Binding"></a>2. What is Python/Language Binding</h2><p>在进一步介绍之前，我们需要知道什么是Python Binding，什么是Language Binding。</p><p>从概念上来说，Language Binding是Python Binding的父类/超集。而具体来说，Language Binding指的是某种语言中可以让该语言调用其他语言或者一些系统服务的该语言的代码，这些代码成为胶水代码（glue code）。</p><p>关于Language Binding，百度百科上没有介绍，因此只有维基百科的英文介绍</p><blockquote><p><strong>From Wikipedia</strong>:</p><p>In programming and software design, binding is an application programming interface (API) that provides glue code specifically made to allow a programming language to use a foreign library or operating system service (one that is not native to that language).</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217104203893.png" alt="Introduction of Language Binding in Wikipedia"></p></blockquote><p>因此对于Python来说，Python Binding即指能够让Python调用由其他语言开发的库或者是系统提供的功能（系统调用）的Python代码。</p><p>事实上，得益于Python官方的CPython解释器是由C语言开发的，因此Python具有的直接调用C/C++库的这个能力，Python中的不少库都是C++的库，然后提供了Python Binding，从而使得在Python中能够调用这些库。最著名的一个例子就是OpenCV了。</p><p>我们可以用mlocate查一下</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(base) jack@jack-Alienware-m15-R3:~$ locate *opencv*.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们其实就能够看到，Python的opencv库里没有opencv的so，所有的共享库文件都放在了C++源码编译时候安装的位置了，而Python的OpenCV库里本身只是提供了一些OpenCV 的Python Binding代码，真正的功能还得看预编译好的so文件。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211217110010408.png" alt="查询结果"></p><h2 id="3-What-is-PyQt-amp-PySide"><a href="#3-What-is-PyQt-amp-PySide" class="headerlink" title="3. What is PyQt &amp; PySide"></a>3. What is PyQt &amp; PySide</h2><p>我们前面说道Qt是一个C++的应用程序框架，因此PyQt和PySide其实是两种不同的Qt的Python Binding。两者之间的区别在很多时候都只是<code>from xxx.yyy import zzz</code>中的<code>xxx</code>不同，毕竟底层调用的Qt的so都是一样的，Binding 本身只是为Qt编译成so之后里面的API提供Python的类或者函数的签名。</p><p>因此其实我们学习的时候两者任意选一个就行了。但是PyQt由于推出的早，因此资料比较全，而PySide则虽然推出的晚，但是Qt公司的产品，因此两者在学习的时候我们推荐学习PyQt，因为资料会很全。未来PySide也期待他会变得更好。</p><p>注意在未来我们的系列教程中更加关注Qt的Python Binding，而非具体的PyQt、PySide之争。两者在API上的区别正如上面所说，往往是非常小的。</p><p>关于PyQt与PySide其实在技术上的介绍以及结束了，但是我们不禁会想问为什么一个Qt会有PyQt与PySide两套Binding？</p><p>为了解决这个问题，<del>我们就要介绍一下PyQt与PySide的历史了</del>（吃瓜）</p><p>注：以下关于PyQt、PySide的历史参考知乎问题：<a href="https://www.zhihu.com/question/306793447/answer/560109210">如何评价Qt官方推出的Qt for Python(PySide)？</a>中<a href="https://www.zhihu.com/people/phantask93">饶锦蒙的回答</a></p><h3 id="1-PyQt-PyQt5"><a href="#1-PyQt-PyQt5" class="headerlink" title="1. PyQt / PyQt5"></a>1. PyQt / PyQt5</h3><p>PyQt本身Riverbank Computing这家英国公司在2005年以前的时候开发的，那个时候Python刚刚开始流行。</p><p>前面介绍过，Qt身GPL V3协议下的一个项目，因此当使用PyQt程序就被要求需要强制开源，因此PyQt对商业软件的开发就非常不友好。而Qt本身所属的公司在零几年被诺基亚收购之后就成了诺基亚的一个项目。那个时候诺基亚就与Riverbank Computing展开了多轮磋商，希望PyQt能够支持对商业更加友好的LGPL协议，即开源项目在商业软件中被使用了之后，商业软件不需要强制进行开源。因此LGPL对商业更加友好。</p><p>然而PyQt所属的母公司Riverbank Computing十动然拒，最后诺基亚就和Riverbank Computing谈崩了。</p><p>因此从PyQt的角度来看，PyQt是最早支持Qt的Python Binding的库，在发展上也是非常顺利的。</p><p>因此针对不同的Qt版本（Qt4，Qt5），PyQt就有不同的版本支持PyQt4、PyQt5</p><h3 id="2-PySide-Pyside2"><a href="#2-PySide-Pyside2" class="headerlink" title="2. PySide / Pyside2"></a>2. PySide / Pyside2</h3><p>前面我们说到，诺基亚和Riverbank Computing谈崩之后，诺基亚手握Qt的版权，又不忍放过Python中Qt的商业运用，因此2009年一气之下最终决定自己从头单干，重新开发一套Qt的Python Binding，即PySide。</p><p>然而诺基亚后面的故事我们都很熟悉了，2009年PySide发布了同时支持GPL和LGPL的PySide之后，就芜湖了。因此PySide项目就一度搁浅。</p><p>直到2012年，诺基亚把包括PySide在内的所有有关Qt的全部内容卖给了Digia公司。Digia公司在收购了Qt之后，决定大力支持Qt的全方位发展，因此在2014年9月将Qt分拆成一家独立全资子公司The Qt Company。</p><p>虽说加大了投入，该补的课也绕不开，C++的Qt在Digia收购Qt之后就推出了Qt5版本，PySide对Qt5提供支持的计划从2014年才开始筹备，也就是2015年上马的Qt for Python项目，该项目开发的模块命名为PySide2，以表示与老一代PySide的不同。然而反观PyQt，在Qt5出来不到半年时间就支持了PyQt5。</p><p>PySide2在Qt公司和Qt社区开发者的共同努力下，也只在2018年6月才正式发布了第一个版本，稳定性还是个问题。不过从0到1是最难的，后面就容易了。到今天为止，PySide2已经日趋完善，又是亲生的，还有LGPL的加持，今后PySide2有足够的理由变得越来越好。</p><h2 id="4-Which-Version-of-Qt-to-Use？"><a href="#4-Which-Version-of-Qt-to-Use？" class="headerlink" title="4. Which Version of Qt to Use？"></a>4. Which Version of Qt to Use？</h2><p>其实经过前面的介绍，我们也应该知道了Qt5的版本在2012年推出的，Qt4就更早了。虽然最近也推出了Qt6，但是目前市场、社区里的还是Qt5居多，因此我们直接使用Qt5的Python Binding即可。即PyQt5与PySide2</p><p>正如前面所强调的，在未来的文章中我们不会过分强调PyQt5与PySide2，只有在两者API差异比较大的时候我们才会特地的注明到底每一个是怎么样的。</p>]]></content>
      
      
      <categories>
          
          <category> PyQt5 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> GUI开发 </tag>
            
            <tag> PyQt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5学习笔记 Chapter 0-Introduction： Part 0.初心</title>
      <link href="/2021/12/16/pyqt5-xue-xi-bi-ji-0-chu-xin/"/>
      <url>/2021/12/16/pyqt5-xue-xi-bi-ji-0-chu-xin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文作为PyQt系列学习笔记的第一篇，记录了我为什么要学习PyQt，以及本系列文章的组织形式</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211216205416019.png" alt="Qt的Python绑定：PySide"></p><h1 id="PyQt5学习笔记：-Part-0-初心"><a href="#PyQt5学习笔记：-Part-0-初心" class="headerlink" title="PyQt5学习笔记： Part 0-初心"></a>PyQt5学习笔记： Part 0-初心</h1><p>作为系列文章的第一篇，本文将讲解我为什么要学习PyQt、本系列文章的目标以及未来文章的组织形势</p><h2 id="1-为什么要学习PyQt"><a href="#1-为什么要学习PyQt" class="headerlink" title="1. 为什么要学习PyQt"></a>1. 为什么要学习PyQt</h2><h3 id="1-What-is-User-Interface"><a href="#1-What-is-User-Interface" class="headerlink" title="1. What is User Interface"></a>1. What is User Interface</h3><p>一般来说，我们写出的程序都是直接运行的，通常与用户只有有限的交互（例如input等待用户输入），这样的程序在程序员看来就以及很可以了。然而从用户的角度来说，这样的程序体验非常差。因为用户无法与程序进行交互。</p><p>而对于提供了用户界面（User Interface）的程序用户体验就会好很多，而且看起来就会非常高级。</p><p>例如下面有了文字用户界面，用户就可以指定不同的参数和选项，从而实现不同的功能。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/Fdedit.png" alt="用户界面之一：图形文字界面文件管理器（Text User Interface File Manager)"></p><h3 id="2-Classification-of-User-Interface"><a href="#2-Classification-of-User-Interface" class="headerlink" title="2. Classification of User Interface"></a>2. Classification of User Interface</h3><p>一般来说，用户界面分为两种，一种是<strong>文字用户界面</strong>，另外一种就是<strong>图形用户界面</strong>。</p><h4 id="1-Text-based-User-Interface-（TUI）"><a href="#1-Text-based-User-Interface-（TUI）" class="headerlink" title="1. Text(-based) User Interface （TUI）"></a>1. Text(-based) User Interface （TUI）</h4><p>文字用户界面即指程序与用户的交互界面就是由文本构成的，即用文本模拟出来的界面。例如我们上面看到的<strong>FreeDOS Edit</strong>。</p><p>很多程序都提看TUI，例如make。有些程序源码中在Makefile中提供了menuconfig规则，我们使用make来利用这个规则进行编译时配置的时候就会看到TUI界面。如下图我们进行内核编译参数配置的时候使用menuconfig。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211216214559133.png" alt="TUI编译内核"></p><p>然后我们就能看到TUI界面</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211216214636804.png" alt="Menuconfig的TUI界面"></p><p>可以看到TUI的界面其实就是把文本背景设置为不同的颜色，以此来表达出界面。</p><h4 id="2-Graphic-based-User-Interface"><a href="#2-Graphic-based-User-Interface" class="headerlink" title="2. Graphic(-based) User Interface"></a>2. Graphic(-based) User Interface</h4><p>图形用户界面则是现在程序的标配，我们在Windows上用的QQ、微信等等都是GUI程序。在Linux上，所谓的桌面也是一个GUI程序。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/4/48/Linux_Mint_19.1_&quot;Tessa&quot;_(Cinnamon" alt="Linux Mint的桌面">.png)</p><p>所以话说回来，我们学习PyQt的目的其实就非常明确了，我们就是想要能够做出来一个GUI程序，即类似于QQ、微信这样的程序。</p><h2 id="2-本系列文章的组织形式"><a href="#2-本系列文章的组织形式" class="headerlink" title="2. 本系列文章的组织形式"></a>2. 本系列文章的组织形式</h2><p>本系列文章将从0开始，记录我学习PyQt的过程，同时也将作为PyQt的教程。</p><p>由于需要学习得内容比较多，因此类似于一本书，全书将会分为多个章节。每个章节围绕一个主题进行讲解。</p><p>讲解内容包括Qt Designer、Layout、Signal与Slot等等内容</p>]]></content>
      
      
      <categories>
          
          <category> PyQt5 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> GUI开发 </tag>
            
            <tag> PyQt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅ML2021-Spring-hw1：Covid19 Cases Prediction</title>
      <link href="/2021/12/11/li-hong-yi-ml2021-spring-hw1-covid19-cases-prediction-md/"/>
      <url>/2021/12/11/li-hong-yi-ml2021-spring-hw1-covid19-cases-prediction-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲解李宏毅ML2021 Spring的Homework1： Covid19 Cases Prediction</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207150639649.png" alt="作业一：COVID-19 Cases Prediction"></p><h1 id="李宏毅ML2021-Spring-hw1：Covid19-Cases-Prediction"><a href="#李宏毅ML2021-Spring-hw1：Covid19-Cases-Prediction" class="headerlink" title="李宏毅ML2021-Spring-hw1：Covid19 Cases Prediction"></a>李宏毅ML2021-Spring-hw1：Covid19 Cases Prediction</h1><h2 id="1-Homework-Objectives"><a href="#1-Homework-Objectives" class="headerlink" title="1. Homework Objectives"></a>1. Homework Objectives</h2><p>作业一的目的在于：</p><ul><li>明白如何使用DNN解决Regression问题</li><li>掌握基本的DNN训练技术：调参、特征选择、正则化</li><li>熟悉Pytorch的使用</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207151013750.png" alt="Objectives of Homework1"></p><h2 id="2-Task-Description"><a href="#2-Task-Description" class="headerlink" title="2. Task Description"></a>2. Task Description</h2><p>本次任务要求我们对每日的新冠肺炎的确诊人数进行预测。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207151406811.png" alt="Task Description"></p><h3 id="1-Survey-Methods"><a href="#1-Survey-Methods" class="headerlink" title="1. Survey Methods"></a>1. Survey Methods</h3><p>数据集的来源是CMU的研究员在社交媒体上发布调查问卷，问卷的内容包括了心理健康状态、流感类似症状疾病患者人数。而后根据受访者居住的地区来监测美国所有州的所有城市的情况。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211211163552345.png" alt="Survey Method"></p><h3 id="2-Data-Inspection"><a href="#2-Data-Inspection" class="headerlink" title="2. Data Inspection"></a>2. Data Inspection</h3><p>本次任务的数据集是csv文件</p><p>在训练数据中，训练数据的csv文件中每一行就是一个example。example的前40维是对于城市的one-hot编码，然后每一个样本会给出来三天的调查情况。</p><p>其中，<strong>前两天的确诊人数是我们的training的一个feature，而第三天的确诊人数则是我们需要预测的label</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207151633099.png" alt="Training Data Inspection"></p><p>而对于测试数据，则只有前面的feature，没有最后的label，最后我们需要将生成的label以csv文件的形式提交</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211211164704231.png" alt="Testing Data Inspection"></p><h3 id="3-Evaluation-Metrics"><a href="#3-Evaluation-Metrics" class="headerlink" title="3. Evaluation Metrics"></a>3. Evaluation Metrics</h3><p>针对本次任务，使用的衡量标准是Rooted Mean Square Error（RMSE），所以最后在kaggle上得到的分数是越低越好。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207152032106.png" alt="Evaluation Metric"></p><h3 id="4-Baselines"><a href="#4-Baselines" class="headerlink" title="4. Baselines"></a>4. Baselines</h3><p>这次任务有三个BaseLine</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207151811659.png" alt="Task Baseline"></p><h2 id="3-My-Solution"><a href="#3-My-Solution" class="headerlink" title="3. My Solution"></a>3. My Solution</h2><p>下面是我关于本次任务的理解和更新</p><h3 id="1-Thoughs"><a href="#1-Thoughs" class="headerlink" title="1. Thoughs"></a>1. Thoughs</h3><p>这个是一个regression的任务，最后的输出是一个数字，所以网络最后一层out_feature是1即可</p><p>然后这些特征之间有可能有一些特征是和确诊人数的确相关的，有一些是和确诊人数完全无关的，甚至是random的，所以这一些特征可能会影响最后的判断，所以后面需要进行特征选择或者让模型自己选出来重要的特征，然后给重要的特征大的权重。类似于attention</p><p>然后可以试试generative的方法，让模型在训练一段时间之后自己生成，即训练判断模型的基础上再生成一个生成模型。生成模型用GAN去生成数据，然后让判断模型去学习。</p><p>最后可以试试不确定性的方法。</p><h3 id="2-Updates"><a href="#2-Updates" class="headerlink" title="2. Updates"></a>2. Updates</h3><h4 id="2021-12-11：完成了基本框架"><a href="#2021-12-11：完成了基本框架" class="headerlink" title="2021-12-11：完成了基本框架"></a>2021-12-11：完成了基本框架</h4><ul><li><strong>进展</strong>：完成了基本的框架的搭建，明天开始训练。完成的框架包括训练代码，网络的定义，dataset和得到提交文件的代码</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(torch) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/deeplearning/hw1_1-regression$ tree src/src/├── dataset.py├── gen_submission.py├── networks.py├── pathconfig.py└── train.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2021-12-12-update1：训练时loss不下降-cry"><a href="#2021-12-12-update1：训练时loss不下降-cry" class="headerlink" title="2021-12-12 update1：训练时loss不下降:cry:"></a>2021-12-12 update1：训练时loss不下降<span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><ul><li><p><strong>问题</strong>：开始训练，但是训练的时候遇到了一些问题，训练的时候loss一直没有下降，例如下面这张图<img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212115234546.png" alt="loss没有下降"></p></li><li><p>解决办法：最后经过检查，是batchsize的问题，dataloader的忘记设置batchsize和shuffle了，所以出了问题，这个数据集里单个样本随机波动太大，不像图像是比较通用的，随机波动小，单个example也能学到东西。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212115505406.png" alt="出问题的代码"><br>最后修改掉之后就可以正常训练了，以后一定要注意小batchsize带来的小样本梯度随机波动问题<br><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212115710477.png" alt="修改之后的代码"></p><p>最后可以正常训练<img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212115901900.png" alt="正常开始训练"></p><p>最后在379个epoch时候停下来了，提交一发<img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212120026808.png" alt="最后的训练结果"></p></li></ul><h4 id="2021-12-12-update2-提交分数起飞-boom"><a href="#2021-12-12-update2-提交分数起飞-boom" class="headerlink" title="2021-12-12 update2: 提交分数起飞:boom:"></a>2021-12-12 update2: 提交分数起飞<span class="github-emoji"><span>💥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a5.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><ul><li><p><strong>问题</strong>：接上一个问题，完成了之后提交结果，分数很烂</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212140536683.png" alt="分数很低"></p></li><li><p><strong>解决办法</strong>：最后经过检查，是网络在训练的时候，对训练数据的feature和label都进行了正则化，使其服从均值为0，标准差为1的分布，这样在训练过程中的梯度的分布也会更加均匀。但是这样做的问题就是网络预测的进过标准化之后的label，所以使用测试数据生成结果的时候得到的也是标准化之后的结果，需要加上label的均值和标准差，但是由于是测试数据，所以没有标准差和均值，而<strong>测试数据和训练数据不是独立同分布的</strong>。所以不能直接加上测试数据的标准差和方差</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212143542126.png" alt="修改前的错误代码，对label也做了标准化"></p><p>修改之后不给label做标准化，再训练一次然后提交</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212151141477.png" alt="修改后不对label做标准化"></p><p>再进行一次训练</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212151509152.png" alt="修改后的训练"></p><p>最后提交的结果，相比于一开始有了很大的进步</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212151837238.png" alt="提交结果"></p></li></ul><h4 id="2021-12-12-update3-Simple-baseline-triangular-flag-on-post"><a href="#2021-12-12-update3-Simple-baseline-triangular-flag-on-post" class="headerlink" title="2021-12-12 update3:  Simple baseline:triangular_flag_on_post:"></a>2021-12-12 update3:  Simple baseline<span class="github-emoji"><span>🚩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f6a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>大胜利<span class="github-emoji"><span>🎉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li><p><strong>思路</strong>：尝试了一下仅仅使用前两天的确诊人数作为feature来训练，最后提升巨大，由于我在代码里预留了dim2use，所以直接加上前两的确诊人数的feature和州，一共42个dimension再来一次</p><p><strong>所以前面的猜想确实成立，即存在一些和确诊人数完全无关的特征，这些特征会极大地影响模型的表现</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212155208705.png" alt="加上前两天的确诊人数"></p></li><li><p><strong>效果</strong>：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212155232450.png" alt="巨大的进步"></p></li></ul><h4 id="2021-12-12-update4-特征选择的思考-Medium-Baseline-triangular-flag-on-post"><a href="#2021-12-12-update4-特征选择的思考-Medium-Baseline-triangular-flag-on-post" class="headerlink" title="2021-12-12 update4: 特征选择的思考 Medium Baseline :triangular_flag_on_post:"></a>2021-12-12 update4: 特征选择的思考 Medium Baseline <span class="github-emoji"><span>🚩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f6a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><ul><li><p><strong>想法</strong>：因为在前面使用了州和前两天，得到的分数非常的高，所以利用了特征选择的手段，试了一下不同的特征，得到的结果如下</p><ul><li><p><strong>使用了州和前两天</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212163655980.png" alt="使用州和前两天"></p></li><li><p><strong>使用了得分前15的特征</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212163737608.png" alt="得分前15的特征"></p></li><li><p><strong>使用了得分大于500的特征</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212163814031.png" alt="得分大于500的特征"></p></li><li><p><strong>只使用前两天得病的人数</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212163858827.png" alt="只使用前两天得病的人数"></p></li></ul><p>而特征选择时候前90个特征的得分如下，可以看到，前两个特征（前两天确诊的人数）的分数是远远大于剩下的特征，也就难怪训练出来最后一个的得分最高</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">                    Specs          Score76       tested_positive.1  148069.65827858         tested_positive   69603.87259143            hh_cmnty_cli    9235.49209461          hh_cmnty_cli.1    9209.01955879          hh_cmnty_cli.2    9097.37517244          nohh_cmnty_cli    8395.42130062        nohh_cmnty_cli.1    8343.25592780        nohh_cmnty_cli.2    8208.17643541                     cli    6388.90684959                   cli.1    6374.54800077                   cli.2    6250.00870242                     ili    5998.92288060                   ili.1    5937.58857678                   ili.2    5796.94767293      worried_finances.2     833.61319175      worried_finances.1     811.91646057        worried_finances     788.07693188        public_transit.2     686.73653970        public_transit.1     681.56290252          public_transit     678.83478984                  shop.2     561.76405166                  shop.1     553.87672748                    shop     546.5533950                       id     328.68231192    worried_become_ill.2     208.12264718                      MA     205.67260374    worried_become_ill.1     203.47307256      worried_become_ill     199.19546186            spent_time.2     193.92668968            spent_time.1     188.76375150              spent_time     183.14522921                      MS     164.45080730                      OK     160.7761357                       CT     146.60954017                      MD     123.5469725                       CA     122.36156229                      OH      92.60376324                      NV      86.48058110                      ID      85.60427553                 anxious      83.53223222                      MO      80.57186136                      UT      76.09237971               anxious.1      75.0735223                       AZ      72.80367685            restaurant.2      71.04775467            restaurant.1      70.08674323                      NE      69.08267649              restaurant      69.02759335                      TX      68.60934789               anxious.2      64.5877442                       AK      64.39624232                      PA      63.0960936                       CO      47.44609615                      KY      43.15197213                      IA      42.0966008                       FL      39.97677827                      NY      38.26168438                      WA      35.19877531                      OR      30.42481982  travel_outside_state.2      29.42480819                      MI      27.61129464  travel_outside_state.1      27.47727446    travel_outside_state      25.78825114                      KS      18.69999455           felt_isolated      18.34572833                      RI      18.22380073         felt_isolated.1      18.05009891         felt_isolated.2      17.89572034                      SC      15.17410045            wearing_mask      13.10686263          wearing_mask.1      11.66081520                      MN      11.13468587           large_event.2      10.9953231                       AL      10.91595281          wearing_mask.2      10.42354439                      WV       9.40700369           large_event.1       9.13166925                      NJ       8.63782437                      VA       8.32844951             large_event       7.4492279                       GA       7.30044783     work_outside_home.2       4.17440465     work_outside_home.1       3.88715654               depressed       3.83787911                      IL       3.83412347       work_outside_home       3.28351372             depressed.1       2.96797128                      NC       2.8773594                       AR       2.54622390             depressed.2       2.362492Int64Index([76, 58, 43, 61, 79, 44, 62, 80, 41, 59, 77, 42, 60, 78, 93, 75, 57,            88, 70, 52, 84, 66, 48,  0, 92, 18, 74, 56, 86, 68, 50, 21, 30,  7,            17,  5, 29, 24, 10, 53, 22, 36, 71,  3, 85, 67, 23, 49, 35, 89,  2,            32,  6, 15, 13,  8, 27, 38, 31, 82, 19, 64, 46, 14, 55, 33, 73, 91,            34, 45, 63, 20, 87,  1, 81, 39, 69, 25, 37, 51,  9, 83, 65, 54, 11,            47, 72, 28,  4, 90],           dtype='int64')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2021-12-12-update5-大进步-tada"><a href="#2021-12-12-update5-大进步-tada" class="headerlink" title="2021-12-12 update5: 大进步:tada:"></a>2021-12-12 update5: 大进步<span class="github-emoji"><span>🎉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><ul><li><p><strong>思路</strong>：因为前面实验了一下使用不同的特征，发现只有前两个特征，所以我感觉特征选择可能走到了头，需要新的思路来进一步提升模型的表现。因此从模型本身下手，更换了网络模型，从助教的baseline换成了残差模型，同样还是只有两个特征</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212170623668.png" alt="网络模型"></p></li><li><p><strong>效果</strong>：最后的效果的提升还是巨大的</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212170744439.png" alt="提交后的结果"></p></li></ul><h4 id="2021-12-12-update6-关于优化器"><a href="#2021-12-12-update6-关于优化器" class="headerlink" title="2021-12-12 update6: 关于优化器"></a>2021-12-12 update6: 关于优化器</h4><ul><li><p><strong>思路</strong>：前面改了一下网络结构，使得精度有了不错的提升。我在特征选择后面又想到了一个思路，就是换一个优化器，所以在实验完网络结构之后我又实验了一下优化器，看看优化器会不会对训练又帮助，所以把SGD换成了AdamW，AdamW比Adam少了对bias的求导，所以方向避免出错。</p><p>换优化器其实我也是实验了不少次，因为使用SGD的时候，不管超参数怎么变，总会在51个epoch的时候出现一次最优值。虽然有的超参数经过比较长的epoch之后会有新的最优值，但是51这个epoch常常会出现，不管我怎么变超参数。</p><p>所以我怀疑51个epoch的时候对于SGD优化器，已经到了一个比较wide的谷底，这个时候很难跳出去，所以有的时候会直接在这里停下来。</p><p>作为弥补我换了一个优化器，换成了AdamW，因为AdamW跳出saddle point的能力要强不少</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212173038313.png" alt="一些训练轮次"></p></li><li><p><strong>结果</strong>：更换优化器之后，训练轮次要长很多，而且最初的十多个epoch会有震荡，还在loss 空间的高处</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/train_log.png" alt="AdamW的训练过程"></p><p>上面的图其实看不太出来，因为横轴30000多个step，但是SGD的训练图在开始部分是直线下冲的</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/train_log1.png" alt="train_log1"></p><p>最后的结果是成功冲进了1分以内的误差</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212173834843.png" alt="1分以内"></p></li></ul><h4 id="2012-12-12-update7-关于正则化"><a href="#2012-12-12-update7-关于正则化" class="headerlink" title="2012-12-12 update7: 关于正则化"></a>2012-12-12 update7: 关于正则化</h4><ul><li><p><strong>思路</strong>：前面在想的时候其实还想到了第三个思路，就是在网络中加入正则化方法，一个是加入dropout，一个是加入batch normalization，因为目前这两个是公认的不错的的正则化方法。而使用正则化方法能够帮助加速训练、提高收敛精度。然而在训练时候却发现不太对劲。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212175933758.png" alt="不太对劲的正则化"></p><p>可以看到，使用batch norm 和 dropout，收敛速度不降反升。这个和大家的公认有所差别，我百思不得其解<span class="github-emoji"><span>😕</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f615.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>最后怀疑是AdamW优化器的问题。因为AdamW优化器中有限制梯度的项，而dropout会mask掉一些神经元，导致梯度在这里为0，而batch norm则是炸平梯度空间。所以怀疑问题出在这里，优化器换回SGD，好家伙，这个速度，比纯SGD快多了（下面的图第一个日志写错了，应该是batch norm）</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211212180324925.png" alt="使用AdamW的训练记录"></p></li></ul><h4 id="2021-12-13-update1-Strong-Network，More-Complex-data"><a href="#2021-12-13-update1-Strong-Network，More-Complex-data" class="headerlink" title="2021-12-13 update1: Strong Network，More Complex data"></a>2021-12-13 update1: Strong Network，More Complex data</h4><ul><li><p><strong>问题</strong>：昨天在最后使用adam优化器和residual模块的配合，训练阶段使用特征选择选出来的前两天的确诊人数，一共2个dimension的feature作为输入进行训练，最后得到的精度0.98左右。昨天的炼丹就到此为止了。昨天晚上在复盘的时候想到，老师上课讲过的模型训练攻略里说的内容。</p><ol><li>而在复盘的时候想起来，昨天的炼丹过程其实提升最大的有两段，第一段就是在一开始使用助教的baseline的时候，使用特征抽取选取了前两天的特征，loss在training data上的损失就收敛到1.x左右了。可是使用baseline在这之后不管怎么样都始终无法进入到0.x的大关。而关于Optimization中也实验过了正则化、调参、换优化器等等手段。但是模型的表现还是没有下降。</li><li>第二个阶段就是换了residual的模型，性能立马又有了提升。但是同样的，residual的模型各种optimization的方法都已经试过了，最后还是卡在了0.98左右。</li></ol><p>最后想想老师讲的课，突然明白，在一开始的时候，model的能力不够强，所以没有办法学好14个重要特征。因此选择前两天的确诊人数作为feature，性能有了很大的提升。这个时候的问题可能是baseline model 的model bias了，即模型的能力不够强。后来歪打正着换了一个模型，同样的数据和参数下训练，性能立马有了提升，所以确信是baseline模型的问题。</p><p>可是后来不管怎么调，residual的模型性能也上不去了。后来其实我也试了一下wide的模型，wide + residual的模型，最后性能都不是很好。这个时候我突然想起来，因为baseline里面是两个feature表现最好，所以我就直接用了两个dimension的feature来train residual的一系列model。后来换model单纯的只是希望能够得到能力更强的model。</p><p>但是问题却在于，能力更强的model确实能够得到更好的performance，但是我并不知道residual是否达到了他的上限，即有可能是我只用了前两天的确诊人数，这样的training data对residual太弱了，他完全学有余力。</p><p>刚好我也没有像baseline一样进行特征选择的测试，所以我其实并不知道residual的model是否达到他的上限了。所以今天我试着使用了更多的training data，即使用了所有大于5000分的数据，一共14个维度</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211213003527934.png" alt="用更多的数据来训练residual model"></p></li><li><p><strong>结果</strong>：最后经过训练之后提交，大进步<span class="github-emoji"><span>🎉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211213003658575.png" alt="使用14个feature训练的结果"></p></li></ul><h4 id="2021-12-13-update2-temp-final"><a href="#2021-12-13-update2-temp-final" class="headerlink" title="2021-12-13 update2: temp final"></a>2021-12-13 update2: temp final</h4><p>搞到现在，做了一下，现在最优的成绩是下面的，基本上就是残差模块的数量问题，关于伪标签其实我感觉如果用test的data来做的话，就会有过拟合test数据的嫌疑。所以目前想的是等用generative的方法来做，目前暂时就先到这里</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211213015919490.png" alt="目前的最优成绩"></p><h2 id="4-My-Codes"><a href="#4-My-Codes" class="headerlink" title="4. My Codes"></a>4. My Codes</h2><p>下面是我的代码</p><h3 id="1-代码结构"><a href="#1-代码结构" class="headerlink" title="1. 代码结构"></a>1. 代码结构</h3><p>整个代码的结构如下</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(torch) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/deeplearning/hw1_1-regression$ tree -d -L 2.├── checkpoint│   ├── Baseline│   ├── DeeperNet│   ├── DeeperNormalizedNet│   ├── OtherNet│   └── WideNet├── data├── log│   ├── Baseline│   ├── DeeperNet│   ├── DeeperNormalizedNet│   ├── OtherNet│   └── WideNet├── src│   ├── config│   └── __pycache__└── submission    ├── Baseline    ├── DeeperNet    ├── DeeperNormalizedNet    ├── OtherNet    └── WideNet22 directories<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中:</p><ul><li><p>src里都是源代码</p></li><li><p>checkpoint、log和submission都如其名</p></li><li><p>每次进行训练的时候，都会根据模型（网络）名创建一个文件夹，在里面放对应的训练日志、提交结果、参数文件等等。以log为例，每次得到的结果都是根据日期和时间创建的文件夹。只有正确训练结束才会三个文件，分别为训练摘要、训练图像以及训练的过程中的loss。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(torch) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/deeplearning/hw1_1-regression$ tree log/DeeperNet/log/DeeperNet/├── 2021-12-12 16_52_47├── 2021-12-12 16_53_13├── 2021-12-12 16_53_38├── 2021-12-12 16_54_21├── 2021-12-12 16_55_03│   └── message.txt├── 2021-12-12 16_56_25│   └── message.txt├── 2021-12-12 16_56_50│   ├── message.txt│   ├── train_log1.png│   └── train_val.loss.pkl├── 2021-12-12 17_12_44├── 2021-12-12 17_12_57│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 17_16_00│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 17_16_56│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 17_17_49│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 17_20_12├── 2021-12-12 17_20_34│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 17_41_30│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 18_17_42│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 18_21_58├── 2021-12-12 18_22_24│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 18_28_27│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_17_44│   └── message.txt├── 2021-12-12 19_18_15│   └── message.txt├── 2021-12-12 19_18_42│   └── message.txt├── 2021-12-12 19_19_12│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_20_16│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_25_46│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_27_36│   └── message.txt├── 2021-12-12 19_28_20│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_33_37│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_37_51│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_42_24│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_48_44│   └── message.txt├── 2021-12-12 19_48_59│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_52_28│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 19_56_30│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 20_05_07├── 2021-12-12 20_05_46│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 20_10_02│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 20_12_20│   └── message.txt├── 2021-12-12 20_13_33│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 20_16_43│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-12 20_21_37│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-13 00_46_42│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-13 00_59_08│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-13 01_34_47│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-13 01_39_11│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-13 01_48_12│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl├── 2021-12-13 01_51_22│   ├── message.txt│   ├── train_log.png│   └── train_val.loss.pkl└── 2021-12-13 01_55_10    ├── message.txt    ├── train_log.png    └── train_val.loss.pkl48 directories, 104 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>直接提交submission中生成的文件即可</li></ul><h3 id="2-src中文件作用"><a href="#2-src中文件作用" class="headerlink" title="2. src中文件作用"></a>2. src中文件作用</h3><p>src中有这些文件</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(torch) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/deeplearning/hw1_1-regression$ tree src/ -L 1src/├── config├── dataset.py├── feature_selection.py├── gen_submission.py├── networks.py├── pathconfig.py├── __pycache__└── train.py2 directories, 6 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li>train是训练代码</li><li>gen_submission是生成结果的代码</li><li>networks是所有的网络的代码</li><li>feature_selection 是做特征工程的时候代码</li></ul><p>具体的代码在下面给出来</p><h3 id="3-data中的数据"><a href="#3-data中的数据" class="headerlink" title="3. data中的数据"></a>3. data中的数据</h3><p>data中需要把训练、测试数据放进去就行了</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">(torch) jack@jack-Alienware-m15-R3:/media/jack/JackCode/project/deeplearning/hw1_1-regression$ tree data/data/├── covid.test.csv├── covid.train.csv└── sampleSubmission.csv0 directories, 3 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实最后只会用到test 和 train</p><h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>用的时候要注意，gen_submission要改参数文件的路径。此外自己想写网络的话需要继承_NetworkBase，然后重写dtype</p><p>训练网络和生成结果的时候一种网络一个函数即可</p><h4 id="1-pathconfig-py"><a href="#1-pathconfig-py" class="headerlink" title="1. pathconfig.py"></a>1. pathconfig.py</h4><p>自动决定所有的路径</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import sysfrom pathlib import Pathfrom colorama import Fore, Styleif (p:=Path(__file__).resolve().parent).__str__() not in sys.path:    sys.path.append(p.__str__())def green(s: str):    return f"{Fore.GREEN}{s}{Fore.RESET}"def red(s: str):    return f"{Fore.RED}{s}{Fore.RESET}"def yellow(s: str):    return f"{Fore.YELLOW}{s}{Fore.RESET}"class Paths:    base_path: Path = Path(__file__).resolve().parents[1]    src_path: Path = base_path.joinpath("src")    log_path: Path = base_path.joinpath("log")    data_path: Path = base_path.joinpath("data")    checkpoint_path: Path = base_path.joinpath("checkpoint")    submission_path: Path = base_path.joinpath("submission")    train_path: Path = data_path / "covid.train.csv"    test_path: Path = data_path / "covid.test.csv"    config_path: Path = src_path / "config"for key, value in Paths.__dict__.items():    if key.endswith("_path") and not value.exists():        value.mkdir(parents=True)if __name__ == "__main__":    pc = Paths()    print(pc.base_path)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-feature-selection-py"><a href="#2-feature-selection-py" class="headerlink" title="2. feature_selection.py"></a>2. feature_selection.py</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport pandas as pdfrom sklearn import preprocessingfrom sklearn.feature_selection import SelectKBest, f_regressionfrom pathconfig import Pathsdata = pd.read_csv(Paths.train_path)x, y = data.iloc[:, :-1], data.iloc[:, -1]x = (x - x.min()) / (x.max() - x.min())# 根据得分函数计算出来的分数选取前五个bestfeatures = SelectKBest(score_func=f_regression, k=5)fit = bestfeatures.fit(x,y)dfscores = pd.DataFrame(fit.scores_)dfcolumns = pd.DataFrame(x.columns)#concat two dataframes for better visualization featureScores = pd.concat([dfcolumns,dfscores],axis=1)featureScores.columns = ['Specs','Score']  #naming the dataframe columnspd.set_option('display.max_rows', None)print(featureScores.nlargest(90,'Score'))  #print 15 best featuresprint(featureScores.nlargest(90, "Score").index)print(pd.Series(data.columns))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-dataset-py"><a href="#3-dataset-py" class="headerlink" title="3. dataset.py"></a>3. dataset.py</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pickleimport randomimport typingimport numpy as npimport pandas as pdimport torch.utils.data as datafrom pathconfig import *class CovidDataset(data.Dataset):    def __init__(self, split="train", dim2use: typing.Iterable[int]=None, val_ratio: float=-1) -> None:        super().__init__()        dim2use = range(93) if dim2use is None else dim2use        assert split in ["train", "test", "val"], red(f"无效的数据集类别：{split}")        assert (t:=(np.array(dim2use) < 93)).all(), red(f"无效的feature dimension， 最大只有 93 维(0-92), dim2use={dim2use[t]} > 92")        # read file        self.split: str = split        if self.split == "test":            raw_csv: np.ndarray = (a:=pd.read_csv(Paths.test_path, header=0, index_col=0, dtype=float)).to_numpy()        else:            raw_csv: np.ndarray = pd.read_csv(Paths.train_path, header=0, index_col=0, dtype=float).to_numpy()            if 0 < val_ratio < 1:                val_idx: typing.List[int] = random.sample(population=range(len(raw_csv)), k=int(val_ratio * len(raw_csv)))                train_idx: typing.List[int] = list(set(range(len(raw_csv))) - set(val_idx))                if Paths.config_path.joinpath("train_val.pkl").exists():                    print(yellow("覆盖train_val.pkl"))                with open(Paths.config_path.joinpath("train_val.pkl"), "wb") as f:                    pickle.dump(obj={"train":train_idx, "val":val_idx}, file=f)            else:                try:                    with open(Paths.config_path.joinpath("train_val.pkl"), "rb") as f:                        p = pickle.load(file=f)                        train_idx: typing.List[int] = p["train"]                        val_idx: typing.List[int] = p["val"]                except FileNotFoundError:                    assert False, red(f"不存在train_validation的config文件，请先指定val_ratio生成train_val的config")            if split == "val":                raw_csv = raw_csv[val_idx, :]            else:                raw_csv = raw_csv[train_idx, :]        # standard        self.mean = raw_csv[:, 40:-1].mean(axis=0)        self.std = raw_csv[:, 40:-1].std(axis=0)        raw_csv[:, 40:-1] = (raw_csv[:, 40:-1] - self.mean) / self.std        if self.split != "test":            self.data: np.ndarray = raw_csv[:,:-1][:, dim2use]            self.label: np.ndarray = raw_csv[:,-1]        else:            self.data: np.ndarray = raw_csv[:,:][:, dim2use]    def __len__(self) -> int:        return len(self.data)    def __getitem__(self, index: int) -> typing.Tuple[np.ndarray]:        if self.split != "test":            return self.data[index], self.label[index]        else:            return self.data[index]if __name__ == "__main__":    # cd = CovidDataset(split="train", val_ratio=0.1)    # cd = CovidDataset(split="val", dim2use=range(10))    # cd = CovidDataset(split="test", dim2use=range(10))    cd = CovidDataset(split="train", dim2use=None)    print(cd.data.shape)    for x, y in cd:        print(x, y)        print(x.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-networks-py"><a href="#4-networks-py" class="headerlink" title="4. networks.py"></a>4. networks.py</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import torchimport torch.nn as nnclass _NetworkBase(nn.Module):    def __init__(self):        super().__init__()        self.dtype = None        self.net: nn.Module = Noneclass Baseline(_NetworkBase):    def __init__(self, in_features:int):        super().__init__()        self.net = nn.Sequential(            nn.Linear(in_features=in_features, out_features=64),            nn.ReLU(),            nn.Linear(in_features=64, out_features=1)        )        for name, son in self.net.named_children():            weight: nn.parameter.Parameter            if (weight:=getattr(son, "weight", None)) is not None:                self.dtype: torch.dtype = weight.dtype    def forward(self, x: torch.Tensor):        # x: [batch, channel]        return self.net(x)class DeeperNet(_NetworkBase):    def __init__(self, in_features: int):        super().__init__()        self.input_trainsform = nn.Sequential(            nn.Linear(in_features=in_features, out_features=64),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=128),            # nn.Dropout(),        )        self.residual_block1 = nn.Sequential(            nn.Linear(in_features=64, out_features=32),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=64),            # nn.Dropout(),            nn.Linear(in_features=32, out_features=64),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=128),            # nn.Dropout(),        )        self.residual_block2 = nn.Sequential(            nn.Linear(in_features=64, out_features=32),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=64),            # nn.Dropout(),            nn.Linear(in_features=32, out_features=64),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=128),            # nn.Dropout(),        )        self.residual_block3 = nn.Sequential(            nn.Linear(in_features=64, out_features=32),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=64),            # nn.Dropout(),            nn.Linear(in_features=32, out_features=64),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=128),            # nn.Dropout(),        )        self.residual_block4 = nn.Sequential(            nn.Linear(in_features=64, out_features=32),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=64),            # nn.Dropout(),            nn.Linear(in_features=32, out_features=64),            nn.LeakyReLU(),            # nn.BatchNorm1d(num_features=128),            # nn.Dropout(),        )        self.output = nn.Sequential(            nn.Linear(in_features=64, out_features=1),            # nn.LeakyReLU(),            # nn.Linear(in_features=32, out_features=1)        )        for name, son in self.input_trainsform.named_children():            weight: nn.parameter.Parameter            if (weight:=getattr(son, "weight", None)) is not None:                self.dtype: torch.dtype = weight.dtype    def forward(self, raw_x: torch.Tensor) -> torch.Tensor:        x = self.input_trainsform(raw_x)        y1 = self.residual_block1(x) + x        y2 = self.residual_block2(y1) + y1         # y3 = self.residual_block3(y2) + y2        # y4 = self.residual_block4(y3) + y3        return self.output(y2)class DeeperNormalizedNet(_NetworkBase):    def __init__(self, in_features: int):        super().__init__()        self.input_trainsform = nn.Sequential(            nn.Linear(in_features=in_features, out_features=128),            nn.ReLU()        )        self.residual_block1 = nn.Sequential(            nn.Linear(in_features=128, out_features=64),            nn.ReLU(),            # nn.BatchNorm1d(num_features=64),            # nn.Dropout(),            nn.Linear(in_features=64, out_features=128),            nn.ReLU(),            # nn.BatchNorm1d(num_features=128),            # nn.Dropout(),        )        self.residual_block2 = nn.Sequential(            nn.Linear(in_features=128, out_features=64),            nn.ReLU(),            # nn.BatchNorm1d(num_features=64),            # nn.Dropout(),            nn.Linear(in_features=64, out_features=128),            nn.ReLU(),            # nn.BatchNorm1d(num_features=128),            # nn.Dropout(),        )        self.output = nn.Linear(in_features=128, out_features=1)        for name, son in self.input_trainsform.named_children():            weight: nn.parameter.Parameter            if (weight:=getattr(son, "weight", None)) is not None:                self.dtype: torch.dtype = weight.dtype    def forward(self, raw_x: torch.Tensor) -> torch.Tensor:        x = self.input_trainsform(raw_x)        y1 = self.residual_block1(x) + x        y2 = self.residual_block2(y1) + y1        return self.output(y2)class WideNet(_NetworkBase):    def __init__(self, in_features: int):        super().__init__()        self.input_trainsform = nn.Sequential(            nn.Linear(in_features=in_features, out_features=128),            nn.ReLU()        )        self.residual_block1 = nn.Sequential(            nn.Linear(in_features=128, out_features=64),            nn.ReLU(),            nn.Linear(in_features=64, out_features=128),            nn.ReLU()        )        self.residual_block2 = nn.Sequential(            nn.Linear(in_features=128, out_features=64),            nn.ReLU(),            nn.Linear(in_features=64, out_features=128),            nn.ReLU()        )        self.residual_block3 = nn.Sequential(            nn.Linear(in_features=128, out_features=64),            nn.ReLU(),            nn.Linear(in_features=64, out_features=128),            nn.ReLU()        )        self.output = nn.Linear(in_features=128, out_features=1)        for name, son in self.input_trainsform.named_children():            weight: nn.parameter.Parameter            if (weight:=getattr(son, "weight", None)) is not None:                self.dtype: torch.dtype = weight.dtype    def forward(self, raw_x: torch.Tensor) -> torch.Tensor:        x = self.input_trainsform(raw_x)        y11 = self.residual_block1(x) + x        y12 = self.residual_block2(x) + x        y1 = (y11 + y12) / 2        y2 = self.residual_block3(y1) + y1        return self.output(y2)class OtherNet(_NetworkBase):    def __init__(self, in_features: int):        super().__init__()        self.net = nn.Sequential(            nn.Linear(in_features=in_features, out_features=32),            nn.BatchNorm1d(num_features=32),            nn.Dropout(p=0.2),            nn.LeakyReLU(),            nn.Linear(in_features=32, out_features=1)        )        for name, son in self.net.named_children():            weight: nn.parameter.Parameter            if (weight:=getattr(son, "weight", None)) is not None:                self.dtype: torch.dtype = weight.dtype    def forward(self, x: torch.Tensor):        # x: [batch, channel]        return self.net(x)if __name__ == "__main__":    baseline = Baseline(in_features=93)    x = torch.randn(64, 93).to(dtype=baseline.dtype, device=baseline.device)    baseline(x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-train-py"><a href="#5-train-py" class="headerlink" title="5. train.py"></a>5. train.py</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import datetimeimport typingfrom pathlib import Pathimport numpy as npimport pandas as pdimport matplotlib as mplimport matplotlib.pyplot as pltfrom colorama import Fore, Stylefrom matplotlib.axes import Axesimport torchimport torch.cudaimport torch.backends.cudnnimport torch.optim as optimimport torch.nn as nnfrom torch.optim import optimizerimport torch.utils.data as dataimport networksfrom pathconfig import *from dataset import *class Trainer(object):    def __init__(self, network: networks._NetworkBase, dim2use: typing.List[int]=None) -> None:        super().__init__()        self.start_time: str = datetime.datetime.now().__str__().split(".")[0]        self.select_device()        self.reproducibile()        self.network = network.to(device=self.device)        self.suffix: str = self.network.__class__.__name__        self.log_folder: Path = Paths.log_path / self.suffix / self.start_time.replace(":", "_")        self.checkpoint_path: Path = Paths.checkpoint_path / self.suffix / f"{self.start_time}.pt".replace(":", "_")        if not self.checkpoint_path.parent.exists():            self.checkpoint_path.parent.mkdir(parents=True)        if not self.log_folder.exists():            self.log_folder.mkdir(parents=True)        # train        self.train_loader = data.DataLoader(CovidDataset(split="train", dim2use=dim2use), batch_size=64, shuffle=True)        self.val_loader = data.DataLoader(CovidDataset(split="val", dim2use=dim2use), batch_size=64, shuffle=False)        # mse for regression        self.lossfunc = nn.MSELoss(reduction="mean")        # self.lossfunc = nn.(reduction="mean")        # visualize        self.train_loss: typing.List[float] = []        self.val_loss: typing.List[float] = []        self.min_val_loss: float = float("inf")        self.axes: Axes        _, self.axes = plt.subplots(nrows=1, ncols=1, figsize=(18,9))    def select_device(self):        self.device = "cuda" if torch.cuda.is_available() else "cpu"    def reproducibile(self, seed: int=0):        np.random.seed(seed=seed)        torch.manual_seed(seed=seed)        # no optimization for convolution        torch.backends.cudnn.benchmark = False        # use default convolution algorithm        torch.backends.cudnn.deterministic = True        if self.device == "cuda":            torch.cuda.manual_seed(seed=seed)            torch.cuda.manual_seed(seed=seed)    def visualize(self, val_loss: float, train_loss: float):        plt.ion()        self.axes.cla()        self.axes.set_ylim(0.0, 400.0)        self.axes.set_xlabel("steps")        self.axes.set_ylabel("loss / MSE")        self.axes.set_title(f"{self.suffix}-{self.start_time}")        x_train = range(len(self.train_loss))        x_val = x_train[::len(self.train_loss) // len(self.val_loss)]        self.axes.plot(x_train, self.train_loss, c="tab:red", label="train loss")        self.axes.plot(x_val, self.val_loss, c="tab:cyan", label="val loss")        self.axes.plot([],[], label=f"min_val_loss: {self.min_val_loss:>5.4f}")        self.axes.plot([],[], label=f"val/train loss: {val_loss:>5.4f}/{train_loss:>5.4f}")        self.axes.text(x=len(self.train_loss)//2, y=200, s=f"Current loss: {self.train_loss[-1]:>5.4f}", fontsize=24)        self.axes.legend()        plt.pause(0.05)        plt.ioff()    def save(self, epoch: int):        print(f"Saving model at {Fore.GREEN}{Style.BRIGHT}{epoch}{Style.RESET_ALL} epoch, val_loss = {Fore.GREEN}{Style.BRIGHT}{self.min_val_loss}{Style.RESET_ALL}")        torch.save(self.network.state_dict(), f=self.checkpoint_path)    def lossfunc_l2(self, target, pred) -> torch.Tensor:        loss = self.lossfunc(target, pred)        norm_loss = 0        for param in self.network.parameters():            norm_loss += torch.sum(param**2)        return loss + norm_loss * 0.00075    @torch.no_grad()    def validation(self):        loss = 0        x: torch.Tensor        y: torch.Tensor        self.network.eval()        for x, y in self.val_loader:            x, y = x.to(device=self.device, dtype=self.network.dtype), y.to(device=self.device, dtype=self.network.dtype)            y_pred: torch.Tensor = self.network(x)            # loss += self.lossfunc(y, y_pred.squeeze()).sqrt()            # loss = self.lossfunc_l2(y, y_pred.squeeze())            loss += self.lossfunc(y, y_pred.squeeze())        l: torch.Tensor        self.val_loss.append(l:=(loss/len(self.val_loader)).cpu().item())        return l    def train(self, lr: float=1e-4, wd: float=0.9, n_epoch: int=3000, momentum=0.9, early_stop: int=200):        msg: str = input("请输入本次训练的日志记录：")        # optimizer = optim.SGD(self.network.parameters(), lr=lr, weight_decay=wd, momentum=momentum)        optimizer = optim.AdamW(self.network.parameters(), lr=lr, weight_decay=wd)        with open(self.log_folder.joinpath("message.txt"), "w") as f:            f.write(msg+"\n")            f.write(f"epoch: {n_epoch}, lr: {lr}, wd: {wd}, early_stop: {early_stop}, optimizer: {optimizer.__class__.__name__}\n")        early_stop_cnt = 0        for epoch in range(n_epoch):            x: torch.Tensor            y: torch.Tensor            self.network.train()            train_loss: float = 0            for x, y in self.train_loader:                optimizer.zero_grad()                x, y = x.to(device=self.device, dtype=self.network.dtype), y.to(device=self.device, dtype=self.network.dtype)                y_pred: torch.Tensor = self.network(x)                loss: torch.Tensor = self.lossfunc(y, y_pred.squeeze())                # loss = self.lossfunc_l2(y, y_pred.squeeze())                # loss = loss.sqrt()                loss.backward()                optimizer.step()                train_loss += loss.clone().detach().cpu().squeeze().item()                self.train_loss.append(loss.clone().detach().cpu().squeeze().item())            train_loss = (train_loss / len(self.train_loader))            val_loss = self.validation()            if val_loss < self.min_val_loss:                self.min_val_loss = val_loss                early_stop_cnt = 0                self.save(epoch=epoch)            else:                early_stop_cnt += 1            self.visualize(val_loss=val_loss, train_loss=train_loss)            if early_stop_cnt >= early_stop:                break        print(green(f"Training stopped at {epoch}"))        print(green("Saving trainig log"))        with open(self.log_folder.joinpath("train_val.loss.pkl"), "wb") as f:            pickle.dump(                {                    "val": self.val_loss,                    "train": self.train_loss,                    "min_val": self.min_val_loss                }, file=f            )        plt.savefig(self.log_folder.joinpath("train_log.png").__str__(), dpi=300)    # @torch.no_grad()    # def get_presudodef baseline():    b = networks.Baseline(in_features=93)    t = Trainer(network=b)    t.train(wd=0.5)def previous2day():    dim2use = list(range(40))    dim2use.extend([57, 75])    b = networks.Baseline(in_features=42)    t = Trainer(network=b, dim2use=dim2use)    t.train()def selected_feature():    dim2use = np.array([76, 58]) - 1    b = networks.Baseline(in_features=len(dim2use))    t = Trainer(network=b, dim2use=dim2use)    t.train()def residual():    # dim2use = np.array([76, 58]) - 1    dim2use = np.array([75, 57, 42, 60, 78, 43, 61, 79, 40, 58, 76, 41, 59, 77])    # dim2use = np.array([76, 58, 43, 61, 79, 44, 62, 80, 41, 59, 77, 42, 60, 78, 93, 75, 57, 88, 70, 52, 84, 66, 48]) - 1    # dim2use = np.array([75, 57, 61, 79, 43, 78, 60, 42, 91, 73, 83, 80, 68, 62, 40, 86, 65, 77, 85, 67, 55, 49])    d = networks.DeeperNet(in_features=len(dim2use))    t = Trainer(network=d, dim2use=dim2use)    t.train(wd=0.5, lr=1e-3)def normalized():    dim2use = np.array([76, 58]) - 1    d = networks.DeeperNormalizedNet(in_features=2)    t = Trainer(network=d, dim2use=dim2use)    t.train(wd=0.5)def wider():    dim2use = np.array([76, 58]) - 1    w = networks.WideNet(in_features=2)    t = Trainer(network=w, dim2use=dim2use)    t.train(wd=0.5, lr=1e-4)def other():    dim2use = np.array([75, 57, 42, 60, 78, 43, 61, 79, 40, 58, 76, 41, 59, 77])    o = networks.OtherNet(in_features=len(dim2use))    t = Trainer(network=o, dim2use=dim2use)    t.train(wd=0.5, lr=1e-4)if __name__ == "__main__":    # baseline()    # previous2day()    # selected_feature()    residual()    # other()    # normalized()    # wider()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-gen-submission-py"><a href="#6-gen-submission-py" class="headerlink" title="6. gen_submission.py"></a>6. gen_submission.py</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import typingimport numpy as npimport pandas as pdimport torchimport torch.utils.data as datafrom dataset import CovidDatasetimport networksfrom pathconfig import *@torch.no_grad()def gen_submission(network:networks._NetworkBase, dim2use=None, save_path: Path=None):    test_loader = data.DataLoader(dataset=CovidDataset(split="test", dim2use=dim2use), batch_size=64)    result = []    x: torch.Tensor    for x in test_loader:        x = x.to(device="cuda", dtype=network.dtype)        y_pred: torch.Tensor = network(x)        result.extend(y_pred.cpu().squeeze().tolist())    if not save_path.parent.exists():        save_path.parent.mkdir(parents=True)    result = np.array(result)    with open(save_path, "w") as f:        print(save_path)        f.write("id,tested_positive\n")        for id, r in enumerate(result):            f.write(f"{id},{r}\n")def gen_baseline():    net = networks.Baseline(in_features=93).cuda()    net.load_state_dict(torch.load(s:=Paths.checkpoint_path.joinpath("../checkpoint/Baseline/2021-12-12 15_29_31.pt")))    gen_submission(network=net, dim2use=None, save_path=Paths.submission_path.joinpath(net.__class__.__name__, s.stem.split(".")[0] + ".csv"))def gen2day():    net = networks.Baseline(in_features=42).cuda()    net.load_state_dict(torch.load(s:=Paths.checkpoint_path.joinpath("../checkpoint/Baseline/2021-12-12 15_40_58.pt")))    dim2use = list(range(40))    dim2use.extend([57, 75])    gen_submission(network=net, dim2use=dim2use, save_path=Paths.submission_path.joinpath(net.__class__.__name__, s.stem.split(".")[0] + ".csv"))def feature_selection():    # dim2use = np.array([76, 58, 43, 61, 79, 44, 62, 80, 41, 59, 77, 42, 60, 78, 93]) - 1    dim2use = np.array([76, 58]) - 1    net = networks.Baseline(in_features=len(dim2use)).cuda()    net.load_state_dict(torch.load(s:=Paths.checkpoint_path.joinpath("../checkpoint/Baseline/2021-12-12 16_33_04.pt")))    gen_submission(network=net, dim2use=dim2use, save_path=Paths.submission_path.joinpath(net.__class__.__name__, s.stem.split(".")[0] + ".csv"))def residual():    # dim2use = np.array([76, 58, 43, 61, 79, 44, 62, 80, 41, 59, 77, 42, 60, 78, 93]) - 1    # dim2use = np.array([76, 58]) - 1    dim2use = np.array([75, 57, 42, 60, 78, 43, 61, 79, 40, 58, 76, 41, 59, 77])    # dim2use = np.array([75, 57, 61, 79, 43, 78, 60, 42, 91, 73, 83, 80, 68, 62, 40, 86, 65, 77, 85, 67, 55, 49])    # dim2use = np.array([76, 58, 43, 61, 79, 44, 62, 80, 41, 59, 77, 42, 60, 78, 93, 75, 57, 88, 70, 52, 84, 66, 48]) - 1    # dim2use = np.array([75, 57])    net = networks.DeeperNet(in_features=len(dim2use)).cuda()    net.load_state_dict(torch.load(s:=Paths.checkpoint_path.joinpath("../checkpoint/DeeperNet/2021-12-13 01_55_10.pt")))    gen_submission(network=net, dim2use=dim2use, save_path=Paths.submission_path.joinpath(net.__class__.__name__, s.stem.split(".")[0] + ".csv"))def normalize():    # dim2use = np.array([76, 58, 43, 61, 79, 44, 62, 80, 41, 59, 77, 42, 60, 78, 93]) - 1    dim2use = np.array([76, 58]) - 1    net = networks.DeeperNormalizedNet(in_features=len(dim2use)).cuda()    net.load_state_dict(torch.load(s:=Paths.checkpoint_path.joinpath("../checkpoint/DeeperNormalizedNet/2021-12-12 17_55_08.pt")))    gen_submission(network=net, dim2use=dim2use, save_path=Paths.submission_path.joinpath(net.__class__.__name__, s.stem.split(".")[0] + ".csv"))def wider():    dim2use = np.array([76, 58]) - 1    net = networks.WideNet(in_features=len(dim2use)).cuda()    net.load_state_dict(torch.load(s:=Paths.checkpoint_path.joinpath("../checkpoint/WideNet/2021-12-12 18_12_38.pt")))    gen_submission(network=net, dim2use=dim2use, save_path=Paths.submission_path.joinpath(net.__class__.__name__, s.stem.split(".")[0] + ".csv"))def other():    dim2use = np.array([75, 57, 42, 60, 78, 43, 61, 79, 40, 58, 76, 41, 59, 77])    net = networks.OtherNet(in_features=len(dim2use)).cuda()    net.load_state_dict(torch.load(s:=Paths.checkpoint_path.joinpath("../checkpoint/OtherNet/2021-12-13 00_49_48.pt")))    gen_submission(network=net, dim2use=dim2use, save_path=Paths.submission_path.joinpath(net.__class__.__name__, s.stem.split(".")[0] + ".csv"))if __name__ == "__main__":    # gen_baseline()    # gen2day()    # feature_selection()    # other()    residual()    # normalize()    # wider()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 李宏毅ML2021 Spring Homeworks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Hungyi Li </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Neural Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李宏毅ML2021 Spring homeworks: hw0 -- 概述</title>
      <link href="/2021/12/11/li-hong-yi-ml2021-spring-hw0-gai-shu/"/>
      <url>/2021/12/11/li-hong-yi-ml2021-spring-hw0-gai-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文讲解李宏毅ML2021 Spring homeworks系列文章的写作原因以及系列文章的写作目的</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207145714311.png" alt="课程官网"></p><span id="more"></span><h1 id="李宏毅ML2021-Spring-homeworks-hw0-—-概述"><a href="#李宏毅ML2021-Spring-homeworks-hw0-—-概述" class="headerlink" title="李宏毅ML2021 Spring homeworks: hw0 — 概述"></a>李宏毅ML2021 Spring homeworks: hw0 — 概述</h1><p>李宏毅老师的Machine Learning 2021 Spring的课程李宏毅老师以及上传到他的Youtube上了，并且系列作业也已经经过整理向公众开放。今年的ML课程完全关注Deep Learning，此外结合了Kaggle的许多实战。<strong>因此本系列文章记录了我在完成作业时候的心得与体会。</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/44fe603d253c2586def6d0e832b5efd6_r.jpg" alt="ML与DL的关系"></p><h2 id="1-写作初心"><a href="#1-写作初心" class="headerlink" title="1. 写作初心"></a>1. 写作初心</h2><p>在2019年我刚进入大学的时候，那个时候深度学习已经火热起来了。在那个时候我就通过观看李宏毅老师的Machine Learning的系列课程从而对机器学习和深度学习入门了。</p><p>然而可惜的是，由于种种原因，在2019年的时候，李宏毅老师的ML系列课程我最终没有坚持下来全部看完。</p><p>一方面是受到了当时学识的限制。在那时候刚刚进入大学，刚刚开始学习线性代数，对概率论、图论、凸优化、计算机、多元高等数学等内容完全没有接触过。</p><p>另外一方面当时更加关注与计算机底层LInux等内容的学习；最后是大一时候的课是真的多。</p><p>因此最终没有听完2019年的课程，非常的可惜。</p><p>现在因为降级转入计算机专业的原因，有了很多的时间；此外自己在业余时间也已经把许多计算机的课程、深度学习的数学原理课程都已经学过了，编程能力也有了非常大的提升。</p><p>又恰逢2021年李宏毅老师的课程上架。因此决定这一次详细的学完所有课程并完成对应的作业。</p><p>所有的作业都以博客的形式来记录我炼丹的点滴。希望能够见证我这一段时间的投入和付出。</p><h2 id="2-Who-is-Hung-yi-Lee"><a href="#2-Who-is-Hung-yi-Lee" class="headerlink" title="2. Who is Hung-yi Lee"></a>2. Who is Hung-yi Lee</h2><p>As now we are going to have classes of Hung-yi Lee, we’d better have some knowledge of him.</p><p>首先是<code>Wikipedia</code>的介绍</p><blockquote><p><strong>From wikipedia</strong></p><p>李宏毅（1985年或1986年－），台湾地区计算机科学家，国立台湾大学电机工程学系副教授，研究领域包括语意理解、语音辨识、机器学习、深度学习等。</p><p>李宏毅在大学二年级时，因对电机系许多课程感到困惑，曾一度非常沮丧迷惘，甚至萌生了退学的念头。他当时选了一门“数字通信处理”课程，发现自己难以听懂，但他并未放弃，不弃选不退修，最终豁然开朗，“原来用手机拨电话给别人时，中间发生的事就是这些信号处理。”找到学习的兴趣后，李宏毅开始跟随中央研究院李琳山院士做项目，随后于2010年从国立台湾大学取得硕士学位，2012年取得博士学位。2012年9月至2013年8月间，李宏毅于中央研究院资讯科技创新研究中心担任博士后研究员。2013年9月以客座科学家身份前往麻省理工学院计算机科学暨人工智能实验室。2014年返台，担任台湾大学电机工程学系教师至今。</p><p>2015年，李宏毅开始在台湾大学讲授机器学习课程，选课人数通常爆满，有400多人来修。于是，李宏毅将学生分在两间教室，一间现场看老师上课，另一间同步看直播。由于直播上课的诸多限制，李宏毅养成了录制课程影片的习惯。一开始李宏毅将影片上传至个人主页，后来由于萤幕侧录软件的序号过期，无法导出MP4，但有导出至YouTube的选项，于是李宏毅开始将课程影片上传至YouTube。此举不仅帮助了台湾大学的学生，还意外嘉惠台湾大学以外的学生。在其影片下方，还有中国大陆的学生留言感谢，表示已经听完全部课程，并留下笔记连结。截至2021年9月30日，李宏毅的YouTube频道有8.99万位订阅者，最热门的影片有56万次观看。</p><p>李宏毅擅长用浅显易懂的语言，以学生喜爱的精灵宝可梦、凉宫春日等动漫来讲解复杂的机器学习技术，因此被亲切地称为“精灵宝可梦大师”。中华民国电脑学会称李宏毅为“第一个公开有系统地完整深入讲解深度学习技术的学者，使得华文的深度学习教学与英文世界并驾齐驱。”</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207143939983.png" alt="维基百科对老师的介绍"></p><p>从维基百科的介绍中能够看出来，李宏毅老师讲解机器学习的课程非常的有趣和生动，因此广受欢迎。我在当初也是受到了李宏毅老师早年的课程的熏陶，才进入了ML/DL的大门。</p><h2 id="3-Why-is-Hung-yi-Lee"><a href="#3-Why-is-Hung-yi-Lee" class="headerlink" title="3. Why is Hung-yi Lee"></a>3. Why is Hung-yi Lee</h2><p>为什么选择李宏毅老师的课程而非其他老师的课程？</p><p>首先是因为李宏毅老师的课程非常的通俗易懂，在讲课的时候老师会举各种各样的例子，宝可梦、全职猎人、凉宫春日等等，贴近与学生的距离。</p><p>其次是因为老师的ML的课程从16年到现在以及过去了5年时间了，在这五年中老师的课程已经经过了长久的打磨，因此会具备丰富的经验，所以学起来的时候体验会好很多。</p><p>最后就是关于我个人的原因，因为先前没有学完老师2019年的课程，感到非常遗憾，所想要在2021年完成老师的课程，弥补当年的遗憾。</p><h2 id="4-How-to-learn"><a href="#4-How-to-learn" class="headerlink" title="4. How to learn"></a>4. How to learn</h2><p>本系列文章将会记录每个作业的说明，我对每个作业的理解以及我在完成作业时的Update，在最后会附带上完整的项目代码。</p><p>所以每一个博客对应的一个作业，其结构大概类似于下面：</p><ol><li>作业介绍</li><li>我的作业动态</li><li>最终代码</li></ol>]]></content>
      
      
      <categories>
          
          <category> 李宏毅ML2021 Spring Homeworks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Hungyi Li </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> CNN </tag>
            
            <tag> Attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo的个人技术博客搭建 Part 4 Markdown编辑器Typora的设置以及腾讯云图床设置</title>
      <link href="/2021/12/10/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-4-markdown-bian-ji-qi-typora-de-she-zhi-yi-ji-teng-xun-yun-tu-chuang-she-zhi/"/>
      <url>/2021/12/10/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-4-markdown-bian-ji-qi-typora-de-she-zhi-yi-ji-teng-xun-yun-tu-chuang-she-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面我们通过hexo在本地搭建出了静态博客网站的框架，那么我们还需要一个合适的Markdown编辑器来帮助我们快乐的写博客</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211211015803341.png" alt="最终效果图:Nord主题"></p><span id="more"></span><h1 id="基于Hexo的个人技术博客搭建-——-Markdown编辑器Typora的设置以及腾讯云图床设置"><a href="#基于Hexo的个人技术博客搭建-——-Markdown编辑器Typora的设置以及腾讯云图床设置" class="headerlink" title="基于Hexo的个人技术博客搭建 ——  Markdown编辑器Typora的设置以及腾讯云图床设置"></a>基于Hexo的个人技术博客搭建 ——  Markdown编辑器Typora的设置以及腾讯云图床设置</h1><p>通过前面的几讲，我们已经成功的在本地搭建出来了一个博客网站，并且进行了美化。然而博客网站的目的在于发布我们自己的博客，因此我们还需要一个趁手的编辑器来帮助我们编写<code>Markdown</code>文章。</p><p>经过重重考虑，我最终的博客开发环境为：<code>Typora</code> + 腾讯云图床 + <code>Github</code>托管网页。</p><p>在本章将讲解Typora编辑器的设置和腾讯云图床的设置。下节将讲解腾讯云图床的设置。</p><h2 id="1-What-is-Typora-图床？"><a href="#1-What-is-Typora-图床？" class="headerlink" title="1. What is Typora/图床？"></a>1. What is Typora/图床？</h2><h3 id="1-Typora"><a href="#1-Typora" class="headerlink" title="1. Typora"></a>1. Typora</h3><p>首先是<code>维基百科</code>的介绍</p><blockquote><p><strong>From Wikipidia</strong></p><p>Typora是一款由Abner Lee开发的轻量级Markdown编辑器，适用于OS X、Windows和Linux三种操作系统。与其他Markdown编辑器不同的是，Typora没有采用源代码和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式。</p></blockquote><p>其实说白了，<code>Typora</code>和记事本没有任何的区别，都是拿来写文本文件的。只不过Typora是专门拿来写Markdown文件的。针对<code>Markdown</code>文件的编写，Typora的体验会非常好。</p><p>此外Typora是一个三平台通用的编辑器，而且非常轻量，因此对于大型的IDE而言打开速度会快很多</p><h3 id="2-图床"><a href="#2-图床" class="headerlink" title="2. 图床"></a>2. 图床</h3><p><code>百度百科</code>的介绍</p><blockquote><p><strong>From BaiduBaike</strong></p><p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p></blockquote><p>其实说白了，图床就相当于一个相册，类似于百度云等云盘的相册功能。只不过图床里的图片都会有一个链接，通过链接就能够访问、看到这张图片。例如下面的这张图片</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207132435763.png" alt="根据链接显示图像"></p><h2 id="2-Why-Typora-图床？"><a href="#2-Why-Typora-图床？" class="headerlink" title="2. Why Typora/图床？"></a>2. Why Typora/图床？</h2><h3 id="1-Typora-1"><a href="#1-Typora-1" class="headerlink" title="1. Typora"></a>1. Typora</h3><p>其实选择Typora的原因有很多，具体来说吸引我的原因有下面的几个：</p><ol><li><p><strong>好用</strong>：用Typora来写Markdown的体验非常流畅与直观。因为Markdown本身就是一个 标记语言，所以会有非常多的标记用来说明一段文本应该被展示的样子，具体来说效果就是下面的图片中我正在写的这篇文章的Markdown源码</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211210210326416.png" alt="Markdown的源代码"></p><p>但是在Typora中，源码形式的Markdown会被直接解析并显示出对应的效果，因此会非常直观，方便书写。具体效果如下</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211210210717942.png" alt="Typora中的即时显示"></p></li></ol><ol><li><p><strong>多平台互通</strong>：因为我本身是需要进行软件程序开发、深度学习模型训练的，因此在Linux进行这些操作就会非常的舒服。而有的时候需要我去处理一些Word文本、PPT等等。这个时候就还是需要Windows上的全家桶。因此多个平台上Typora都可以使用，结合Typora以文件的形式保存配置信息，我们可以做到三个平台上Typora的无缝切换，不存在任何体验的割裂，因此非常的舒服</p></li><li><p><strong>好看</strong>：Typora是基于Node.js的程序，因此支持自己编写css来定义样式。所以我们可以自己设置Typora的外观。此外Typora还有一个不错的皮肤市场，因此我们其实可以从这个市场中下载皮肤然后进行使用。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207134405026.png" alt="Typora的皮肤市场"></p></li></ol><ol><li><p><strong>非常好的图床支持</strong>：稍后我们其实会讲到图床的好处和为什么需要图床，而<code>Typora</code>内置了<code>PicGo</code>，对各大主流的图床的支持都非常好，因此和图床搭配使用效果奇佳。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211210211710899.png" alt="Typora中的图床设置"></p></li><li><p>……</p></li></ol><p>总之，Typora有着多种多样的优点吸引我，因此我的博客中也是使用Typora作为Markdown的编辑器。事实上，我从2019年开始就已经使用Typora了，可谓是资深用户。</p><p>需要注意的是，Typora在之前全都是测试版，从2021年11月23日起发布了1.0版本，并且从1.0版本以后成为收费软件，售价14.99美元，约合89RMB。</p><p>不过官方也承诺过1.0版本以前的版本都将继续保持免费，而1.0版本以后的版本都将保持收费。其实在现在最新的Typora免费版（大概是0.11）的功能和1.0版本基本没有差别，因此再没有推出大的更新之前/足够吸引我的功能之前还是继续使用免费版。其实免费版也已经够大家使用了。</p><p>下面也会讲解如何下载免费版。</p><h3 id="2-图床-1"><a href="#2-图床-1" class="headerlink" title="2. 图床"></a>2. 图床</h3><p>我们通过hexo搭建的博客其实是一个静态博客。静态博客就意味着博客中所有的网页资源都是静态的，在用户点击请求文章的时候，文字和图片同时被发送过去。然而我们的博客资源在传输的过程中，博客资源所在的服务器的传输带宽有限，因此我们如果把图片和博客放在同一个服务器上，传输的速度就会很慢。此外我们后面也会讲解用Github托管博客资源，所以我们每次进行本地推送和异地同步就会很浪费时间。</p><p>而由于图床是我们把图片存放在图床商家的服务器，通过一个链接就可以访问，因此使用图床就可以使得用户访问文章的时候，图片的带宽需求由图床服务器承担。而图床服务器一般带宽都会非常大。因此就可以加速页面的加载速度，同时方便我们进行推送和同步。</p><p>对于我个人而言，我使用的是<strong>腾讯云存储桶作为图床</strong>，而主要原因就是我的服务器也是腾讯云的，所以我懒得换来换去。<strong>其实任何的图床厂商都是可以的。</strong></p><p>下面我们会讲解如何创建腾讯云图床，以及在Typora中设置图床。对于其他的图床在Typora中的设置其实查一下都会有。</p><h2 id="3-Typora设置"><a href="#3-Typora设置" class="headerlink" title="3. Typora设置"></a>3. Typora设置</h2><p>对于Typora的设置，主要包含四个方面：下载免费版， 换个皮肤，设置快捷键以及图床设置。不过由于图床设置是和图床有关的，因此最后的图床设置在图床创建后面讲</p><h3 id="1-下载免费版"><a href="#1-下载免费版" class="headerlink" title="1. 下载免费版"></a>1. 下载免费版</h3><p>免费版其实在官网中就有列出来。<a href="https://typora.io/">官网</a>：<a href="https://typora.io/">https://typora.io/</a></p><p>我们点进去官网翻到最底下，有一个<code>所有的历史文件</code></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211210214453168.png" alt="历史文件"></p><p>点进去之后点到开发测试版本</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211210214545807.png" alt="开发测试版本"></p><p>然后同样在最下面的old release</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211210215003642.png" alt="旧版本"></p><p>点进去之后就可以下载</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211210215114073.png" alt="下载旧版本"></p><p>点击之后下载即可</p><h3 id="2-设置皮肤"><a href="#2-设置皮肤" class="headerlink" title="2. 设置皮肤"></a>2. 设置皮肤</h3><p>安装之后，我们就可以安装皮肤。前面说过，我们可以在市场上下载皮肤，其实皮肤就是css文件加上资源文件。所以我们安装皮肤其实就是把下载的这些资源粘贴到皮肤文件夹中。</p><p>我们首先打开资源文件夹，在左上角的<code>file</code>—&gt; <code>preference</code>中选择<code>Apprence</code>，然后选择打开<code>Theme Folder</code></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207141743141.png" alt="打开主题文件夹"></p><p>然后在皮肤市场中下载需要的皮肤，我下载的<code>Nord</code>，<code>Dracula</code>和<code>Mint</code></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207141909886.png" alt="下载皮肤"></p><p>然后把下载下的皮肤压缩文件解压之后复制到打开的主题文件夹中即可，需要注意的是，皮肤最重要的是css文件，而皮肤名的文件夹中放的是一些资源，所以我们需要把css放到正确的位置</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207142137820.png" alt="复制皮肤到皮肤文件夹中"></p><p>最后重启Typora就可以在左上角的Themes中选择皮肤</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207142227515.png" alt="选择皮肤"></p><p>选择<code>Mint</code>主题看看效果</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207142620434.png" alt="Mint主题效果"></p><h3 id="3-设置快捷键"><a href="#3-设置快捷键" class="headerlink" title="3. 设置快捷键"></a>3. 设置快捷键</h3><p>Typora的快捷键设置其实是通过一个json文件完成，因此我们在这个Json文件中编辑快捷键即可</p><p>需要注意的是，我们需要首先在英文版中查看需要设置快捷键的功能的名称，例如我们需要设置快捷插入代码框Code（我这里是以及设置过了）</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207141509346.png" alt="查看功能名称"></p><p>然后我们打开Preference中的General，然后打开在keyBinding中设置功能和对应的键即可。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211210222113923.png" alt="image-20211210222113923"></p><h2 id="4-腾讯云图床创建以及Typora配置"><a href="#4-腾讯云图床创建以及Typora配置" class="headerlink" title="4. 腾讯云图床创建以及Typora配置"></a>4. 腾讯云图床创建以及Typora配置</h2><p>关于腾讯云图床的配置，参考这篇<a href="https://blog.51cto.com/u_15070902/3764737">文章</a>：<a href="https://blog.51cto.com/u_15070902/3764737">https://blog.51cto.com/u_15070902/3764737</a></p><p>最通过这样的配置，我们就完成了Typora的设置与图床的搭配，现在开始我们就可以快乐的开始写博客了 <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS杂篇 Melodic下Python3中使用CV_Bridge与TF</title>
      <link href="/2021/11/23/ros-za-pian-melodic-xia-python3-zhong-shi-yong-cv-bridge-yu-tf/"/>
      <url>/2021/11/23/ros-za-pian-melodic-xia-python3-zhong-shi-yong-cv-bridge-yu-tf/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TF与CV_Bridge是ROS中非常好用的工具，前者用于帮助我们进行坐标转换，后者帮助我们在ROS中使用OpenCV。然而在Melodic版本中Python3下使用这两个包却会报错，本文将解决这Python3CV_Bridge与TF的使用问题。</p></blockquote><span id="more"></span><h1 id="ROS杂篇-Melodic下Python3中使用CV-Bridge与TF"><a href="#ROS杂篇-Melodic下Python3中使用CV-Bridge与TF" class="headerlink" title="ROS杂篇 Melodic下Python3中使用CV_Bridge与TF"></a>ROS杂篇 Melodic下Python3中使用CV_Bridge与TF</h1><blockquote><p>前言：为什么要写这篇博客</p></blockquote><p>在使用ROS驱动机器人的时候，经常遇到的一个问题就是我们需要使用摄像头来获得视觉信息，并且在此基础上，指导机器人进行操作。</p><h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates ! ! !"></a>Updates ! ! !</h2><p>由于最近一个周我的工作变动，目前需要在Ubuntu 20.04 LTS进行ROS开发，20.04中TF和CV_Bridge默认都支持Python3，因此目前我不需要解决这个问题。这篇文章以后更完</p>]]></content>
      
      
      <categories>
          
          <category> ROS杂篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> melodic </tag>
            
            <tag> OpenCv </tag>
            
            <tag> cv_bridge </tag>
            
            <tag> sensor_msgs </tag>
            
            <tag> roslaunch </tag>
            
            <tag> tf2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS杂篇 ROS中使用Kinect V2 Part2：iai-kinect使用</title>
      <link href="/2021/11/19/ros-za-pian-ros-zhong-shi-yong-kinect-v2-iai-kinect-shi-yong/"/>
      <url>/2021/11/19/ros-za-pian-ros-zhong-shi-yong-kinect-v2-iai-kinect-shi-yong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇详细介绍了iai-kinect2功能包，在此基础上通过iai-kinect2获取深度图像，从而进行ROS中的开发。</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211121155602208.png" alt="使用Kinect V2获取得到图像经过YOLO检测并与深度配准"></p><span id="more"></span><h1 id="ROS杂篇-ROS中使用Kinect-V2-Part2：iai-kinect2使用"><a href="#ROS杂篇-ROS中使用Kinect-V2-Part2：iai-kinect2使用" class="headerlink" title="ROS杂篇 ROS中使用Kinect V2 Part2：iai-kinect2使用"></a>ROS杂篇 ROS中使用Kinect V2 Part2：iai-kinect2使用</h1><blockquote><p>前言：为什么要写这篇博客</p></blockquote><p>在上一篇中，我们介绍了如何在<code>Ubuntu</code>上安装<code>Kinect V2</code>的开原驱动：<code>libfrenect2</code>，以及如何安装在<code>ROS</code>中使用<code>libfrenect2</code>获取深度图像的功能包<code>iai-kinect2</code>。然而在上一篇文章的最后，我们只是简单的使用了一下<code>iai-kinect2</code>功能包。但是我们通过<code>rostopic list</code>却看到了非常多的话题，那么这些话题之间到底是什么关系呢？又该如何基于<code>iai-kinect2</code>进行深度开发呢？</p><p>本节就将在上一篇的基础上，在介绍<code>iai-kinect2</code>的基础上，利用<code>iai-kinect2</code>进行开发。如果没有看过第一篇文章、没有配置好环境，先按照<a href="http://jackwang.cafe/2021/11/18/ros-za-pian-an-zhuang-kinect-v2-qu-dong/">第一篇文章中的教程</a>跟着来。</p><p>废话不多说，下面就开始吧。</p><h2 id="1-什么是iai-kinect2？"><a href="#1-什么是iai-kinect2？" class="headerlink" title="1. 什么是iai-kinect2？"></a>1. 什么是iai-kinect2？</h2><blockquote><p>我认为合理的学习方法：学什么前，先问是什么，再问为什么学（学习这个东西的目的），搞懂学了能为我们带来那些帮助，最后再开始学</p></blockquote><p>如果你有看过我的上一篇博客的话，你应该就会知道，<code>iai-kinect2</code>是<code>ROS</code>的一个功能包，他的作用在于调用了<code>libfreenect2</code>驱动来获得<code>Kinect V2</code>相机得到的深度图像以及通过<code>OpenGL</code>、<code>CUDA</code>、<code>CPU</code>等平台极大地提升了渲染速度和适应性。最终实现了多平台下深度图像30 FPS的性能。</p><p>下面是对<code>iai-kinect2</code>的更加详细的介绍</p><h3 id="A-谁开发的iai-kinect2"><a href="#A-谁开发的iai-kinect2" class="headerlink" title="A. 谁开发的iai-kinect2?"></a>A. 谁开发的iai-kinect2?</h3><p>iai-kinect2是由德国不莱梅大学（University of Bremen）的博士生Thiemo Wiedemeyer。他在2013年的时候去不莱梅大学的人工智能研究所读博的时候开发出了<code>iai-kinect2</code>。在2014年的时候，经过几个月的开发，他和他组里的另外一个负责串口相关部分的博士生合作，最终完成了这个非常好用的库，并在ROS的论坛上发布了这一消息。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211120010505103.png" alt="Thiemo Wiedemeyer在ROS论坛上发布这个功能包的帖子"></p><h3 id="B-iai-kinect2的组成"><a href="#B-iai-kinect2的组成" class="headerlink" title="B. iai-kinect2的组成"></a>B. iai-kinect2的组成</h3><p>前面我们只是从大体上直到了<code>iai-kinect2</code>是一个<code>ROS</code>的功能包，他调用了<code>libfreenect2</code>来获取深度图像。其实更准确的说，<code>iai-kinect2</code>是<code>ROS</code>的一个<strong>元功能包</strong>。</p><blockquote><p><strong>什么是元功能包？</strong></p><p><code>ROS</code>中有一些基础的概念：工作空间、源码空间、编译空间、开发空间、功能包、元功能包、发行版等等。</p><p>通常我们工作是在一个工作空间中，这个工作空间中包含了我们开发的一切：我们的源代码、生成的库文件、生成的头文件、得到的可执行文件……而我们写的代码都以功能包的形式组织起来，我们在发布代码的时候就是以功能包的形式进行发布。而通常几个具有相关功能的功能包组合在一起就是一个元功能包，我们通过元功能包将几个功能包组合起来，使得他们成为一个整体来进行发布。</p><p>在下图中，我们所有的代码都在catkin_workspace这个工作空间中（挖个坑，以后写写文章讲讲什么是<code>catkin</code>）。而具体来说，我们的源代码存放在<code>src</code>源码空间中，我们通过<code>catkin_make</code>会对我们所有的源代码进行编译，编译过程中产生的中间文件，例如<code>Cmake</code>的<code>module</code>以及<code>Makefile</code>等等都在<code>build</code>编译空间中。我们最后的可执行文件和我们自己写的库文件都在<code>devel</code>开发空间中。对于源码空间中，一个package就负责实现一个具体的功能，例如读取摄像头、抓取物体等等。如果package1和package2有所关联，例如package1是读取摄像头的功能包，而package2是驱动机械臂的功能包，那么他们两个在一起可以完成机器人抓取物体这个功能，那么这个时候，我们就可以新建一个功能包，这个功能包什么都没有，只有表明这两个功能包在一起组成一个元功能包的配置信息，即描述元功能包架构的功能包。在下面就是iai-kinect2这个功能包</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/文件系统.jpg" alt="ROS中的基础概念/文件系统"></p></blockquote><p>具体来说，<code>iai-kinect2</code>这个元功能包由几个功能包组成：<code>iai-kinect2</code>（元功能包描述功能包）、<code>kinect2_bridge</code>（负责调用libfreenect2、OpenGL获取图像的功能包）、<code>kinect_calibration</code>（提供了Kinect V2相机GUI校准的功能包）、<code>kinect_registration</code>（负责点云和深度图像配准的功能包）以及<code>kinect_viewer</code>（提供了简单的可视化功能的功能包）。</p><p>具体功能包的架构可以看下图</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211120012913705.png" alt="iai-kinect2元功能包的架构"></p><h3 id="C-iai-kinect2的功能"><a href="#C-iai-kinect2的功能" class="headerlink" title="C. iai-kinect2的功能"></a>C. iai-kinect2的功能</h3><p>关于<code>iai-kinect2</code>的功能，我们前面其实已经体验过了他的可视化和获取深度图像以及点云和彩色图像的配准。因此这里主要关注<code>iai-kinect2</code>中的标定功能。</p><blockquote><p>众所周知，我们利用相机除了拍照以外，还有一个重要的功能就是从相机获取的图像信息出发计算三维空间中物体的几何信息并由此重建和识别物体。这也是计算机视觉的基本任务之一。那么我们在进行推断的时候就存在一些问题，其中最主要的一个问题就是相机的镜头畸变，即由于相机的镜头是一个凹透镜导致物体间真实的距离被扭曲。因此我们需要通过一些手段来进行修正。进行修正之后会得到一些参数，利用这些参数我们就可以对畸变的图像进行修正，以实现获得物体间精准的位置。由于这个参数和相机的镜头、角度有关，因此他们又叫做相机参数。通过标定我们就能够获得这些参数。</p><p>例如在下图中，我们可以直到机器人和地板的线都应该是直线，但是由于畸变导致原本直的线歪曲，这个现象在图像边缘处尤为明显。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211120021326327.png" alt="相机畸变修正的例子"></p><p>当然除了畸变以外还有世界坐标转相机坐标等等问题，他们统称为相机参数。</p><p>关于相机标定的更多内容，推荐参考搜狐上的博客：<a href="https://www.sohu.com/a/336803765_120071391">https://www.sohu.com/a/336803765_120071391</a></p></blockquote><p><code>iai-kinect2</code>中直接提供了用于相机标定的程序，因此我们可以直接在命令行中进行调用即可。关于如何进行校准，参考<a href="https://github.com/code-iai/iai_kinect2/tree/master/kinect2_calibration#calibrating-the-kinect-one">github上的readme</a></p><p>最终通过标定，可以实现的效果如下。可以看出来，原本倾斜的图像被校准了。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/68747470733a2f2f61692e756e692d6272656d656e2e64652f5f6d656469612f6b696e656374325f636c6f75645f6e6f63616c69622e706e67" alt="未校准前的点云图像"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/68747470733a2f2f61692e756e692d6272656d656e2e64652f5f6d656469612f6b696e656374325f636c6f75645f63616c69622e706e67" alt="校准后的点云图像"></p><h2 id="2-iai-kinect2的使用"><a href="#2-iai-kinect2的使用" class="headerlink" title="2. iai-kinect2的使用"></a>2. iai-kinect2的使用</h2><p>我们在下面将对<code>iai-kinect2</code>的使用进行介绍，不过需要说明的是：由于<code>iai-kinect2</code>的代码非常好，将自己尽可能的低耦合，因此其所有的依赖都是<code>ROS</code>的标准消息。因此，我们学习iai-kinect2的使用主要是从下面两个方面去学习</p><ul><li><code>iai-kinect2</code>中使用的<code>ROS</code>的标准消息：<code>Image</code>和<code>CompressedImage</code></li><li><code>iai-kinect2</code>中每个话题的含义和作用</li></ul><h3 id="A-ROS中Image和CompressedImage"><a href="#A-ROS中Image和CompressedImage" class="headerlink" title="A. ROS中Image和CompressedImage"></a>A. ROS中Image和CompressedImage</h3><p><code>ROS</code>中为图像数据提供了两个官方的消息类型：<code>Image</code>和<code>CompressedImage</code>。其中<code>Image</code>是没有经过压缩的图片而<code>CompressedImage</code>则是经过压缩的图片。由与<code>ROS</code>中的所有的消息其实都是基于<code>std_msgs</code>提供的基础数据类型上定义的，因此<code>Image</code>和<code>CompressedImage</code>也不例外。具体来说，图片本身是用一个装着字节流的数组保存的，而图片的<code>frame_id</code>和对应的相机信息等等都是有对应的项。</p><h4 id="消息定义"><a href="#消息定义" class="headerlink" title="消息定义"></a>消息定义</h4><p>首先是<code>Image</code>消息的定义，可以看到<code>header</code>中提供时间戳等信息，而图像的长宽、字节序、编码方式等等内容都是用于帮助解码<code>data</code>字节流的。此外也能够看到，<code>ROS</code>中的图像每一个像素都是用一个8位无符号整数描述的。</p><pre class="line-numbers language-lang-msg"><code class="language-lang-msg"># This message contains an uncompressed image# (0, 0) is at top-left corner of image#Header header        # Header timestamp should be acquisition time of image                     # Header frame_id should be optical frame of camera                     # origin of frame should be optical center of camera                     # +x should point to the right in the image                     # +y should point down in the image                     # +z should point into to plane of the image                     # If the frame_id here and the frame_id of the CameraInfo                     # message associated with the image conflict                     # the behavior is undefineduint32 height         # image height, that is, number of rowsuint32 width          # image width, that is, number of columns# The legal values for encoding are in file src/image_encodings.cpp# If you want to standardize a new string format, join# ros-users@lists.sourceforge.net and send an email proposing a new encoding.string encoding       # Encoding of pixels -- channel meaning, ordering, size                      # taken from the list of strings in include/sensor_msgs/image_encodings.huint8 is_bigendian    # is this data bigendian?uint32 step           # Full row length in bytesuint8[] data          # actual matrix data, size is (step * rows)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似的，<code>CompressedImage</code>则是经过压缩的图像，具体的压缩方式就是使用<code>jpg</code>、<code>png</code>等编码格式，因此图像的编码方式是固定的</p><pre class="line-numbers language-lang-tmsg"><code class="language-lang-tmsg">Header header        # Header timestamp should be acquisition time of image                     # Header frame_id should be optical frame of camera                     # origin of frame should be optical center of camera                     # +x should point to the right in the image                     # +y should point down in the image                     # +z should point into to plane of the imagestring format        # Specifies the format of the data                     #   Acceptable values:                     #     jpeg, pnguint8[] data         # Compressed image buffer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后需要注意的是<code>iai-kinect2</code>中还用到了<code>camerainfo</code>这个<code>ROS</code>的官方消息，其内容如下，主要定义了相机的内外参数，获取图像的分辨率等信息</p><pre class="line-numbers language-lang-msg"><code class="language-lang-msg"># This message defines meta information for a camera. It should be in a# camera namespace on topic "camera_info" and accompanied by up to five# image topics named:##   image_raw - raw data from the camera driver, possibly Bayer encoded#   image            - monochrome, distorted#   image_color      - color, distorted#   image_rect       - monochrome, rectified#   image_rect_color - color, rectified## The image_pipeline contains packages (image_proc, stereo_image_proc)# for producing the four processed image topics from image_raw and# camera_info. The meaning of the camera parameters are described in# detail at http://www.ros.org/wiki/image_pipeline/CameraInfo.## The image_geometry package provides a user-friendly interface to# common operations using this meta information. If you want to, e.g.,# project a 3d point into image coordinates, we strongly recommend# using image_geometry.## If the camera is uncalibrated, the matrices D, K, R, P should be left# zeroed out. In particular, clients may assume that K[0] == 0.0# indicates an uncalibrated camera.########################################################################                     Image acquisition info                          ######################################################################### Time of image acquisition, camera coordinate frame IDHeader header    # Header timestamp should be acquisition time of image                 # Header frame_id should be optical frame of camera                 # origin of frame should be optical center of camera                 # +x should point to the right in the image                 # +y should point down in the image                 # +z should point into the plane of the image########################################################################                      Calibration Parameters                         ######################################################################### These are fixed during camera calibration. Their values will be the ## same in all messages until the camera is recalibrated. Note that    ## self-calibrating systems may "recalibrate" frequently.              ##                                                                     ## The internal parameters can be used to warp a raw (distorted) image ## to:                                                                 ##   1. An undistorted image (requires D and K)                        ##   2. A rectified image (requires D, K, R)                           ## The projection matrix P projects 3D points into the rectified image.######################################################################### The image dimensions with which the camera was calibrated. Normally# this will be the full camera resolution in pixels.uint32 heightuint32 width# The distortion model used. Supported models are listed in# sensor_msgs/distortion_models.h. For most cameras, "plumb_bob" - a# simple model of radial and tangential distortion - is sufficient.string distortion_model# The distortion parameters, size depending on the distortion model.# For "plumb_bob", the 5 parameters are: (k1, k2, t1, t2, k3).float64[] D# Intrinsic camera matrix for the raw (distorted) images.#     [fx  0 cx]# K = [ 0 fy cy]#     [ 0  0  1]# Projects 3D points in the camera coordinate frame to 2D pixel# coordinates using the focal lengths (fx, fy) and principal point# (cx, cy).float64[9]  K # 3x3 row-major matrix# Rectification matrix (stereo cameras only)# A rotation matrix aligning the camera coordinate system to the ideal# stereo image plane so that epipolar lines in both stereo images are# parallel.float64[9]  R # 3x3 row-major matrix# Projection/camera matrix#     [fx'  0  cx' Tx]# P = [ 0  fy' cy' Ty]#     [ 0   0   1   0]# By convention, this matrix specifies the intrinsic (camera) matrix#  of the processed (rectified) image. That is, the left 3x3 portion#  is the normal camera intrinsic matrix for the rectified image.# It projects 3D points in the camera coordinate frame to 2D pixel#  coordinates using the focal lengths (fx', fy') and principal point#  (cx', cy') - these may differ from the values in K.# For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will#  also have R = the identity and P[1:3,1:3] = K.# For a stereo pair, the fourth column [Tx Ty 0]' is related to the#  position of the optical center of the second camera in the first#  camera's frame. We assume Tz = 0 so both cameras are in the same#  stereo image plane. The first camera always has Tx = Ty = 0. For#  the right (second) camera of a horizontal stereo pair, Ty = 0 and#  Tx = -fx' * B, where B is the baseline between the cameras.# Given a 3D point [X Y Z]', the projection (x, y) of the point onto#  the rectified image is given by:#  [u v w]' = P * [X Y Z 1]'#         x = u / w#         y = v / w#  This holds for both images of a stereo pair.float64[12] P # 3x4 row-major matrix########################################################################                      Operational Parameters                         ######################################################################### These define the image region actually captured by the camera       ## driver. Although they affect the geometry of the output image, they ## may be changed freely without recalibrating the camera.             ######################################################################### Binning refers here to any camera setting which combines rectangular#  neighborhoods of pixels into larger "super-pixels." It reduces the#  resolution of the output image to#  (width / binning_x) x (height / binning_y).# The default values binning_x = binning_y = 0 is considered the same#  as binning_x = binning_y = 1 (no subsampling).uint32 binning_xuint32 binning_y# Region of interest (subwindow of full camera resolution), given in#  full resolution (unbinned) image coordinates. A particular ROI#  always denotes the same window of pixels on the camera sensor,#  regardless of binning settings.# The default setting of roi (all values 0) is considered the same as#  full resolution (roi.width = width, roi.height = height).RegionOfInterest roi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于其他传感器消息，参考<code>roswiki</code>的文章：<a href="http://wiki.ros.org/sensor_msgs">http://wiki.ros.org/sensor_msgs</a></p><p>关于全部的官方消息，参考<code>roswiki</code>文章：<a href="http://wiki.ros.org/common_msgs?distro=noetic">http://wiki.ros.org/common_msgs?distro=noetic</a></p><h4 id="使用cv-bridge转接给OpenCV"><a href="#使用cv-bridge转接给OpenCV" class="headerlink" title="使用cv_bridge转接给OpenCV"></a>使用cv_bridge转接给OpenCV</h4><p>需要注意的是，上面的方式的到的图像都是<code>ROS</code>中定义的图像的消息，而<code>ROS</code>中的图像的消息和<code>OpenCV</code>的并不一样，因此如果我们后续还要对图像进行处理的话，就需要将<code>ROS</code>中的图像转变为<code>OpenCV</code>的图像。为此我们就需要使用<code>CV_bridge</code>。</p><p>ROS中的图像和OpenCV中的图像不一样的地方在于，<code>ROS</code>是通过字节流以及辅助的解码信息来表示一张图像，而OpenCV则是通过其核心的<code>lplImage</code>数据结构来表示一张图像（<code>lpl</code>表示 <code>Intel Image Processing Library</code>）。<code>lplImage</code>的定义如下，当然我们没必要全部搞懂，看看定义知道不同即可。</p><p>此外<code>Python</code>中<code>OpenCV</code>的图像的表示是基于<code>Num Py</code>的，因此还会存在不一样的地方。</p><pre class="line-numbers language-lang-c++"><code class="language-lang-c++">typedef struct _IplImage      {          int  nSize;         /* IplImage大小 */          int  ID;            /* 版本 (=0)*/          int  nChannels;     /* 大多数OPENCV函数支持1,2,3 或 4 个通道 */          int  alphaChannel;  /* 被OpenCV忽略 */          int  depth;         /* 像素的位深度: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,                                IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F 可支持 */          char colorModel[4]; /* 被OpenCV忽略 */          char channelSeq[4]; /* 同上 */          int  dataOrder;     /* 0 - 交叉存取颜色通道, 1 - 分开的颜色通道.                                cvCreateImage只能创建交叉存取图像 */          int  origin;        /* 0 - 顶—左结构,                                1 - 底—左结构 (Windows bitmaps 风格) */          int  align;         /* 图像行排列 (4 or 8). OpenCV 忽略它，使用 widthStep 代替 */          int  width;         /* 图像宽像素数 */          int  height;        /* 图像高像素数*/          struct _IplROI *roi;/* 图像感兴趣区域. 当该值非空只对该区域进行处理 */          struct _IplImage *maskROI; /* 在 OpenCV中必须置NULL */          void  *imageId;     /* 同上*/          struct _IplTileInfo *tileInfo; /*同上*/          int  imageSize;     /* 图像数据大小(在交叉存取格式下imageSize=image->height*image->widthStep），单位字节*/          char *imageData;  /* 指向排列的图像数据 */          int  widthStep;   /* 排列的图像行大小，以字节为单位 */          int  BorderMode[4]; /* 边际结束模式, 被OpenCV忽略 */          int  BorderConst[4]; /* 同上 */          char *imageDataOrigin; /* 指针指向一个不同的图像数据结构（不是必须排列的），是为了纠正图像内存分配准备的 */      }      IplImage;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以<code>cv_bridge</code>的功能就是下面这张图中所表述的</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/cv_bridge" alt="cv_bridge的作用"></p><p>更多关于<code>cv_bridge</code>的问题，参考<code>roswiki</code>：<a href="https://wiki.ros.org/cv_bridge">https://wiki.ros.org/cv_bridge</a></p><p>此外，需要注意的是，在<code>Melodic</code>下在<code>Python</code>中使用cv_bridge会报错无法加载一个so/dynamic啥啥啥，关于这个问题的解决，先挖个坑，以后再补。</p><h3 id="B-iai-kinect2中每个话题的含义和作用"><a href="#B-iai-kinect2中每个话题的含义和作用" class="headerlink" title="B. iai-kinect2中每个话题的含义和作用"></a>B. iai-kinect2中每个话题的含义和作用</h3><p>当我们以<code>launch</code>文件的形式运行<code>iai-kinect2</code>后，我们会看到很多的话题，这些话题其实分成三组：<code>hd</code>、<code>qhd</code>和<code>sd</code>。需要注意的是，每组话题下的<code>points</code>话题都只是只有通过<code>launch</code>文件运行才会看到的。</p><h4 id="HD话题"><a href="#HD话题" class="headerlink" title="HD话题"></a>HD话题</h4><p>HD话题其实指的是高分辨率的图像，由于<code>Kinect V2</code>相比<code>Kinect V1</code>，其图像极限分辨率1920x1080，因此HD话题中所有的图像都是极限分辨率1920x1080的图像</p><p>此外，HD话题下发布的color表示是RGB彩色图像、<code>color_rect</code>则是经过畸变处理（rectified）的图像，<code>compressed</code>的则是经过压缩的图像。depth则是深度图，<code>mono</code>则是单色灰度图。</p><pre class="line-numbers language-lang-text"><code class="language-lang-text">/kinect2/hd/camera_info/kinect2/hd/image_color/kinect2/hd/image_color/compressed/kinect2/hd/image_color_rect/kinect2/hd/image_color_rect/compressed/kinect2/hd/image_depth_rect/kinect2/hd/image_depth_rect/compressed/kinect2/hd/image_mono/kinect2/hd/image_mono/compressed/kinect2/hd/image_mono_rect/kinect2/hd/image_mono_rect/compressed/kinect2/hd/points<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="QHD话题"><a href="#QHD话题" class="headerlink" title="QHD话题"></a>QHD话题</h4><p>QHD话题的全称是Quater HD，即该话题是HD话题的1/4。原因在于HD话题下的图片实在是太大了，因此无论是数据的传输还是处理都很慢。所以QHD中的图像是对HD的图像进行降采样之后的图像，长宽各自降采样一半，所以是512x424的图片。因此图像处理起来速度很快</p><pre class="line-numbers language-lang-text"><code class="language-lang-text">/kinect2/qhd/camera_info/kinect2/qhd/image_color/kinect2/qhd/image_color/compressed/kinect2/qhd/image_color_rect/kinect2/qhd/image_color_rect/compressed/kinect2/qhd/image_depth_rect/kinect2/qhd/image_depth_rect/compressed/kinect2/qhd/image_mono/kinect2/qhd/image_mono/compressed/kinect2/qhd/image_mono_rect/kinect2/qhd/image_mono_rect/compressed/kinect2/qhd/points<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SD话题"><a href="#SD话题" class="headerlink" title="SD话题"></a>SD话题</h4><p>SD话题中的图像都是从相机获得的红外和深度图像，因此大小都是原本的大小：512x424，处理起来速度还是比较快的。</p><pre class="line-numbers language-lang-text"><code class="language-lang-text">/kinect2/sd/camera_info/kinect2/sd/image_color_rect/kinect2/sd/image_color_rect/compressed/kinect2/sd/image_depth/kinect2/sd/image_depth/compressed/kinect2/sd/image_depth_rect/kinect2/sd/image_depth_rect/compressed/kinect2/sd/image_ir/kinect2/sd/image_ir/compressed/kinect2/sd/image_ir_rect/kinect2/sd/image_ir_rect/compressed/kinect2/sd/points<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-launch启动节点时候指定参数"><a href="#C-launch启动节点时候指定参数" class="headerlink" title="C. launch启动节点时候指定参数"></a>C. launch启动节点时候指定参数</h3><p>由于iai-kinect2自成一套系统，因此我们没有必要也很难修改他的代码来完成我们需要的功能。为此<code>iai-kinect2</code>的<code>launch</code>文件支持在启动的时候指定参数，来实现不同的功能，具体所有的参数如下</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">roslaunch kinect2_bridge kinect2_bridge.launch [options:=value]base_name:=<string>    default: kinect2    info:    set base name for all topicssensor:=<string>    default:    info:    serial of the sensor to usefps_limit:=<double>    default: -1.0    info:    limit the frames per secondcalib_path:=<string>    default: /home/wiedemeyer/work/src/iai_kinect2/kinect2_bridge/data/    info:    path to the calibration filesuse_png:=<bool>    default: false    info:    Use PNG compression instead of TIFFjpeg_quality:=<int>    default: 90    info:    JPEG quality level from 0 to 100png_level:=<int>    default: 1    info:    PNG compression level from 0 to 9depth_method:=<string>    default: cuda    info:    Use specific depth processing: default, cpu, opengl, opencl, cuda, clkde, cudakdedepth_device:=<int>    default: -1    info:    openCL device to use for depth processingreg_method:=<string>    default: opencl    info:    Use specific depth registration: default, cpu, openclreg_device:=<int>    default: -1    info:    openCL device to use for depth registrationmax_depth:=<double>    default: 12.0    info:    max depth valuemin_depth:=<double>    default: 0.1    info:    min depth valuequeue_size:=<int>    default: 2    info:    queue size of publisherbilateral_filter:=<bool>    default: true    info:    enable bilateral filtering of depth imagesedge_aware_filter:=<bool>    default: true    info:    enable edge aware filtering of depth imagespublish_tf:=<bool>    default: false    info:    publish static tf transforms for camerabase_name_tf:=<string>    default: as base_name    info:    base name for the tf framesworker_threads:=<int>    default: 4    info:    number of threads used for processing the images<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-iai-kinect2使用示例"><a href="#3-iai-kinect2使用示例" class="headerlink" title="3. iai-kinect2使用示例"></a>3. iai-kinect2使用示例</h2><p>经过上面的介绍，我们对于如何使用iai-kinect2来获得深度图像和点云应该有了认识，下面我们就给出几个使用的例子。</p><p>其实使用的具体流程很简单，就是去订阅HD、QHD、SD话题中的消息，然后使用CV_Bridge转换成OpenCV的图像，然后再使用OpenCV进行视频图像的处理。</p><h3 id="A-图像显示"><a href="#A-图像显示" class="headerlink" title="A. 图像显示"></a>A. 图像显示</h3><p>下面的这个程序是通过接受命令行参数来实现显示的节点，利用这个程序可以显示每个话题下的图像。不过有一个小问题是我本来想做的是可以同一时间多个窗口显示多个图像，这样效果会好很多。但是由于我电脑性能的问题跑起来很卡，但是显示单独的话题倒是很不错</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">#! /home/jack/anaconda3/envs/ros/bin/python""" 命令行快捷查看iai-kinect2图像的节点 """"""@author: Jack Wang@copyright: Jack Wang@date: 2021-11-20"""from os import readimport sysimport argparsefrom typing import Listimport cv2import numpy as npfor path_idx in range(len(sys.path)):    if "2.7" in sys.path[path_idx]:        temp = sys.path.pop(path_idx)        breaksys.path.append(temp)import rospyfrom cv_bridge import CvBridgefrom sensor_msgs.msg import Image, CompressedImageclass iaiKinect2Viewer(object):    bridge = CvBridge()    def __init__(self, args) -> None:        super().__init__()        self.subcribers: List[rospy.Subscriber] = []        self.windows_idx = 0        assert len(args.topic) % len(args.quality) == 0, f"话题数不匹配"        group_num = len(args.topic) // len(args.quality)        for quality in args.quality:            for i in range(group_num):                temp_topic = args.topic.pop(0)                self.add_subscriber(quality, temp_topic)    def add_subscriber(self, quality: str, topic: str):        assert quality in ["sd", "qhd","hd"], f"无效的话题组"        print(quality, topic)        topic = topic.split("_")        prefix = "/kinect2"        if "color" in topic and "rect" in topic and "compressed" not in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_color_rect"]), data_class=Image, callback=self.show_images, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "color" in topic and "rect" in topic and "compressed" in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_color_rect","compressed"]), data_class=CompressedImage, callback=self.show_compressed_image, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "color" in topic and "rect" not in  topic and "compressed" not in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_color"]), data_class=Image, callback=self.show_images, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "color" in topic and "rect" not in  topic and "compressed" in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_color", "compressed"]), data_class=CompressedImage, callback=self.show_compressed_image, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "depth" in topic and "compressed" not in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_depth_rect"]), data_class=Image, callback=self.show_images, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "depth" in topic and "compressed" in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_depth_rect", "compressed"]), data_class=CompressedImage, callback=self.show_compressed_image, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "mono" in topic and "rect" in topic and "compressed" not in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_mono_rect"]), data_class=Image, callback=self.show_images, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "mono" in topic and "rect" in topic and "compressed" in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_mono_rect","compressed"]), data_class=CompressedImage, callback=self.show_compressed_image, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "mono" in topic and "rect" not in  topic and "compressed" not in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_mono"]), data_class=Image, callback=self.show_images, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "mono" in topic and "rect" not in  topic and "compressed" in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_mono", "compressed"]), data_class=CompressedImage, callback=self.show_compressed_image, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "ir" in topic and "rect" in topic and "compressed" not in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_ir_rect"]), data_class=Image, callback=self.show_images, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "ir" in topic and "rect" in topic and "compressed" in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_ir_rect","compressed"]), data_class=CompressedImage, callback=self.show_compressed_image, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "ir" in topic and "rect" not in  topic and "compressed" not in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_ir"]), data_class=Image, callback=self.show_images, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        elif "ir" in topic and "rect" not in  topic and "compressed" in topic:            self.subcribers.append(rospy.Subscriber(name="/".join([prefix, quality, "image_ir", "compressed"]), data_class=CompressedImage, callback=self.show_compressed_image, queue_size=10, callback_args=self.windows_idx))            self.windows_idx += 1        else:            assert False, f"无效的参数：qualitt={quality}, topic={topic}"    def show_images(self, img, window_idx):        cv_img = self.bridge.imgmsg_to_cv2(img_msg=img)        cv2.imshow(f"viewer_{window_idx}", cv_img)        if cv2.waitKey(1) == 27:            cv2.destroyAllWindows()            rospy.signal_shutdown(reason="pressed esc")    def show_compressed_image(self, img: CompressedImage, windows_idx):        cv_img = self.bridge.compressed_imgmsg_to_cv2(cmprs_img_msg=img)        cv2.imshow(f"viewer_{windows_idx}", cv_img)        if cv2.waitKey(1) == 27:            cv2.destroyAllWindows()            rospy.signal_shutdown(reason="pressed esc")def arg_parser() -> argparse.Namespace:    parser = argparse.ArgumentParser(description="本程序用于可视化显示iai-kinect2的不同话题中的图片，以对比他们的不同")    parser.add_argument("-q", "--quality", dest="quality", nargs="*", type=str, help="指定需要显示图像的话题组")    parser.add_argument("-t", "--topic", dest="topic", nargs="+", type=str, help="指定需要显示图像的话题")    return parser.parse_args()if __name__ == "__main__":    args = arg_parser()    print(args.quality, args.topic)    rospy.init_node(name="ini_kinect2_viewer")    viewer = iaiKinect2Viewer(args=args)    rospy.spin()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的话则在命令行中加上参数，<code>-q</code>表示图像的质量，即<code>qhd</code>、<code>sd</code>还是<code>hd</code>，<code>-t</code>表示显示的话题。写的时候是支持多个话题同时显示的，但是不知道哪里出问题了显示不出来</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 显示单个话题的图像：1/4 大小的灰度图(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ rosrun look_kenect2 look_images.py -q qhd -t mono<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211120152240529.png" alt="qhd中mono里的黑白图像"></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 显示单个话题的图像：1/4 大小的彩色图(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ rosrun look_kenect2 look_images.py -q qhd -t color<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211120152424998.png" alt="qhd中color里的彩色图像"></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 显示单个话题的图像：1/4 大小的深度图(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ rosrun look_kenect2 look_images.py -q qhd -t depth_compressed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要说明的是，qhd和hd中的深度图像如果不用compressed，即直接用的kinect采集到的的点的话，那么显示的非常卡，因为点云的数据实在是太大了，用而compressed中的数据则是iai-kinect2经过OpenCL、CUDA加速渲染之后得到的，因此帧率比较高。此外获取到的深度图每个像素都是一个以毫米为单位的距离值，因此使用OpenCV直接显示的话被做了归一化，所以越近的地方越黑，越远的地方越白，一些异常点，即没有反射的点距离被认为是摄像头获取距离的极限值（&gt;1200，即超过12米），因此这些异常点使得归一化之后基本都是黑的，我们自己使用的时候一定要先处理异常点然后再归一化，最后再显示</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211120153143101.png" alt="qhd里的深度图"></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 显示单个话题的图像：sd大小的红外图像(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ rosrun look_kenect2 look_images.py -q sd -t ir_rect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要说明的是，Kinect V2相机有一个红外发射器，一个红外接收器，因此距离越近，表面越光滑，接收器接收到反射的红外线越强，数值越高，对应就越白</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211120154330718.png" alt="sd里的红外图"></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 显示单个话题的图像：sd大小的色彩图^(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ rosrun look_kenect2 look_images.py -q sd -t color_rect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>理论上来说，sd话题里显示的都是红外相机拍摄得到的图片，因此不会存在颜色，所以这里其实是把RGB相机拍到的图片和红外相机图片配准之后的结果</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211120154705830.png" alt="sd里的color_rect"></p><h3 id="B-YOLO-V5进行物体检测"><a href="#B-YOLO-V5进行物体检测" class="headerlink" title="B. YOLO V5进行物体检测"></a>B. YOLO V5进行物体检测</h3><p>利用之前写好的YOLO V5，可以实现物体检测，然后根据深度图像来标注出物体的距离</p><p>YOLO V5的代码后面整理出来会放出来，这里先用一用，下面的代码需要注意的是rospy中的message_filter如果消息频率速度过快，甚至快过了message_filter处理的速度，那么就会导致两个消息无法对应起来，因此就永远不会调用回调函数，因此cv2.waitkey需要等10毫秒左右</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">#! /home/jack/anaconda3/envs/ros/bin/pythonimport sysimport timefrom pathlib import Pathimport cv2import numpy as npfrom colorama import Fore, Stylefrom libyolo import YoloV5stemp_path = Nonefor path_idx in range(len(sys.path)):    if "2.7" in sys.path[path_idx]:        temp_path = sys.path.pop(path_idx)        breakif temp_path is not None:    sys.path.append(temp_path)import rospyimport message_filtersfrom sensor_msgs.msg import CompressedImagefrom cv_bridge import CvBridgeclass DetectYoloKinect(object):    yolo = YoloV5s(weight_path=Path(__file__).resolve().parent.parent.joinpath("models", "yolov5s.pt"))    bridge = CvBridge()    font = cv2.FONT_HERSHEY_DUPLEX    def __init__(self, rgb_img_topic: str, depth_img_topic: str, if_detection_only: bool = False) -> None:        super().__init__()        rospy.loginfo(msg=f"{Fore.GREEN}启动物体检测节点！{Style.RESET_ALL}")        if if_detection_only:            rospy.Subscriber(name=rgb_img_topic, data_class=CompressedImage, callback=self._detect_only_cb,                             queue_size=10)        else:            rgb_subscriber = message_filters.Subscriber(rgb_img_topic, CompressedImage)            depth_subscriber = message_filters.Subscriber(depth_img_topic, CompressedImage)            sync = message_filters.ApproximateTimeSynchronizer(fs=[rgb_subscriber, depth_subscriber], queue_size=100,                                                               slop=1)            sync.registerCallback(self._multi_cb)        self.last_time_rgb = time.time()    def _detect_only_cb(self, img: CompressedImage):        cv_image: np.ndarray = self.bridge.compressed_imgmsg_to_cv2(cmprs_img_msg=img)        result_dict, draw_img = self.yolo.inference(cv_image, if_absolute=True, if_show=True)        t2 = time.time()        draw_img = cv2.putText(draw_img, f"fps: {1 / (t2 - self.last_time_rgb):>5.2f}, seq_id: {img.header.seq}",                               (10, 20), self.font, 0.8, (0, 255, 0), 2)        self.last_time_rgb = t2        cv2.imshow("color_detections", draw_img)        if cv2.waitKey(1) == 27:            cv2.destroyAllWindows()            rospy.logwarn("按下了ESC键，终止节点...")            rospy.signal_shutdown(reason="pressed esc")    def _multi_cb(self, rgb_img: CompressedImage, depth_img: CompressedImage):        rospy.loginfo("Getting into _multi_cb")        cv_rgb: np.ndarray = self.bridge.compressed_imgmsg_to_cv2(cmprs_img_msg=rgb_img)        cv_depth: np.ndarray = self.bridge.compressed_imgmsg_to_cv2(cmprs_img_msg=depth_img)        cv_depth_draw: np.ndarray = np.stack([cv_depth] * 3, axis=2)  # to BGR        cv_depth_draw = (cv_depth_draw - cv_depth_draw.min()) / (cv_depth_draw.max() - cv_depth_draw.min())        # inference        result_dict, cv_rgb_draw = self.yolo.inference(cv_rgb, if_absolute=True, if_show=True)        # log time        t = time.time()        fps = round(1 / (t - self.last_time_rgb), ndigits=2)        self.last_time_rgb = t        rospy.loginfo(msg="Done inference, start to draw")        # draw basic info        cv_rgb_draw = cv2.putText(cv_rgb_draw, f"FPS:{fps}, seq:{depth_img.header.seq}",                                  org=(10, 20), fontFace=self.font, fontScale=0.8, color=(0, 255, 0), thickness=2)        cv_depth_draw = cv2.putText(cv_depth_draw, f"FPS:{fps}, seq:{depth_img.header.seq}",                                    org=(10, 20), fontFace=self.font, fontScale=0.8, color=(0, 255, 0), thickness=2)        # draw depth        rospy.loginfo(msg="Done draw basic, start draw depth")        for d_type, items in result_dict.items():            for item in items:                # 周围100个点的平均，yolo的结果已经确保点在图像内                depth = self.__get_depth((x := item[0]), (y := item[1]), depth_image=cv_depth, area_size=20)                x, y = int(x), int(y)                cv_depth_draw = cv2.putText(cv_depth_draw, text=f"{d_type}, {depth / 10:>.2f}m", org=(x, y-5),                                            fontFace=self.font, fontScale=0.8, color=(0, 255, 0), lineType=2)                cv_depth_draw = cv2.circle(cv_depth_draw, center=(x, y), radius=5, color=(0, 0, 255),                                           thickness=2, lineType=2)        rospy.loginfo(msg=f"Done Drawing")        cv2.imshow("detection_result", cv_rgb_draw)        cv2.imshow("depth_result", cv_depth_draw)        if cv2.waitKey(10) == 27:            cv2.destroyAllWindows()            rospy.logwarn(msg=f"按下了ESC键，手动关闭了节点")            rospy.signal_shutdown(reason="pressed esc")    @staticmethod    def __get_depth(x: float, y: float, depth_image: np.ndarray, area_size: int = 20) -> float:        boundary = [int(position) for position in                    [y - area_size / 2, y + area_size / 2, x - area_size / 2, x + area_size / 2]]        return depth_image[boundary[0]:boundary[1], boundary[2]:boundary[3]].mean()if __name__ == "__main__":    rospy.init_node(name="detect_yolo_kinect2", anonymous=False)    dyk = DetectYoloKinect(rgb_img_topic="/kinect2/qhd/image_color/compressed",                           depth_img_topic="/kinect2/qhd/image_depth_rect/compressed", if_detection_only=False)    rospy.spin()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后得到的效果如下，可以看到YOLO还是可以的，不过有的时候会识别错误，例如把纸板识别成了沙发。而且在深度图中，越靠近边缘实际上越不准确，如果没有反射回来的话距离就被记为0。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211121155602208.png" alt="YOLO和深度图配准"></p>]]></content>
      
      
      <categories>
          
          <category> ROS杂篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> Kinect V2 </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> melodic </tag>
            
            <tag> OpenCv </tag>
            
            <tag> cv_bridge </tag>
            
            <tag> sensor_msgs </tag>
            
            <tag> iai-kinect2 </tag>
            
            <tag> roslaunch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS杂篇 ROS中使用Kinect V2 Part1：安装+使用</title>
      <link href="/2021/11/18/ros-za-pian-an-zhuang-kinect-v2-qu-dong/"/>
      <url>/2021/11/18/ros-za-pian-an-zhuang-kinect-v2-qu-dong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Kinect是非常流行的获取深度、彩色、点云的相机。本文介绍了Kinect相机的具体性能，以及如何在ROS调用Kinect相机。</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118214830894.png" alt="最终效果图"></p><span id="more"></span><h1 id="ROS杂篇-ROS中使用Kinect-V2-Part1：安装-使用"><a href="#ROS杂篇-ROS中使用Kinect-V2-Part1：安装-使用" class="headerlink" title="ROS杂篇 ROS中使用Kinect V2 Part1：安装+使用"></a>ROS杂篇 ROS中使用Kinect V2 Part1：安装+使用</h1><blockquote><p>前言：为什么要写这篇博客</p></blockquote><p>由于我目前的工作需要我编写服务机器人的代码，而服务机器人就免不了需要视觉信息来指导机器人完成服务。包括RGB彩色相机获得的彩色图像、深度相机获得的深度图像等等各种视觉传感器。对于简单的RGB相机拍摄到的RGB彩色图像，由于全球统一的接口，因此有很多工具都可以帮助我们从<code>/dev/video*</code>中读取到彩色图像。通过OpenCV的<code>VideoCapture</code>就可以读到。然而问题的关键在于，针对一些特定的设备，例如深度相机，目前全球尚无统一的标准，因此在数据流中图像的格式各个厂家都是不一样的。因此这个时候想要读取到这些特殊相机的图像就需要花一番功夫了。尤其是在硬件厂商不提供Linux的驱动的时候更难受。</p><p>由于我具体的开发平台配置就是 <code>Ubuntu 18.04</code> + <code>ROS Melodic</code> + <code>Kinect V2</code>相机。<strong>所以特地写这篇博客记录一下ROS中如何配置Kinect V2相机</strong></p><p><strong>下文针对Ubutnu 18.04 + ROS Melodic 验证可行</strong></p><h2 id="1-什么是-Kinect-相机？"><a href="#1-什么是-Kinect-相机？" class="headerlink" title="1. 什么是 Kinect 相机？"></a>1. 什么是 Kinect 相机？</h2><blockquote><p>正如我一向的态度，学什么、做什么前先问问为什么要学/做，再问问自己学/做的是什么。为什么要做上面已经回答了，因为我需要用它。那接下来就是要做的是什么？</p></blockquote><p>个人的角度来说，<code>Kinect</code> 相机就是一款特殊的相机，他可以读取到RGB彩色图像和深度图像，通过<code>Kinect</code>相机采集到的图像和深度信息，我们就能够快乐的进行开发~</p><p>虽然<code>Kinect V2</code>在2017年由于<code>Xbox</code>取消了<code>Kinect</code>的接口而停产，但是发现到<code>Kinect</code>相机价值的微软随后推出的 <code>Kinect V3</code> 和 <code>Kinect DK</code> 都是专门为科研推出的设备。（我有幸用过 <code>Kinect DK</code>，上面部署了现成的 <code>Human Motion Estimation</code> 的模型，可以直接获得人体的关键点，非常好用）</p><blockquote><p>摘自<code>维基百科</code></p><p><strong>Kinect</strong>是由<a href="https://zh.wikipedia.org/wiki/微軟">微软</a>开发，应用于<a href="https://zh.wikipedia.org/wiki/Xbox_360">Xbox 360</a>和<a href="https://zh.wikipedia.org/wiki/Xbox_One">Xbox One</a>主机的周边设备。它让玩家不需要手持或踩踏<a href="https://zh.wikipedia.org/wiki/控制器">控制器</a>，而是使用<a href="https://zh.wikipedia.org/wiki/语音指令">语音指令</a>或<a href="https://zh.wikipedia.org/wiki/手势">手势</a>来操作Xbox 360和Xbox One的系统界面。它也能捕捉玩家全身上下的动作，用身体来进行游戏，带给玩家“免控制器的游戏与娱乐体验”。此设备是<a href="https://zh.wikipedia.org/wiki/微軟研究院">微软研究院</a>的研究成果之一。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118142428272.png" alt="维基百科上对Kinect相机的介绍"></p></blockquote><p>可以看得出来，<code>Kinect</code>相机最初其实是由Windows为<code>Xbox</code>游戏机准备的外设，通过Kinect相机可以玩一些体感游戏。不过多好的设备当然是要我们来折腾的，拿来单纯玩游戏就有点太奢侈了。</p><p>不过正式用于Kinect相机是微软家的产品，按照微软的尿性大概是不会给开源驱动的（虽然这几年微软逐渐在拥抱开源，可是KinectV1、V2都是2010年的产品啊），事实也的确如此。Kinect目前微软官方的驱动只有在Windows上才有。这也就是为什么我们稍后等下需要安装<code>Kinect V2</code>的驱动。</p><h2 id="2-Kinect-相机介绍"><a href="#2-Kinect-相机介绍" class="headerlink" title="2. Kinect 相机介绍"></a>2. Kinect 相机介绍</h2><blockquote><p>以下内容参考博客：<a href="https://www.cnblogs.com/traceplus/p/4136297.html">https://www.cnblogs.com/traceplus/p/4136297.html</a></p></blockquote><h3 id="A-Kinect-V1"><a href="#A-Kinect-V1" class="headerlink" title="A. Kinect V1"></a>A. Kinect V1</h3><p>2012年美国微软发售的<code>Kinect V1</code>，因为可以很方便就能取得Depth（深度）和 skeleton（人物姿势）等信息，被全世界的开发者和研究人员关注。</p><p><code>Kinect V1</code>的Depth传感器，采用了<code>Light Coding</code>的方式，读取投射的红外线的<code>pattern</code>，通过<code>pattern</code>的变形来取得Depth的信息。为此，Depth传感器分为投射红外线的IR Projector（左）和读取的IR Camera（右）。此外还有<code>Kinect V1</code>中间还搭载了RGB相机。</p><p><code>Light Coding</code>是以色列的<code>PrimeSense</code>公司的Depth传感器技术，于2013年被美国苹果公司收购。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/012317367015237.jpg" alt="Kinect V1的图片"></p><h3 id="B-Kinect-V2"><a href="#B-Kinect-V2" class="headerlink" title="B. Kinect V2"></a>B. Kinect V2</h3><p><code>Kinect V2</code>获得Depth信息采用的则是<code>Time of Flight(TOF)</code>的方式，通过从投射的红外线反射后返回的时间来取得Depth信息。红外发射器和接收器在面板底部，因此看不到外观，不过<code>Color Camera</code>旁边是红外线<code>Camera</code>(左)和投射脉冲变调红外线的<code>Porjector</code>（右）。</p><p>微软过去收购过基于<code>TOF</code>方式的深度传感器技术的公司（注：应该是指的3DV），已经在使用这个技术，不过没有详细的公布。</p><p>（额外插一句，TOF是目前大多数点云数据获取的方式）</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/012317384052450.jpg" alt="Kinect V2"></p><h3 id="C-两者对比"><a href="#C-两者对比" class="headerlink" title="C.两者对比"></a>C.两者对比</h3><p><strong>首先是两者的参数</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118144936589.png" alt="Kinect V1 和 V2 性能对比"></p><p><strong>然后需要注意的是两者的接口</strong></p><ul><li>V1的要求是USB2.0理论传输速率是60MB/s，v2是USB3.0理论传输速率是500MB/s。</li><li>对于<code>Kinect V1</code>，对XRGB四通道图像，30fps的帧率下每秒所需传输的数据大小为640 x 480 x 4 x 30约为35M；再加上USHORT格式的深度图，30fps，每秒传输数据量为320 x 240 x 2 x 30约为4M。总计约为40MB/s，因为带宽有限，所以在保证画面帧率稳定的情况下，分辨率只能如此，而且基本上必须独占一个USB接口。</li><li>对于<code>Kinect V2</code>的情况，彩色图像1920 x 1080 x 4 x 30 约为237M，深度图像512 x 424 x 2 x 30约为12M，总计约为250M/s。所以非USB3.0不可，否则传输不了这么大的数据量。</li></ul><h2 id="3-安装Kinect驱动-ROS中间件"><a href="#3-安装Kinect驱动-ROS中间件" class="headerlink" title="3. 安装Kinect驱动+ROS中间件"></a>3. 安装Kinect驱动+ROS中间件</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A. 概述"></a>A. 概述</h3><p>首先需要说明的是开发的方式，因为Kinect相机是物理硬件，所以获取到的是二进制数据流，我们首先需要使用驱动将二进制数据流转换为有意义的图像，然后在我们自己的程序针在这些图像的基础上去进行开发。</p><ul><li><strong>将二进制数据流转换为图像的程序对应下图的Kinect Driver</strong></li><li><strong>我们自己的程序对应下图的<code>Application</code></strong></li><li><strong>需要注意的是，在ROS中通常只会有一个程序调用Kinect Driver，因此不考虑右边的工作模型。右边的模型只有多人、多任务同时要调用Kinect</strong> <strong>Driver时候才会有用，针对单任务其实没有啥影响</strong></li></ul><p>在<code>Kinect</code>标准的<code>Windows</code>上，<code>Kinect</code>的驱动是Windows上直接下载的，然后<code>Windows</code>还提供了<code>Kinect</code>的SDK，里面有现成的人体骨架识别的<code>API</code>，所以可以直接用。<strong>但是在Linux的ROS上想要使用Kinect相机的话，把二进制数据流转换为图像的驱动需要我们自己写，然后SDK+程序得自己开发</strong>。</p><ul><li>幸运的是，已经有人写好了<code>Kinect</code>的驱动，因此我们直接下载驱动即可。但是<code>Kinect</code>驱动只能帮助我们能在<code>Ubuntu</code>上获得Kinect的图像，所以接下来我们需要做的第二件事就是编写一个<code>ROS</code>调用<code>Kinect</code>的节点来调用<code>Kinect</code>驱动，并将获得的图像以话题的形式发布到<code>ROS</code>中去。</li><li>更加幸运的是，这一步也已经有人帮我们做好了，我们需要需要做的下载、编译这个调用Kinect驱动获得图像、并以<code>ROS</code>话题形式发布的<code>ROS</code>功能包（相当于中间件）。</li></ul><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/012317438589516.png" alt="开发方式"></p><p>因此，整个安装流程分成两步，</p><ol><li>安装 <code>Kinect</code> 的驱动</li><li>安装<code>ROS</code>功能包</li></ol><h3 id="B-安装Kinect-V2驱动——libfreenect2"><a href="#B-安装Kinect-V2驱动——libfreenect2" class="headerlink" title="B. 安装Kinect V2驱动——libfreenect2"></a>B. 安装Kinect V2驱动——libfreenect2</h3><p>首先需要安装<code>Kinect</code>在<code>Ubuntu</code>上的驱动：<code>libfreenect2</code>。</p><p>这个驱动是<code>Github</code>上开源的用<code>C++</code>和<code>Cmake</code>写的<code>Kinect V2</code>的驱动，所以我们稍后克隆下来之后安装一下依赖，然后配置<code>CMake</code>生成<code>Makefile</code>、然后make编译，最后make install安装库即可。</p><h4 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h4><p>实现用apt包管理器安装下稍后编译时候的依赖</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project$ sudo apt-get install build-essential cmake pkg-config libturbojpeg libjpeg-turbo8-dev mesa-common-dev freeglut3-dev libxrandr-dev libxi-dev libglfw3-dev libglfw3-dev libopenni2-dev libusb-dev libturbojpeg0-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于我已经安装过了，所以这一步我不会安装任何东西。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118172852901.png" alt="安装依赖"></p><h4 id="2-下载源码"><a href="#2-下载源码" class="headerlink" title="2. 下载源码"></a>2. 下载源码</h4><p><code>git</code>直接下载源码即可，如果下载的慢的话，要么科学上网，要么先用国内的码云gitee克隆一下，然后再下载码云的仓库。关于如何使用码云加速<code>github</code>下载可以参考我的这篇文章（挖个坑，以后补）</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project$ git clone https://github.com/OpenKinect/libfreenect2.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118173143020.png" alt="下载源码"></p><p>下载之后的项目文件结构，可以看出来，是一个非常经典的<code>CMake</code>的项目</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118173557080.png" alt="下载后的项目结构"></p><h4 id="3-配置-amp-编译"><a href="#3-配置-amp-编译" class="headerlink" title="3. 配置&amp;编译"></a>3. 配置&amp;编译</h4><p>对于一个<code>CMake</code>工程，得到项目最后的成果，即最终的动态链接库/共享库、可执行文件一共需要两步。第一步是配置（<code>Config</code>），第二步是构建（<code>Build</code>）。配置指的是设置项目的一些配置，比如说编译器使用的语法标准、是否禁止编译器在编译阶段优化代码等等。这里不展开讲了，具体内容可以参考我的<code>CMake</code>系列文章（挖个坑）。</p><p>首先创建一个编译空间</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project$ cd libfreenect2/(base) jack@jack-Alienware-m15-R3:~/project/libfreenect2$ mkdir build(base) jack@jack-Alienware-m15-R3:~/project/libfreenect2$ cd build/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来再使用<code>CMake</code>针对<code>build</code>文件夹外的<code>CMakeLists</code>进行配置，需要注意的是，由于我已经配好了<code>Nvidia</code>的显卡驱动和<code>CUDA</code>，因此我指定使用<code>CUDA</code>编译，这样运行的时候就会有加速。此外配置的时候要指定安装到的位置，这个安装到的位置稍后安装ROS功能包的时候会用到，所以不建议修改，用默认的就行。</p><p>具体来说我们都是在命令行使用-D参数来指定<code>CMake</code>的宏及其值(D=define)，<code>CMakeLists</code>中会检查这些宏的值。如果你不是<code>CUDA</code>的话就把后面指定<code>CUDA</code>的宏删掉即可</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/libfreenect2/build$ cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/freenect2 -DENABLE_CXX11=ON -DCUDA_PROPAGATE_HOST_FLAGS=off<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118184945046.png" alt="CMake配置工程"></p><p>可以看到<code>CMake</code>配置的流程还是很清晰的，首先会去寻找系统中的编译器版本然后再去检查当前编译器是否至此指定版本的语法，接下来去寻找包等等。全部配置过程没有问题的话就会显示最后的三句话，当前<code>build</code>编译空间下也多出来很多中间文件。<code>Makefile</code>就是稍后<code>make</code>解析的对象。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/libfreenect2/build$ ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118185449344.png" alt="配置的结果"></p><p>然后我们make编译即可</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/libfreenect2/build$ make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我这里的编译可以说是顺风顺水，主要原因其实是我已经配置过一遍了，这是写教程时候删掉了全部的文件重头再来的结果。<strong>其实在第一次配的时候在编译这里遇到了两三个问题</strong>，不过我都解决掉了，现在没有办法把这些问题复现出来。这里挖个坑，下一次装机补上。主要的两个问题是第一次会报错不存在一个叫<code>libGL.so</code>的共享库，第二次则是在最后编译到100%之后链接的时候报错说没有定义的引用：<code>undefined reference to _glapi_tls_Current</code>。</p><p>其实这两个问题都和<code>OpenGL</code>这个图形库有关（<code>Graphic Librar</code>y）。图形负责渲染材质等等，是将数据显示到我们的显示器上的库，包括看到的桌面、窗口等等都是用图形库渲染出来的。而<code>Kinect</code>捕获到的数据要转成图片显示，就必然会用到<code>OpenGL</code>这个库。第一个报错是因为管道断开（<code>libGL.so</code>是一个软连接），重新链接就行，第二个报错则是因为<code>libGL.so</code>链接到的共享库版本太老，指定一个更新的即可。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118185715177.png" alt="编译的过程"></p><p>最后，由于<code>libfreenect2</code>最终生成的是一个驱动，因此他最终生成的结果不仅有可执行文件，还有共享库，我们需要<code>make install</code>来安装一下共享库。说是安装，其实就是把共享库复制到指定的位置去，一般的项目都是把共享库复制到系统链接时候的搜索路径，这样编译的时候系统会自动的去搜索。<strong>不过由于我们上面CMake在配置的时候指定了安装位置，因此他其实会安装到我们的家目录下面</strong></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/libfreenect2/build$ make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从命令的输出确实能够看到安装的位置就是我们的家目录</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118190908729.png" alt="安装的结果"></p><h4 id="4-设置USB规则"><a href="#4-设置USB规则" class="headerlink" title="4. 设置USB规则"></a>4. 设置USB规则</h4><p>由于<code>libfreenect2</code>是一个驱动，因此他需要和底层的硬件做交互，所以需要设置一下<code>USB</code>规则。在<code>Linux</code>中所有的串口都是由一个叫<code>udev</code>的程序负责的，他相当于<code>Windows</code>的设备管理器。这里挖个坑，以后补上关于<code>udev</code>的内容。更多细节可以参考<a href="https://www.jianshu.com/p/dd6cecd7755a">这篇简书的博客</a></p><blockquote><p><strong>以下内容引用自简书博客</strong></p><p><strong>udev在linux的那个位置</strong></p><p>udev的守护进程在linux的位置在systemd中的位置如下所示，举个例子：如果向pc中插入一个usb设备，kernel在总线上发现这个设备，使用dirver初始化，在sysfs创建device目录等操作之后，将通知用户空间的udev，然后上层的显示层才能看到这个usb设备，并最终将它显示在desktop上：</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/330043-6ecf51d6a519b4fe.png" alt="Systemd守护进程所处的位置"></p></blockquote><p>我们直接把规则文件复制到<code>udev</code>的配置文件夹下即可</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo cp ../platform/linux/udev/90-kinect2.rules /etc/udev/rules.d/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-验证安装"><a href="#5-验证安装" class="headerlink" title="5. 验证安装"></a>5. 验证安装</h4><p>最后上面的步骤一步步做下来，应该是没有问题的，不过在编译驱动的时候我们观察到make最后在生成一个叫做<code>Protonect</code>的可执行文件。这个程序其实就是验证安装的程序。我们接上<code>Kinect</code>的连接线，然后运行这个程序，如果安装成功就能够看到下面的图片</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/libfreenect2/build$ ./bin/Protonect<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>四张图中左上角是深度图，左下角是RGB图像，右下角是点云的图像，右上角是带有RGB的点云的图像。需要注意的是，点云的图像是通过深度图推算出来的。深度图只有一个Depth通道，数值越大表示越远，看起来就越黑。而点云图是XYZ三个通道，分别表示点相对相机的的XYZ坐标。而右上角的点云则是RGBXYZ六个通道图片。右边看到，有<code>CUDA</code>加速喧嚷延迟基本都在10ms左右，速度还是非常快的</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118193300100.png" alt="验证程序的运行结果"></p><h4 id="6-安装驱动可能遇到的问题"><a href="#6-安装驱动可能遇到的问题" class="headerlink" title="6. 安装驱动可能遇到的问题"></a>6. 安装驱动可能遇到的问题</h4><p>暂时没有，留待下次重装系统时候补充。</p><h3 id="C-安装ROS-Kinect深度相机功能包——iai-kinect2"><a href="#C-安装ROS-Kinect深度相机功能包——iai-kinect2" class="headerlink" title="C. 安装ROS Kinect深度相机功能包——iai_kinect2"></a>C. 安装ROS Kinect深度相机功能包——iai_kinect2</h3><p>就像在<code>Melodic</code>上使用<code>CV_Bridge</code>一样（挖个<code>Melodic</code>编译<code>CV_Bridge</code>的坑，以后补上），<code>iai_kinect2</code>也需要我们从<code>github</code>上下载源码然后编译。</p><p>在编译之后，我们想要通过Kinect获得深度图像、点云图像等等直接启动这个<code>iai_kinect2</code>中的节点就行。这个节点将会调用libfreenect，并将获取到的图像发布到指定的话题里，因此我们订阅指定的话题即可得到数据。</p><h4 id="1-下载并编译功能包"><a href="#1-下载并编译功能包" class="headerlink" title="1. 下载并编译功能包"></a>1. 下载并编译功能包</h4><p>由于iai-<code>kinect2</code>本质上是<code>ROS</code>的一个功能包，而<code>ROS</code>的功能包的发布都是以功能包的形式发布的，因此我们只需要把这个功能包下载到工作空间中并进行编译即可。为了不污染我们自己的工作空间，避免每次都要编译这个包，我们新创建一个叫做<code>install_iai_kinect</code>的工作空间的安装这个包</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(ros) jack@jack-Alienware-m15-R3:~/project$ mkdir install_iai_kinect2(ros) jack@jack-Alienware-m15-R3:~/project$ cd install_iai_kinect2/(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ mkdir src(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ cd src/(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2/src$ catkin_init_workspace (ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2/src$ cd ..(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ catkin_make(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ ll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118205323865.png" alt="初始化之后的工作空间"></p><p>然后git下载功能并安装依赖，注意这里如果前面改了<code>libfreenect</code>的安装路径的话，这里编译的时候要添加一个<code>CMake</code>的宏来指定<code>libfreenect</code>的路径，参考<a href="https://github.com/code-iai/iai_kinect2#install">文章</a>。</p><p>此外，在使用<code>rosdep</code>安装的时候会遇到一个“报错”（见下），这个其实是正常的，因为<code>kinect2_brideg</code>、<code>kinect2_cailbration</code>、<code>kinect2_caliration</code>、<code>kinect2_viewer</code>这四个节点被<code>rosdep</code>认为是功能包了，但他们其实都只是<code>iai_kinect2</code>的一部分。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ cd src/(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2/src$ git clone https://github.com/code-iai/iai_kinect2.git(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2/src$ cd iai_kinect2(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2/src/iai_kinect2$ rosdep install -r --from-paths .(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2/src/iai_kinect2$ cd ../../(ros) jack@jack-Alienware-m15-R3:~/project/install_iai_kinect2$ catkin_make -DCMAKE_BUILD_TYPE="Release"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>ERROR: the following packages/stacks could not have their rosdepc keys resolved<br>to system dependencies:<br>kinect2_bridge: Cannot locate rosdep definition for [kinect2_registration]<br>kinect2_calibration: Cannot locate rosdep definition for [kinect2_bridge]<br>kinect2_viewer: Cannot locate rosdep definition for [kinect2_bridge]<br>iai_kinect2: Cannot locate rosdep definition for [kinect2_registration]</p></blockquote><p>最后没有error就成功安装功能包了，但是不要忘记<code>source</code>一下，因为这个功能包不在<code>ROS</code>的元功能包中。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118205948236.png" alt="编译的结果"></p><h4 id="2-验证安装"><a href="#2-验证安装" class="headerlink" title="2. 验证安装"></a>2. 验证安装</h4><p>同样，经历过上面的步骤之后，我们脸上<code>Kinect V2</code>的连接线来跑跑节点，看看有没有问题。类似于<code>cv_bridge</code>，<code>iai-kinect2</code>编译之后会得到一个<code>kinect_bridge</code>，我们利用其中的launch文件来测试一下。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(ros) jack@jack-Alienware-m15-R3:~/project/install_iai-kinect$ source devel/setup.bash (ros) jack@jack-Alienware-m15-R3:~/project/install_iai-kinect$ roslaunch kinect2_bridge kinect2_bridge.launch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118204334851.png" alt="launch启动整个kinect_bridge"></p><p>然后我们再开一个终端来看看节点图</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/install_iai-kinect$ rqt_graph<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看起来还不错，可以看到<code>kinect_bridge</code>其实只是一个交互的节点，他的后端数据处理都是依靠的其他的节点，<code>kinect2</code>负责调用<code>libfreenect</code>驱动，剩下的hd、sd、qhd分别负责处理高中低分辨率的图像。</p><p>不过由于rqt是通过rosmaster中的注册信息来画节点图的，因此没有被订阅的话题无法被显示出来，我们看看所有的话题</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118203224904.png" alt="Kinect_Bridge节点图"></p><p>新开一个终端</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~$ rostopic list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到有很多的话题，不过其实所有的话题分成三组，<code>hd</code>表示高分辨率，<code>qhd</code>表示中分辨率，<code>sd</code>表示低分辨率</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118203435667.png" alt="Kinect_Bridge发布的所有的画图"></p><p>最后其实<code>kinect_bridge</code>提供了可视化的节点，不过首先需要对kinect相机进行校准，否则是有偏差的，不过我们这里只是为了验证，因此跑起来看看</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">rosrun kinect2_viewer kinect2_viewer kinect2 sd cloud<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看起来效果还不错，不过由于订阅的是低分辨的图片，因此图片放大之后实际上像素间就会出现一些缺失的黑色点</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118203934128.png" alt="可视化的结果"></p><h4 id="3-安装时候的一些说明"><a href="#3-安装时候的一些说明" class="headerlink" title="3. 安装时候的一些说明"></a>3. 安装时候的一些说明</h4><blockquote><h4 id="1-编译的时候弹出来警告"><a href="#1-编译的时候弹出来警告" class="headerlink" title="1. 编译的时候弹出来警告"></a>1. 编译的时候弹出来警告</h4><p>具体的警告如下图。只是警告而已，不是错误，不用管。因为<code>catkin</code>作为<code>cmake</code>的上级编译系统，最后还是调用的<code>g++</code>，<code>g++</code>在编译的是帮我们检查代码，警告我们哪里语法不规范啥的，没必要管，能用就行。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118202235817.png" alt="编译时候的警告"></p></blockquote><h4 id="4-安装功能包可能会遇到的问题"><a href="#4-安装功能包可能会遇到的问题" class="headerlink" title="4. 安装功能包可能会遇到的问题"></a>4. 安装功能包可能会遇到的问题</h4><blockquote><h4 id="1-CMake-Error-at-usr-lib-x86-64-linux-gnu-cmake-Qt5Gui-Qt5GuiConfig-cmake-27-message-：Qt5的报错"><a href="#1-CMake-Error-at-usr-lib-x86-64-linux-gnu-cmake-Qt5Gui-Qt5GuiConfig-cmake-27-message-：Qt5的报错" class="headerlink" title="1. CMake Error at /usr/lib/x86_64-linux-gnu/cmake/Qt5Gui/Qt5GuiConfig.cmake:27 (message)：Qt5的报错"></a>1. <strong>CMake Error at /usr/lib/x86_64-linux-gnu/cmake/Qt5Gui/Qt5GuiConfig.cmake:27 (message)</strong>：Qt5的报错</h4><p>具体报错如下图，即缺少了<code>libEGL.so</code>这个共享库</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118200845339.png" alt="Qt5报错"></p><p><strong>解决方法：</strong></p><p>和上面安装驱动时候遇到的报错差不多，估计是一个尿性，即软连接断了，先去<code>/usr/lib/x86-linux-gnu</code>下看看。果然，红色的字体，断开的链接。即<code>/usr/lib/x86_64-linux-gnu/libEGL.so</code>这个软连接本来指向的文件没了。不过看这个样子有一个1.1.0版本的，估计是某次<code>apt upgrade</code>时候更新了这个库。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/install_iai-kinect$ ll /usr/lib/x86_64-linux-gnu/libEGL.so*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118201305342.png" alt="libEGL.so断开的软连接"></p><p>那么解决思路就很简单了，我们先删掉原有的断掉的链接，然后让他再指向新版本就行了，毕竟新版本一般都是向后兼容的。除了<code>Python2</code>到<code>Python3</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/install_iai-kinect$ sudo rm /usr/lib/x86_64-linux-gnu/libEGL.so (base) jack@jack-Alienware-m15-R3:~/project/install_iai-kinect$ sudo ln -s /usr/lib/x86_64-linux-gnu/libEGL.so.1.1.0 /usr/lib/x86_64-linux-gnu/libEGL.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在看着就没问题了，管道对了</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118201854870.png" alt="重置libEGL.so的指向"></p><p>然后再进行编译即可</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118202028422.png" alt="功能包可以正常编译"></p></blockquote><h2 id="4-使用kinect-bridge"><a href="#4-使用kinect-bridge" class="headerlink" title="4. 使用kinect_bridge"></a>4. 使用kinect_bridge</h2><p>使用<code>kinect_bridge</code>其实特别简单，就是订阅话题而已，为此我们快速写一个<code>Python</code>脚本测试，注意测试时候新建的功能包的依赖不要加<code>iai_kinect2</code>，因为<code>kinect_bridge</code>实现了低耦合性，所有的消息全部都是<code>ROS</code>中的标准消息类型，因此没有提供任何ROS编译之后可以引用的库。<strong>下面是是一个错误的示例</strong>。（挖个坑，以后出一个关于<code>Vscode</code>开发<code>ROS</code>的环境搭建，真的<code>VScode</code>越用越爽）</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118210715487.png" alt="功能包的依赖"></p><p>正因为<code>kinect_bridge</code>中的消息全部都是<code>ROS</code>的标准消息，所有的图像都是<code>sensor_msgs/Image</code>或者<code>sensor_msgs/CompressedImage</code>。而点云则是<code>sensor_msgs/PointCloud2</code>，我们可以非常快速的写一个测试代码，代码见下（<strong>注意如果你要写C++的话不要在iai_bridge的工作空间中编译，会报错，因为Kinect_Bridge没有提供ROS编译、安装相关的CMake指令</strong>）</p><p>关于<code>ROS</code>中使用<code>conda</code>、还有<code>cv_bridge</code>、<code>ROS</code>使用<code>Python</code>等问题先挖个坑，后面补上文章</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">#! /home/jack/anaconda3/envs/ros/bin/python"""rospy 中使用 通过 kinect 获取点云的示例代码 """"""@author: Jack Wang@copyright: Jack Wang@time: 2021-11-18"""import sysimport datetimeimport timeimport cv2from colorama import Fore, Style# 我在 Python3 下编译了cv_bridge，所以要避免import了下载ROS时候一并下载的系统的Python2.7的cv_bridgefor path_idx in range(len(sys.path)):    if "2.7" in sys.path[path_idx]:        temp = sys.path.pop(path_idx)        breaksys.path.append(temp)import rospyfrom sensor_msgs.msg import Imagefrom cv_bridge import CvBridgeclass MyKinectViewer(object):    bridge = CvBridge()    today: str = datetime.date.today().__str__()    start_sec: float = time.time()    font = cv2.FONT_HERSHEY_DUPLEX    def __init__(self) -> None:        super().__init__()        rospy.loginfo(msg=f"{Fore.GREEN}启动KinectBridge订阅节点！{Style.RESET_ALL}")        subcriber = rospy.Subscriber(name="/kinect2/sd/image_color_rect", data_class=Image, callback=self.image_cb, queue_size=20)    def image_cb(self, msg: Image) -> None:        cv_img = self.bridge.imgmsg_to_cv2(msg)        cv_img = cv2.putText(cv_img, f"{self.today}, start times: {time.time()-self.start_sec:>.2f}", (10, 380), self.font, 0.8, (0, 255, 0), 2,)        cv_img = cv2.putText(cv_img, f"-- by Jack Wang", (270, 400), self.font, 0.8, (0, 255, 0), 2,)        cv2.imshow("kinect_test", cv_img)        if cv2.waitKey(1) == 27:            rospy.loginfo(f"{Fore.GREEN}关闭节点{Style.RESET_ALL}")            rospy.signal_shutdown(reason="pressed esc")if __name__ == "__main__":    rospy.init_node(name="kinect_test", anonymous=False)    mkv = MyKinectViewer()    rospy.spin()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出来，效果还不错</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118214830894.png" alt="节点效果图"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118214855870.png" alt="按下ESC键退出节点"></p><p>结合我之前写的<code>YOLO V5</code>的<code>ROS</code>图像处理节点，最后可以实现的效果（<code>Yolo V5</code>的<code>ROS</code>节点代码后面会发出来）</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211118220436969.png" alt="image-20211118220436969"></p><p>至此，本文全部结束，我们首先介绍了什么是<code>Kinect</code>相机；然后就<code>Kinect</code>相机的参数、工作原理进行了介绍；接下来讲解了如何在<code>Linux(Ubuntu)</code>上安装<code>Kinect V2</code>相机的驱动：<code>libfreenect2</code>和安装<code>ROS</code>中的<code>Kinect</code>相机调用节点；在最后我们给出了一个简单的小例子，来演示如何使用<code>iai-kinect2</code>功能包得到的图像数据。</p><p>关于iai-kinect2的更多使用教程，请看下一篇文章：<code>ROS</code>中<code>iai-kinect2</code>功能包的使用。</p><p>6200字，码字不易~，欢迎打赏~，一起推动开源事业进步</p>]]></content>
      
      
      <categories>
          
          <category> ROS杂篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> Kinect V2 </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> melodic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo的个人技术博客搭建 —— Part-3 matery主题下的Hexo博客优化.md</title>
      <link href="/2021/11/14/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-3-matery-zhu-ti-xia-de-hexo-you-hua-md-md/"/>
      <url>/2021/11/14/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-3-matery-zhu-ti-xia-de-hexo-you-hua-md-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>hexo本身只是提供了一个博客的框架，博客网站的美化和优化还是需要靠自己配置主题。本讲将带领读者利用Matery主题对Hexo搭建的博客进行深度优化</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211207132452913.png" alt="最终效果展示图"></p><span id="more"></span><h1 id="基于Hexo的个人技术博客搭建-——-Part-3-matery主题下的Hexo博客优化"><a href="#基于Hexo的个人技术博客搭建-——-Part-3-matery主题下的Hexo博客优化" class="headerlink" title="基于Hexo的个人技术博客搭建 ——  Part 3 matery主题下的Hexo博客优化"></a>基于Hexo的个人技术博客搭建 ——  Part 3 matery主题下的Hexo博客优化</h1><p>在前面的一章中，我们已经通过<code>hexo</code>在本地搭建出了一个博客。但是目前，这个博客还存在一些问题</p><ol><li><strong>目前博客网站运行在本地，所以只有我们自己能看到</strong></li><li><strong>Hexo默认的博客不够美观、功能不够多</strong></li></ol><p>针对上面两个我们，本章和下一章就将进行解决。本章首先解决第二个问题，即优化Hexo博客。</p><h2 id="1-为什么使用其他的Hexo主题？"><a href="#1-为什么使用其他的Hexo主题？" class="headerlink" title="1. 为什么使用其他的Hexo主题？"></a>1. 为什么使用其他的Hexo主题？</h2><p>在前面一章中我们讲过，<code>Hexo</code>主题的工作原理其实就是<code>Hexo</code>的主题里面写的<code>JavaScript</code>和<code>CSS</code>覆盖掉了<code>hexo</code>的<code>JavaScript</code>和<code>CSS</code>。而CSS决定了<code>Hexo</code>博客的外观，因此是否美观实际上取决于主题里的<code>CSS</code>。同样JavaScript决定了网页和我们的交互，因此网页的功能如何实际上也取决与我们的主题。因此，一个优秀的主题是有一个完美的<code>Hexo</code>博客的先决条件。有了一个优秀的主题，我们的博客不仅更加美观，功能也会更加强大。</p><p>因此我们对<code>Hexo</code>博客进行优化，实际上就是使用其他主题，并对这些主题进行配置、</p><p>后面，就将以<code>Hexo</code>的<code>matery</code>主题为例，进行优化</p><h2 id="2-基于Matery主题的Hexo博客优化"><a href="#2-基于Matery主题的Hexo博客优化" class="headerlink" title="2. 基于Matery主题的Hexo博客优化"></a>2. 基于Matery主题的Hexo博客优化</h2><p><code>Matery</code>主题是由国内的闪烁之狐（blinkfox）制作的一款美观的主题，包括我在写这篇博客时候我的博客所用的主题就是<code>Matery</code>。</p><p>之所以使用<code>Matery</code>主题，美观只是一个方面，更重要的是<code>Matery</code>以插件的形式提供了非常多优秀的程序，通过这些程序使得我们能够极大地优化我们的网站。</p><p>访问闪烁之狐的<a href="http://blinkfox.com/">Hexo博客</a>和他的<code>Matery</code>主题的<a href="https://github.com/blinkfox/hexo-theme-matery">Github</a>查看更多的信息</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115010655463.png" alt="闪烁之狐的Matery主题示例"></p><p>接下来我们就将基于<code>Matery</code>主题来对我们的<code>Hexo</code>博客进行优化</p><blockquote><p>注意，下面的很多教程在<code>Matery</code>的<code>Github</code>上已经有介绍了，因此下面的介绍更多的是关注<code>Matery Github</code>上没有讲到的点</p></blockquote><h3 id="1-安装Matery"><a href="#1-安装Matery" class="headerlink" title="1. 安装Matery"></a>1. 安装Matery</h3><p><code>Matery</code>的<code>Github</code>中的中文说明已经讲过了，在<code>Hexo</code>博客文件夹下的<code>theme</code>文件夹<code>clone</code> 下<code>Matery</code>项目即可</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ cd themes/(base) jack@jack-Alienware-m15-R3:~/project/blog-test/themes$ git clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装完成之后，我们hexo博客看看效果</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test/themes$ cd ..(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>发现和之前的博客并没有任何变化</strong>，这是因为我们需要在<code>Hexo</code>的配置文件中指定使用<code>Matery</code>主题</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115011512753.png" alt="博客没有任何变化"></p><h3 id="2-切换Matery主题"><a href="#2-切换Matery主题" class="headerlink" title="2. 切换Matery主题"></a>2. 切换Matery主题</h3><p><code>vim</code>修改<code>hexo</code>博客根目录下的<code>_config.yml</code>，将<code>theme</code>的值改为 <code>hexo-theme-matery</code>，这样就启用了Matery主题</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115011735922.png" alt="修改之后的值"></p><p>接下来运行一下博客，就能够看到效果了</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，默认配置就已经非常漂亮了</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115011929561.png" alt="Matery主题的首页"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115012203467.png" alt="Matery主题的底部"></p><p>但是这个默认的主题也有一些小问题，需要我们去修改，比如说网站的左上角的logo，中间浮动打印的语句，中间的github链接需要修改成我们自己的，我的梦想栏的语句需要修改成自己的，右下角的联系方式需要改成我们自己的……</p><p>除了这些个人信息配置以外，还有最关键的一点就是右上角选项卡除了<code>首页</code>以外，其他的点击都会直接没有对应的界面显示。<strong>这是因为Matery默认没有这些界面，需要我们自己配置</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115012428235.png" alt="点击后显示错误"></p><h3 id="3-添加缺失的页面"><a href="#3-添加缺失的页面" class="headerlink" title="3. 添加缺失的页面"></a>3. 添加缺失的页面</h3><p>在前面的一章中，我们讲到<code>hexo</code>中一篇博客的源文件是一个<code>.md</code>文件，通过使用<code>hexo generta</code>命令，hexo自动的为我们的博文生成一个网页以及对应的资源文件。而其实在<code>hexo</code>，中一个页面对应的也是一个<code>.md</code>文件，同样我们稍后使用<code>hexo generta</code>来生成新的页面。只不过页面对应的<code>.md</code>文件会和博客的<code>.md</code>存在一些不同</p><p>下面就将以添加<code>关于</code>界面为例，讲解Hexo的页面工作原理的同时带领读者配置<code>Matery</code>的页面</p><h4 id="A-添加关于About页面"><a href="#A-添加关于About页面" class="headerlink" title="A. 添加关于About页面"></a>A. 添加<code>关于About</code>页面</h4><p>我们首先在根目录下使用<code>hexo new page xxx</code>命令来生成一个新的页面。同样为了后续的讲解，我们首先保存下现在的目录结构</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ touch before_about.txt(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ touch after_about.txt(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ tree >> before_about.txt (base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo new page "about"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们需要修改刚刚新生成的<code>.md</code>来说明这个是一个页面而非博客，这样稍后生成博客的时候就会生成出来一个新的页面</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ vim source/about/index.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>index.md</code>修改为如下内容，当然日期可以按照你自己的来</p><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">---title: aboutdate: 2021-11-15 01:37:51type: "about"layout: "about"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115014047478.png" alt="修改后的index.md"></p><p>接下来我们生成一下添加后的博客，别忘了生成之前<code>clean</code>一下，清除掉之前的博客。同时下面由于要讲解原理，因此生成后我们输出一下生成之后的目录结构</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo clean(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo gen(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ tree >> after_about.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后我们运行下博客看看效果</p><p>可以看到，此时点击<code>关于</code>就可以正常显示处页面了，底部则显示出我们的制作的项目</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115014533558.png" alt="正常显示的关于页面"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115014620968.png" alt="关于页面的底部"></p><p>当然，这些信息都是默认的信息，我们稍后是肯定需要修改成我们自己的。不过在这之前，先别着急，我们先了解一下<code>hexo</code>是怎么样新生成一个页面的</p><h4 id="B-Hexo是怎么样生成新的页面的？"><a href="#B-Hexo是怎么样生成新的页面的？" class="headerlink" title="B. Hexo是怎么样生成新的页面的？"></a>B. Hexo是怎么样生成新的页面的？</h4><p>我们利用上面两次输出的目录结构，来看看添加、生成页面之后博客目录结构的变化</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ vim -d before_about.txt after_about.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先是发布的博客的<code>public</code>文件夹下多了非常多的东西。除了我们之前添加的第一篇博客外，还多出了<code>about</code>、<code>css</code>、<code>js</code>等一些文件夹</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115015145727.png" alt="Public文件夹的变化"></p><p>此外，我们的源代码文件夹中也多了<code>about</code>文件夹和在其下面的<code>index.md</code></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115015222432.png" alt="source文件夹下的不同"></p><p>实际上到这里你应该能够猜出来了，<code>hexo</code>和<code>matery</code>生成新的页面的工作原理就是：</p><ul><li>首先<code>hexo</code>认为<code>source</code>文件夹下的一个文件夹就是一个页面，这个页面必须要有一个<code>index.md</code>来说明这个页面的信息，例如上面指定生成页面使用的模板</li><li>其次，<code>matery</code>在生成项目的时候，会在public下生成新的网站的配置文件来修改默认的页面。因此我们的确可以修改这个<code>public</code>下面的<code>matery</code>生成的资源文件。但是并不推荐这样做，因为所有的修改在后续<code>generate</code>之后就会丢失。与此相比，下面会介绍更好的修改、配置<code>matery</code>主题的方式</li></ul><p>最后，我们依照<code>Matery Github</code>（<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">链接</a>）中的<code>README</code>的指引，如法炮制添加剩下的所有页面。</p><p>完成了之后，你可以尽情的探索一下新得到的页面。</p><h3 id="4-配置Matery主题"><a href="#4-配置Matery主题" class="headerlink" title="4. 配置Matery主题"></a>4. 配置Matery主题</h3><p>上面我们通过简单的Matery主题的配置得到了一些界面，下面我们就将进一步配置Matery主题。</p><p>授人以鱼不如授人以渔，因此下面我会首先讲解Matery主题的配置是如何工作的而非单纯的罗列，在讲解完原理之后会留下我参考过的不错的链接，读者可以去里面根据自己的需求配置。</p><p>下面将以安装文章字数插件为例进行讲解。</p><h4 id="A-文章字数统计"><a href="#A-文章字数统计" class="headerlink" title="A. 文章字数统计"></a>A. 文章字数统计</h4><p>细心地读者已经发现，在我们上面的博客底部其实是没有文章字数统计的，而闪烁之狐的实例网页中却具有文章字数统计。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115021145362.png" alt="我们的界面"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115021216163.png" alt="闪烁之狐的网站"></p><p>实际上，这个功能是依靠第三方插件<code>+Matery</code>配置完成的。我们首先下载这个插件，不过注意，我们在前面安装了<code>cnpm</code>，因此使用<code>cnpm</code>安装即可</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ cnpm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成之后，我们还要修改<code>theme</code>文件夹下<code>Matery</code>主题的配置文件来激活插件，<strong>注意是Matey主题的配置文件</strong>。因为页面的样式信息都是Matery负责的。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ vim themes/hexo-theme-matery/_config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改为</p><pre class="line-numbers language-lang-yaml"><code class="language-lang-yaml">postInfo:  date: true  update: false  wordCount: true # 设置文章字数统计为 true.  totalCount: true # 设置站点文章总字数统计为 true.  min2read: true # 阅读时长.  readCount: true # 阅读次数.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115021824246.png" alt="修改后的_config.yml"></p><p>然后我们同样clean之后generate看看效果</p><p>可以看到，已经出现统计信息了</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115021949461.png" alt="底部具有了统计信息"></p><h4 id="B-Matery的配置是如何工作的？"><a href="#B-Matery的配置是如何工作的？" class="headerlink" title="B. Matery的配置是如何工作的？"></a>B. Matery的配置是如何工作的？</h4><p>事实上，<code>Matery</code>主题依靠其主题文件夹下的<code>_config.yml</code>来进行配置。这个文件中提供了诸如：网站上方选项卡的选项、个人信息、头像、logo等资源文件位置这类的配置，还有是否激活xx插件、xx效果等配置。因此我们通过<code>Matery</code>的<code>_config.yml</code>来进行配置。</p><p>在我们配置完了之后，在<code>generate</code>的过程中，<code>matery</code>就会根据我们的配置来生成对应的文件。可以说是非常方便。</p><p>例如我们修改在关于页面中显示的个人信息</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115023301903.png" alt="修改个人信息"></p><p>同样，我们修改之后clean、gen、server来看看效果</p><p>可以看到，相关信息已经被修改了，不过由于我没有改头像，因此头像没有变</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211115023432763.png" alt="修改后的效果"></p><p>此外，由于闪烁之狐大佬良好的代码风格，因此在<code>Matery</code>的配置文件夹下，几乎可以看到所有的配置以及修改方式~。大家可以多试试</p><p>此外，推荐一个我参考过的博客，他也是基于<code>Matery</code>进行了配置和优化，并且自己改了一些<code>JavaScript</code>，以实现更好的效果，<a href="https://m3df.xyz/2020/06/13/e9fff968/">零下三度的极寒的博客</a></p><p>最后，本章到了这里就结束了。在本章我们首先讲解了为什么要使用第三方的<code>Hexo</code>主题，以及为什么使用<code>Matery</code>主题。接下来我们结合两个案例讲解了如何对<code>Matery</code>主题进行配置并解释了<code>Matery</code>配置的工作原理，在明白工作原理之后，大家去修改自己的博客网站就会得心应手很多。最后我们提供了其他的参考链接来帮助大家配置自己的博客网站。</p><p>在下一章中，我们将讲解如何低成本的把自己的博客部署到公网上去，使得所有人都能够访问你的博客。</p><p>码字不易，3100字，欢迎打赏~，一起推动开源事业~</p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的个人技术博客搭建 —— Part 2 Hexo快速建站以网站基础信息配置</title>
      <link href="/2021/11/13/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-2-hexo-shi-yong-he-ji-chu-pei-zhi-md/"/>
      <url>/2021/11/13/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-2-hexo-shi-yong-he-ji-chu-pei-zhi-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要讲解如何使用Hexo快速搭建出一个博客网站，接下来对<code>Hexo</code>搭建的博客网站进行介绍，最后对Hexo搭建的博客网站进行网站基础信息的设置。</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113193858319.png" alt="快速建站最终实现的效果"></p><span id="more"></span><h1 id="基于Hexo的个人技术博客搭建-——-Part-2-Hexo快速建站以网站基础信息配置"><a href="#基于Hexo的个人技术博客搭建-——-Part-2-Hexo快速建站以网站基础信息配置" class="headerlink" title="基于Hexo的个人技术博客搭建 —— Part 2 Hexo快速建站以网站基础信息配置"></a>基于Hexo的个人技术博客搭建 —— Part 2 Hexo快速建站以网站基础信息配置</h1><p>在前面的章节中，我们已经讲解了配置<code>Hexo</code>的开发环境，本节将讲解如何使用Hexo快速建立自己的个人博客以及对个人博客进行基本信息设置</p><h2 id="1-Hexo快速建站"><a href="#1-Hexo快速建站" class="headerlink" title="1. Hexo快速建站"></a>1. Hexo快速建站</h2><blockquote><p>前面说过，<code>Hexo</code>搭建得到的博客本质上就是一个文件夹，因此<code>Hexo</code>进行的各种操作都是对这个文件夹里的文件进行操作。</p></blockquote><h3 id="1-初始化博客-——-hexo-init"><a href="#1-初始化博客-——-hexo-init" class="headerlink" title="1. 初始化博客 ——  hexo init"></a>1. 初始化博客 ——  <code>hexo init</code></h3><p><code>Hexo</code>提供了init命令来初始化一个博客，为此我们首先新建一个目录用来存放博客的所有文件</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project$ mkdir blog-test(base) jack@jack-Alienware-m15-R3:~/project$ hexo init blog-test/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>hexo init</code>本质上就是去<code>github</code>上克隆<code>hexo starter</code>项目</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113194931504.png" alt="hexo init初始化博客的过程"></p><h3 id="2-运行博客-——-hexo-server"><a href="#2-运行博客-——-hexo-server" class="headerlink" title="2. 运行博客 —— hexo server"></a>2. 运行博客 —— <code>hexo server</code></h3><p>接下来，在博客所在的文件夹的根目录下运行<code>hexo server</code>，来启动<code>hexo</code>的服务程序，这样就可以显示出我们的博客网站。<code>hexo</code>默认是带有一个欢迎界面的，因此即便我们什么都不做也可以正常的运行</p><pre><code>(base) jack@jack-Alienware-m15-R3:~/project$ cd blog-test/(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo server</code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113195611688.png" alt="image-20211113195611688"></p><p>运行之后浏览器中访问该端口就能够看到默认的界面，不过默认的界面的问题还是比较多的，比如网站用的默认主题并不是非常好看、网站的信息都不是，后面我们会慢慢优化。这里看到的效果如下</p><p>可以看到左下角的版权信息是默认的人名，左上角的选项卡选项也很少，右侧的菜单栏消息也很少，下一步我们就将慢慢改掉默认的界面</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113205754034.png" alt="朴素的Hexo"></p><p>为了等下讲解<code>Hexo</code>的原理，我们这里先创建三个文件</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ touch before_gen.txt(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ touch after_gen.txt(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ touch added_gen.txt(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ tree >> before_gen.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-生成博客-——-hexo-clean-amp-hexo-generate"><a href="#3-生成博客-——-hexo-clean-amp-hexo-generate" class="headerlink" title="3. 生成博客 —— hexo clean &amp; hexo generate"></a>3. 生成博客 —— <code>hexo clean</code> &amp; <code>hexo generate</code></h3><p>前面说道，<code>Hexo</code>的工作原理是通过<code>Markdown</code>引擎将<code>Markdown</code>格式的文本渲染成<code>HTML</code>，因此每一次我们在写完文章之后都需要生成一下博文，注意<code>hexo</code>提供了简写命令，因此g、gen、generate都是可以的</p><pre><code>(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo gen</code></pre><p>可以看到生成了不少文件内容</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113215116668.png" alt="hexo gen生成博文"></p><p>最后输出一下目录方便后面查看hexo的运行原理</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ tree >> after_gen.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-新加一篇博客-——-hexo-new"><a href="#4-新加一篇博客-——-hexo-new" class="headerlink" title="4. 新加一篇博客 —— hexo new"></a>4. 新加一篇博客 —— <code>hexo new</code></h3><p>我们自己添加博客，需要使用<code>hexo new 文章名</code>，如果文章名称中含有特殊字符，需要用<code>''</code>包裹起来</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo new 第一篇博文<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新添加的博客在<code>source/_posts/</code>下，使用编辑器打开即可，后面会写一个<code>Typora + 腾讯云床</code>的博客编写环境教程，挖个坑</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ echo "# 大标题" >> source/_posts/第一篇博文.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来继续生成博客，然后我们启动server来看看我们新写的博文，server的简写是s</p><p>注意，在生成前需要用clean清除一下中间的文件</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo clean(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ hexo gen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113220005285.png" alt="新添加一篇博文"></p><p>可以看到多了一篇文章</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113220330894.png" alt="添加文章之后的结果"></p><p>同样，我们记录一下，方便后面讲解原理</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ tree >> added_gen.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上就是关于<code>Hexo</code>的一些基础命令使用</p><h2 id="2-Hexo的运行原理"><a href="#2-Hexo的运行原理" class="headerlink" title="2. Hexo的运行原理"></a>2. Hexo的运行原理</h2><h3 id="1-Hexo的目录结构"><a href="#1-Hexo的目录结构" class="headerlink" title="1. Hexo的目录结构"></a>1. Hexo的目录结构</h3><p>我们通过<code>tree</code>命令来查看</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ tree -L 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，每个文件/文件夹的作用为：</p><ul><li><code>_config.yml</code>：网站的<strong>基础配置</strong>信息，可以在这里配置网站的一些基本参数，例如作者等等。<strong>之所以是基础配置信息，是因为使用不同的主题将会在极大程度上修改、覆盖这里的配置信息</strong>。</li><li><code>package.json</code>：Hexo生成网页、运行服务器等的应用程序信息。<code>EJS</code>, <code>Stylus</code> 和 <code>Markdown renderer</code> 已默认安装，可以由我们自由移除。</li><li><code>scaffolds</code>：模版文件夹。当您生成、新建文章时，<code>Hexo</code> 会根据 <code>scaffold</code> 来建立文件。<strong>不建议修改</strong></li><li><code>source</code>：资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。<code>Markdown</code> 和 <code>HTML</code> 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</li><li><code>themes</code>：主题文件夹。<code>Hexo</code> 会根据主题来生成静态页面。</li></ul><p>这些文件、文件夹中对我们而言最重要的就是<code>_config.yml</code>、<code>themes</code>、<code>source</code>这三个，其他的其实一般我们用不到也不需要改</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211114095916621.png" alt="Hexo博客的架构"></p><h3 id="2-Hexo是如何生成和发布的博文"><a href="#2-Hexo是如何生成和发布的博文" class="headerlink" title="2. Hexo是如何生成和发布的博文"></a>2. Hexo是如何生成和发布的博文</h3><p>上面从整体上介绍了<code>Hexo</code>的目录结构。下面我们将深入了解一下<code>Hexo</code>生成博文的原理。</p><p>我们上面使用tree生成了三次目录结构，接下来我们查看下生成博文和添加博文之后博客项目的变化，使用<code>vim -d</code>比较下三个文件的内容</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ vim -d before_gen.txt after_gen.txt added_gen.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，我们编写的博客都被添加到了<code>source/_posts</code>文件夹下，而我们运行<code>hexo generate</code>后生成的静态博文网页资源就都放在<code>public</code>文件夹下，具体来说，文章放在以日期为名的系列文件夹下，<code>CSS</code>等资源文件则是单独放置</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113223040926.png" alt="hexo new、add之后文件目录的变化"></p><h3 id="3-Hexo是如何管理主题的"><a href="#3-Hexo是如何管理主题的" class="headerlink" title="3. Hexo是如何管理主题的"></a>3. Hexo是如何管理主题的</h3><p>下面我们通过我当前的这个博客来了解下<code>Hexo</code>是如何管理主题的，以及主题是如何工作的</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/hexo-blogs$ tree themes/  -L 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，<code>theme</code>文件夹下，一个文件夹就是一个主题。一个主题内部又有其自身的结构，不同的目录有不同的作用。例如<code>language</code>负责不同语言的博文的设置，<code>source</code>则存放主题的<code>css</code>、<code>js</code>等资源文件，<code>_config.yml</code>则负责主题的配置。</p><p><strong>因此在后续我们美化、深度定制Hexo时候就是修改下载好的主题</strong></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211114021748798.png" alt="Hexo的主题目录"></p><h2 id="3-Hexo-基础信息配置"><a href="#3-Hexo-基础信息配置" class="headerlink" title="3. Hexo 基础信息配置"></a>3. Hexo 基础信息配置</h2><p>前面我们讲到，<code>Hexo</code>自身的<code>_config.yml</code>虽然负责整个项目的配置，但是通常会被我们自己下载的主题的<code>_config.yml</code>所覆盖，因此我们只在Hexo的<code>_config.yml</code>中进行一些基础信息的配置，以便于我们为我们的博客打上自己的信息。</p><p>首先通过<code>vim</code>或者其他编辑器打开根目录下的<code>_config.yml</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/project/blog-test$ vim _config.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211114022512202.png" alt="Hexo 根目录下的配置文件"></p><h3 id="1-个人信息设置"><a href="#1-个人信息设置" class="headerlink" title="1. 个人信息设置"></a>1. 个人信息设置</h3><p>我们只需要修改 <code># Site</code>中的信息即可，这样将网站的默认信息改为我们自己的信息</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211114023546668.png" alt="修改后的个人信息"></p><h3 id="2-URL修改"><a href="#2-URL修改" class="headerlink" title="2. URL修改"></a>2. URL修改</h3><p>注意，<code># URL</code>下的内容修改则在未来将会在别人从我们的网站中复制内容之后作为后续的内容提醒版权，此外也会在文章底部说明版权。</p><p>我们暂时先不做这个修改，等后续博客上线、具有具体的域名/网址后再进行修改。</p><p>进行完上面所有的配置之后，我们就可以查看最终的效果了，我们开启下server查看效果</p><p>可以看到首页的文字和页脚的信息已经改掉了，当然，每篇文章里作者的信息也已经改变了。</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211114023717905.png" alt="修改后的首页"></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211114023757242.png" alt="修改后的页脚信息"></p><p>至此，本章就已经结束了。本章我们首先讲解了<code>Hexo</code>的基础命令，然后研究了<code>Hexo</code>的目录结构和工作原理，方便我们后续修改，最后我们对网站的基础信息做了修改，更多的网站内容和信息的设置详见下一章~</p><p>码字不易，2200多字，欢迎打赏~，一起推动开源事业进步~</p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的个人技术博客搭建-Part 1 Hexo介绍以及环境搭建</title>
      <link href="/2021/11/13/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-1-hexo-jie-shao-yi-ji-huan-jing-da-jian-md/"/>
      <url>/2021/11/13/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-1-hexo-jie-shao-yi-ji-huan-jing-da-jian-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍什么是Hexo，为什么我们要使用Hexo搭建我们的博客以及Hexo环境搭建</p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113024418805.png" alt="Hexo官网"></p><span id="more"></span><h1 id="基于Hexo的个人技术博客搭建-Part-1-Hexo介绍以及环境搭建-md"><a href="#基于Hexo的个人技术博客搭建-Part-1-Hexo介绍以及环境搭建-md" class="headerlink" title="基于Hexo的个人技术博客搭建-Part 1 Hexo介绍以及环境搭建.md"></a>基于Hexo的个人技术博客搭建-Part 1 Hexo介绍以及环境搭建.md</h1><p>在前一章概述中，我们讲解了为什么我认为一个Geek需要一个个人技术博客，并且简单的展示了最终效果，在接下来的章节里，我将一步步的介绍如何打造这样的效果。</p><h2 id="1-What-is-Hexo"><a href="#1-What-is-Hexo" class="headerlink" title="1. What is Hexo"></a>1. What is Hexo</h2><blockquote><p>等等，什么是<code>Hexo</code>？</p></blockquote><p>在开始学习前，我们需要<strong>首先</strong>知道我们将要学的东西是什么以及学习它能带来的好处（为什么要学他），这样我们学起来会轻松很多。因为这样做我们首先对需要学的东西搭建了一个大的框架，后续的学习都是在填充它，不断丰满这个框架，并且也有了充足的动力去学习。</p><ul><li>正如<code>Hexo</code>官网上所说：<strong>Hexo是一个快速、简洁且高效的博客框架</strong>。（<del>虽然这个官网充满了不少广告</del>）</li></ul><p>所谓框架，即指已经为我们构建了基本的博客工具和博客结构（框架），我们后续只需要在这个框架上不断的填充（发布自己的文章）、修改（修改<code>Hexo</code>的代码）。因为<code>Hexo</code>开源，因此我们实际上可以针对<code>Hexo</code>进行任意程度的自定义修改，只有你想不到，没有你改不了。非常庆幸的是，<code>Hexo</code>的作者是台湾人，因此他的官方文档的中文支持是非常好的，这也为我们使用<code>Hexo</code>提供了便利。</p><ol><li><code>Hexo</code>是基于<code>Node.js</code>开发的应用（因此我们稍后在安装的时候会安装<code>Node.js</code>的环境）。借助于<code>Node.js</code>，<code>Hexo</code>可以快速的渲染出漂亮的文章</li></ol><blockquote><p><strong>什么是<code>Node.js</code></strong></p><p>说清这个问题，要说的可不少。接触过网络的人都应该知道，前端页面是由<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>三大技术/三件套支持的，其中<code>HTML</code>负责定义网页改在哪个地方显示什么内容，<code>CSS</code>定义哪个地方的哪个内容该以什么样的方式显示，<code>JavaScript</code>则定义当你与这个内容交互的时候会有什么样的效果。</p><p>举个简单例子，在<a href="https://www.baidu.com/">百度</a>的首页，</p><ol><li>为什么百度的Logo会显示在中间，而备案等网站信息显示在底部？—&gt; <code>HTML</code></li><li>为什么百度的背景是白色的，而不是黑色？  —&gt; <code>CSS</code></li><li>为什么鼠标悬停在左上角的更多的时候会弹出来浮窗？  —&gt; <code>JavaScript</code></li></ol><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113031023828.png" alt="百度的首页"></p><p>正是因为有了这三件套，我们的网页变得多姿多彩了起来，有有价值的信息(<code>HTML</code>)、漂亮的页面(<code>CSS</code>)和友好的交互(<code>JavaScript</code>)。</p><p>然而，渐渐地，<strong>本来地位平等的三件套逐渐开始出现区别</strong>。<code>HTML</code>和<code>CSS</code>都是静态的，在编写结束之后用户能看到的内容就已经固定（关于模板稍后再说），当用户访问这个网页，看到的就是其中的内容；然而<code>JavaScript</code>却由于需要处理的用户的操作不同而做不同的处理，例如在百度的页面中，如果我不是悬浮而是右击怎么办？如果我不是悬浮而是掠过怎么办？正是由于需要处理诸多用户导致的多种多样的Event，<code>JavaScript</code>也具有了if-else等编程语言常见的语句。<strong>渐渐地，随着技术的进步，JavaScript需要处理的问题越来越多，在其能力变强的同时，JavaScript也变得越来越像一门编程语言</strong>。</p><p>然而，这个时候的<code>JavaScript</code>还并不能独当一面。因为在最早的网页中，<code>JavaScript</code>、<code>HTML</code>、<code>CSS</code>是绑定的三件套，当用户访问某个网页，服务器会将该网页的三件套发送给用户，然后由<strong>用户的浏览器解析、渲染、执行HTML、CSS、JavaScript三件套</strong>，从而显示网页。因此这个时候的<code>JavaScript</code>是无法脱离浏览器的。我们从另一个角度考虑，由于JavaScript是由浏览器解析执行的，因此其可以看做是一门解释性语言，在执行<code>JavaScript</code>的时候，CPU执行的机器码来自于其<code>解释器</code>——浏览器。</p><p>后来随着，<code>JavaScript</code>的功能越来越强大，简单的在网页中进行交互已经完全发挥其能力了。因此就出现了诸多项目，这些项目独立于传统浏览器，基于浏览器的<code>JavaScript</code>解析器内核（学名：引擎）亦或是自己编写了<code>JavaScript</code>的解析器来执行<code>JavaScript</code>。至此，<code>JavaScript</code>已经能够独立于浏览器被单独执行了，而非必须在浏览器中以网页的形式打开。</p><p>在前面介绍了那么多之后，终于，到了我们的主角，<code>Node.js</code>。大名鼎鼎的<code>Node.js</code>其实就是基于<code>Chrome V8</code> 引擎的 <code>JavaScript</code> 运行时环境。简单的来说，它能够利用<code>Chrome V8</code>引擎来解析、执行<code>JavaScript</code>。<code>Node.js</code>可以粗暴的理解成<code>JavaScript</code>的解释器。基于此，<code>JavaScript</code>在很多方面都很像<code>Python</code>，包括包管理器、解释器等等</p></blockquote><ol><li><code>Hexo</code>利用<code>Markdown</code>来作为源文章，其内置<code>Markdown</code>的渲染引擎，我们只需要书写Markdown，而后通过<code>Hexo</code>就能够生成<code>HTML</code>等前端文件，非常方便</li></ol><blockquote><p>正如下面这张图，这篇文章也是我用Markdown写出来的，在后续部分除了网站搭建以外，还会讲讲如何搭建写作环境，以实现畅快写作</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113110048831.png" alt="我的Markdown写作环境：Typora+腾讯云图床+Dracula主题"></p></blockquote><ol><li>Hexo搭建出的博客网站是一个静态网站，这就意味着单纯<code>Hexo</code>本身只能提供博客的显示、有限的交互，如果需要登录、发表评论这类需要后端程序支持的运用，就需要第三方插件了。如果非常需要这些功能，要么使用<code>WordPress</code>，要么折腾<code>Hexo</code>的插件</li></ol><p>到这里，你应该明白了<code>Hexo</code>是一个基于<code>Node.js</code>的程序，他帮助我们渲染文章、管理文章，通过这个<code>Hexo</code>我们可以快速、低成本的部署自己的博客</p><h2 id="2-Why-is-Hexo"><a href="#2-Why-is-Hexo" class="headerlink" title="2. Why is Hexo"></a>2. Why is Hexo</h2><blockquote><p>Ok，我知道了什么<code>Hexo</code>，可是为什么要用它它？</p></blockquote><p>事实上，选取<code>Hexo</code>作为我们的博客网站框架来帮助我们搭建技术博客有很多好处：</p><ol><li><code>Hexo</code>框架的学习成本非常低，学起来非常快速，命令行几条语句就能够学会。在整个<code>博客搭建过程</code>中，学习<code>Hexo</code>可能只占很少的时间，主要时间在于挑选一个好看的主题并自己修改、添加自己的个人信息</li><li><code>Hexo</code>搭建的博客非常易于管理。<code>Hexo</code>管理的博客本质上是一个文件夹。因为Hexo搭建出的只是静态博客网站，因此不需要后端程序，所以网站所有的资源（<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>）都放在一个文件夹里就行。如果中间配置出问题了，那么直接删掉整个文件夹就行。</li><li><code>Hexo</code>搭建的博客部署、迁移非常方便。同样是由于Hexo管理的博客网站是一个文件夹，因此我们可利用Git<code>来保存</code>、同步你的博客。此外，由于<code>Github</code>和<code>Gitee</code>提供静态网页的<code>Page</code>服务，所以我们其实可以利用<code>Github</code>和<code>Gitee</code>等<code>Git</code>托管网站来托管我们的网站。防止网络攻击这些都由他们帮我们做好了。</li><li><code>Hexo</code>搭建的博客成本非常低。正是因为我们利用<code>Github</code>和<code>Gitee</code>来托管我们的网站，因此我们只需要花钱买域名和图床即可，买公网服务器什么的全部省掉了。</li><li><code>Hexo</code>具有非常多美观的主题。通过这些主题，我们只需要进行配置和有限的修改就能够做出来非常美观的博客网站。</li></ol><blockquote><p><code>Hexo</code>的官网上提供了非常多的主题（<a href="https://hexo.io/themes/">点击查看</a>），截止我写这篇文章的时候一共有348个官方收录的主题。除此以外还有非常多的未被收录的主题，强推我现在正在用的由<code>闪烁之狐</code>制作的<code>Matery</code>主题，后面也会讲解如何配置<code>Matery</code>主题，这是Matery主题的<a href="http://blinkfox.com/">展示网站</a></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113112326777.png" alt="Hexo官网收录的主题"></p></blockquote><ol><li>……（暂时只想到这几个点）</li></ol><h2 id="3-Hexo环境搭建"><a href="#3-Hexo环境搭建" class="headerlink" title="3. Hexo环境搭建"></a>3. Hexo环境搭建</h2><blockquote><p>开发第一步：搭建环境</p></blockquote><p>注意，由于我本人长期使用<code>Debian/Ubuntu</code>来做开发，因此以下教程都将是基于<code>Ubuntu</code>编写的教程。如果你是其他<code>Linux</code>发行版用户，适度修改即可；如果你是<code>Windows</code>用户，那么你还需要配置不少东西，知乎、简书上你还得查查。</p><p>下面我们就将一步步搭建Hexo环境出来</p><h3 id="1-安装Node-js环境"><a href="#1-安装Node-js环境" class="headerlink" title="1. 安装Node.js环境"></a>1. 安装Node.js环境</h3><p>前面说道，<code>Hexo</code>是基于<code>Node.js</code>开发的程序，因此其运行就需要<code>Node.js</code>，所以我们第一步就是安装<code>Node.js</code></p><blockquote><p>注意：官网上说明，<code>Hexo</code>需要的<code>Node.js</code>的版本不低于<strong>10.13</strong>，强烈建议<code>Node.js</code><strong>12.0</strong>以上的版本</p></blockquote><p>我们首先用<code>apt</code>查一下Ubuntu的仓库里的nodejs的版本</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~$ sudo apt search nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113124733292.png" alt="apt搜索nodejs的结果"></p><p>不难看出来，<code>apt</code>仓库里的<code>nodejs</code>的版本过低，因此我们需要自己从<code>nodejs</code>官网上下载新版本的<code>nodejs</code>，<a href="https://nodejs.org/zh-cn/">官网传送门</a></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113124918179.png" alt="Node.js的官网"></p><p>在我写这篇文章的时候最新版是16.13，由于遵循Linux的传统，双数版本是LTS（Long Time Supported）版本，而单数版本都是尝鲜（Beta）版本，所以选择<strong>稳定版即可</strong></p><p>下载之后解压会得到一个文件夹，这个文件夹里<code>bin</code>目录放的就是官方替我们已经编译好了的二进制可执行文件，可以看到除了node，别的都是软连接</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ tree -L 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意，我这里是已经安装过了<code>Node.js</code>，正常情况下是没有<code>cnpm</code>的，稍后会安装<code>cnpm</code></p></blockquote><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113125500195.png" alt="解压之后的文件夹"></p><p>由于后续需要在命令行中调用<code>Node.js</code>，因此还要把这个<code>bin</code>文件的路径加入到<code>Shell</code>搜索可执行文件路径的<code>PATH</code>环境变量中，这里图方便直接在.<code>bashrc</code>中添加了</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ vim ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113125903583.png" alt="添加了Node.js的PATH"></p><p>这样未来在命令行就可以正常的调用<code>node.js</code>和附带的<code>npm</code>了，测试一波</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113130048060.png" alt="测试Node.js"></p><p>OK，装完了<code>Node.js</code>，下一步</p><h3 id="2-安装cnpm"><a href="#2-安装cnpm" class="headerlink" title="2. 安装cnpm"></a>2. 安装cnpm</h3><p>前面讲到，Node.js中利用了Chrome V8引擎从而实现了JavaScript的运行时环境，从而做到了类似于解释器的效果。做过<code>Python</code>的人应该都会知道<code>pip</code>和<code>conda</code>，他们都是<code>Python</code>的包管理器（当然conda还可以管理环境）。通过<code>pip install xxx</code>或者<code>conda install xxx</code>就能安装Python的第三方库。</p><p><code>Node.js</code>也提供了类似的包管理工具，即<code>npm（Node.js Package Management）</code>，通过npm我们就能够安装<code>Node.js</code>的第三方库。</p><p>但是这些包管理工具的共性就是下载的这些库都是在包管理工具官网上维护的包，我们使用<code>xxx install xxx</code>的时候，会去<code>xxx</code>的包管理网站上搜索<code>xxx</code>包，然后下载。问题的关键就出在了下载这一步，由于这些包管理网站服务器都在国外，因此国内下载就会很慢。为此，我们通过换源来解决，即指定去国内的包管理网站上下载。在<code>pip</code>中我们可以指定<code>-i</code>参数，从而指定去清华源或者中科大源下载<code>Python</code>第三方包。而<code>npm</code>我们同样也可以指定<code>--registry</code>参数，从而指定国内的源（一般都是淘宝源）。</p><p>但是每次都使用<code>--registry</code>参数有点蠢，我们直接使用淘宝做好的<code>cnpm</code>包管理工具就行。<code>cnpm</code>和<code>npm</code>在作用上是一样的，不过对国内用户做了很不错的优化。</p><p>我们首先通过npm指定<code>--registry</code>参数来安装<code>cnpm</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ npm install -g cnpm --registry="https://registry.npm.taobao.org"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>稍等片刻即可，警告是已经安装的别的包报的错，都后面没啥影响，因为我已经安装过了cnpm，所以下面的截图和你的可能不一样</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113131609169.png" alt="安装cnpm"></p><p>安装之后检查下安装是否成功，当然由于路径等环境不一样，输出结果也不太一样，但是能够正常输出就表示安装对了</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ cnpm --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113131849887.png" alt="检查cnpm是否安装成功"></p><p>OK，下一步安装Git</p><h3 id="3-安装git"><a href="#3-安装git" class="headerlink" title="3. 安装git"></a>3. 安装git</h3><p>由于<code>Hexo</code>内置了博客的同步、部署等功能，因此<code>Hexo</code>依赖于<code>git</code>，所以我们首先需要安装<code>git</code></p><p>安装git就简单了，直接<code>apt</code>安装即可，同样由于我已经安装过了，所以输出会不一样</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ sudo apt install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113132146054.png" alt="apt安装git"></p><p>同样，查看下<code>git</code>的版本确认安装成功</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113132257442.png" alt="确认git安装成功"></p><h3 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4. 安装Hexo"></a>4. 安装Hexo</h3><p>在前面所有必备的环境安装成功后，下面将安装<code>Hexo</code></p><p>前面由于已经安装了<code>cnpm</code>，因此我们直接使用<code>cnpm</code>来安装<code>Hexo</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ cnpm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>稍等片刻就安装好了</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113132546043.png" alt="安装hexo"></p><p>为了后续我们能够直接在命令行调用<code>hexo</code>的命令，我们把<code>hexo</code>的可执行文件添加到<code>PATH</code>中去</p><p>注意，<code>npm</code>和<code>cnpm</code>的工作原理都是把下载的包放到<code>node.js</code>所在的根目录的<code>lib</code>中，和<code>pip</code>是异曲同工之秒，我们打开之前node.js在的文件夹就能看到</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113133034708.png" alt="hexo的安装位置"></p><p>同样用<code>vim</code>编辑<code>.bashrc</code></p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113133331507.png" alt="添加hexo可执行文件"></p><p>最后命令行查看下hexo的版本确认成功</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(base) jack@jack-Alienware-m15-R3:~/桌面/node-v16.13.0-linux-x64$ hexo --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211113133455333.png" alt="确认hexo安装成功"></p><p>至此，我们已经成功搭建了Hexo的环境。</p><p>本章结束~</p><p>本章我们首先讲解了什么是<code>hexo</code>，然后讲解了为什么我们要使用<code>hexo</code>，最后讲解了如何安装<code>hexo</code>。</p><p>下一节预告：<code>Hexo使用以及配置</code></p><p>码字不易，4000字，欢迎打赏~，一起为开源事业做贡献~</p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的个人技术博客搭建 —— Part 0 概述</title>
      <link href="/2021/11/12/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-0-gai-shu/"/>
      <url>/2021/11/12/ji-yu-hexo-de-ge-ren-ji-zhu-bo-ke-da-jian-part-0-gai-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章面向前端小白，希望以尽量简单而又不啰嗦的语言介绍如何搭建<code>基于Hexo的个人技术博客</code></p></blockquote><span id="more"></span><h1 id="基于Hexo的个人技术博客搭建-——-Part-0-概述"><a href="#基于Hexo的个人技术博客搭建-——-Part-0-概述" class="headerlink" title="基于Hexo的个人技术博客搭建 —— Part 0 概述"></a>基于Hexo的个人技术博客搭建 —— Part 0 概述</h1><p>作为一个热爱开源的技术爱好者，我热爱学习新的技术、也热衷分享自己掌握的技术。然而分享却并非易事，想要将你的开源技术以个人技术博客的形式分享到互联网上需要有以下的诸多步骤：</p><ol><li>掌握HTML、CSS、JavaScript、Vue.js、Node.js等前端技术，至少能够写出来一个静态网站；或者在静态网页的基础上掌握Nginx、Apache等等后端技术，为前端提供登陆等功能以实现一个动态网站。</li><li>购买具有公网IP的服务器以运行你的网站，使得任何想要访问你网站的人都能够通过公网上的服务器来访问你的网站。</li><li>购买一个域名并为其添加DNS解析、安装SSL证书</li><li>Optional：中国域名<strong>xxxx.xxxx.cn</strong>下的网站需要进行备案</li><li>配置你的服务器以避免来自公网上的攻击</li><li>……</li></ol><p>完成了以上诸多步骤，你的技术网站才能够被其他人访问，别人才能够正常的来阅读你的技术博客。<strong>如此繁琐的程序，往往在前几步就吓退了不少人</strong>。也正是因为如此，就出现了不少帮助我们分享技术的工具，例如：帮助我们快速搭建博客而不需要自己掌握前端技术的<code>WordPress</code>、帮助我们维护文章的<code>CSDN</code>、<code>知乎</code>、<code>简书</code>等等；然而这些工具，也有他们的缺点</p><ul><li><code>WordPress</code>：尽管<code>WordPress</code>使得我们可以可视化的建立、管理前端页面。但是首先，上面的流程中诸多步骤仍然需要自己来完成，购买公网服务器、购买域名等等都是不小的开销；其次<code>WordPress</code>类似于<code>Vscode</code>，具有一个强大的插件系统，即软件本身只具有一定的功能，更多的功能需要靠插件来实现。然而和<code>Vscode</code>不同的是<code>WordPress</code>上好用的插件是要收费的，而且价格不菲（<del>忽略掉万能的淘宝</del>）</li><li><code>CSDN</code>、<code>简书</code>、<code>博客园</code>：尽管类似于<code>CSDN</code>、<code>简书</code>、<code>博客园</code>等这类博客网站已经帮助我们完成了网站安全防护、搜索引擎优化、文章编辑发布和管理等功能，他们的问题存在于盗帖实在太过于严重，很多时候搜索自己需要解决的问题，结果搜出来的全都是一模一样的、爬虫复制粘贴的文章，对解决问题毫无帮助，自己的文章和这些垃圾文章在一起，实在是于心不忍；其次，作为<strong>一名优秀的程序员，拥有自己的技术博客网站将会极大地帮助自己的未来，无论是求职也好亦或是求学……</strong></li></ul><p>因此自己搭建一个博客就非常有必要了。</p><p>本系列最终将通过一系列文章，来帮助你低成本（<strong>可能也就几块钱</strong>）的构建出属于你自己的、美观的个人技术博客</p><p><img src="https://jack-1307599355.cos.ap-shanghai.myqcloud.com/img/image-20211112180102412.png" alt="最终效果展示"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
